// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `agent.proto`

//! Generated by "C:\\phf\\workspace\\security-compute\\code5\\kata-containers\\src\\libs\\protocols\\build.rs" ("build_script_build")

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.CreateContainerRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct CreateContainerRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.CreateContainerRequest.container_id)
    pub container_id: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.CreateContainerRequest.exec_id)
    pub exec_id: ::std::string::String,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.CreateContainerRequest.string_user)
    pub string_user: ::protobuf::MessageField<StringUser>,
    // @@protoc_insertion_point(field:grpc.CreateContainerRequest.devices)
    pub devices: ::std::vec::Vec<Device>,
    // @@protoc_insertion_point(field:grpc.CreateContainerRequest.storages)
    pub storages: ::std::vec::Vec<Storage>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.CreateContainerRequest.OCI)
    pub OCI: ::protobuf::MessageField<super::oci::Spec>,
    // @@protoc_insertion_point(field:grpc.CreateContainerRequest.sandbox_pidns)
    pub sandbox_pidns: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.CreateContainerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateContainerRequest {
    fn default() -> &'a CreateContainerRequest {
        <CreateContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateContainerRequest {
    pub fn new() -> CreateContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;

    pub fn container_id(&self) -> &str {
        &self.container_id
    }

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // .grpc.StringUser string_user = 3;

    pub fn string_user(&self) -> &StringUser {
        self.string_user.as_ref().unwrap_or_else(|| <StringUser as ::protobuf::Message>::default_instance())
    }

    pub fn clear_string_user(&mut self) {
        self.string_user.clear();
    }

    pub fn has_string_user(&self) -> bool {
        self.string_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_user(&mut self, v: StringUser) {
        self.string_user = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_user(&mut self) -> &mut StringUser {
        self.string_user.mut_or_insert_default()
    }

    // Take field
    pub fn take_string_user(&mut self) -> StringUser {
        self.string_user.take().unwrap_or_else(|| StringUser::new())
    }

    // repeated .grpc.Device devices = 4;

    pub fn devices(&self) -> &[Device] {
        &self.devices
    }

    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::std::vec::Vec<Device>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::std::vec::Vec<Device> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::std::vec::Vec<Device> {
        ::std::mem::replace(&mut self.devices, ::std::vec::Vec::new())
    }

    // repeated .grpc.Storage storages = 5;

    pub fn storages(&self) -> &[Storage] {
        &self.storages
    }

    pub fn clear_storages(&mut self) {
        self.storages.clear();
    }

    // Param is passed by value, moved
    pub fn set_storages(&mut self, v: ::std::vec::Vec<Storage>) {
        self.storages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storages(&mut self) -> &mut ::std::vec::Vec<Storage> {
        &mut self.storages
    }

    // Take field
    pub fn take_storages(&mut self) -> ::std::vec::Vec<Storage> {
        ::std::mem::replace(&mut self.storages, ::std::vec::Vec::new())
    }

    // .grpc.Spec OCI = 6;

    pub fn OCI(&self) -> &super::oci::Spec {
        self.OCI.as_ref().unwrap_or_else(|| <super::oci::Spec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_OCI(&mut self) {
        self.OCI.clear();
    }

    pub fn has_OCI(&self) -> bool {
        self.OCI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OCI(&mut self, v: super::oci::Spec) {
        self.OCI = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_OCI(&mut self) -> &mut super::oci::Spec {
        self.OCI.mut_or_insert_default()
    }

    // Take field
    pub fn take_OCI(&mut self) -> super::oci::Spec {
        self.OCI.take().unwrap_or_else(|| super::oci::Spec::new())
    }

    // bool sandbox_pidns = 7;

    pub fn sandbox_pidns(&self) -> bool {
        self.sandbox_pidns
    }

    pub fn clear_sandbox_pidns(&mut self) {
        self.sandbox_pidns = false;
    }

    // Param is passed by value, moved
    pub fn set_sandbox_pidns(&mut self, v: bool) {
        self.sandbox_pidns = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_id",
            |m: &CreateContainerRequest| { &m.container_id },
            |m: &mut CreateContainerRequest| { &mut m.container_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &CreateContainerRequest| { &m.exec_id },
            |m: &mut CreateContainerRequest| { &mut m.exec_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StringUser>(
            "string_user",
            |m: &CreateContainerRequest| { &m.string_user },
            |m: &mut CreateContainerRequest| { &mut m.string_user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "devices",
            |m: &CreateContainerRequest| { &m.devices },
            |m: &mut CreateContainerRequest| { &mut m.devices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "storages",
            |m: &CreateContainerRequest| { &m.storages },
            |m: &mut CreateContainerRequest| { &mut m.storages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::oci::Spec>(
            "OCI",
            |m: &CreateContainerRequest| { &m.OCI },
            |m: &mut CreateContainerRequest| { &mut m.OCI },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sandbox_pidns",
            |m: &CreateContainerRequest| { &m.sandbox_pidns },
            |m: &mut CreateContainerRequest| { &mut m.sandbox_pidns },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateContainerRequest>(
            "CreateContainerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateContainerRequest {
    const NAME: &'static str = "CreateContainerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.string_user)?;
                },
                34 => {
                    self.devices.push(is.read_message()?);
                },
                42 => {
                    self.storages.push(is.read_message()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.OCI)?;
                },
                56 => {
                    self.sandbox_pidns = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if let Some(v) = self.string_user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.storages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.OCI.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.sandbox_pidns != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if let Some(v) = self.string_user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.devices {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.storages {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.OCI.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if self.sandbox_pidns != false {
            os.write_bool(7, self.sandbox_pidns)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateContainerRequest {
        CreateContainerRequest::new()
    }

    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.string_user.clear();
        self.devices.clear();
        self.storages.clear();
        self.OCI.clear();
        self.sandbox_pidns = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateContainerRequest {
        static instance: CreateContainerRequest = CreateContainerRequest {
            container_id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            string_user: ::protobuf::MessageField::none(),
            devices: ::std::vec::Vec::new(),
            storages: ::std::vec::Vec::new(),
            OCI: ::protobuf::MessageField::none(),
            sandbox_pidns: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateContainerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateContainerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateContainerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.StartContainerRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct StartContainerRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.StartContainerRequest.container_id)
    pub container_id: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.StartContainerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartContainerRequest {
    fn default() -> &'a StartContainerRequest {
        <StartContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartContainerRequest {
    pub fn new() -> StartContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;

    pub fn container_id(&self) -> &str {
        &self.container_id
    }

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_id",
            |m: &StartContainerRequest| { &m.container_id },
            |m: &mut StartContainerRequest| { &mut m.container_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StartContainerRequest>(
            "StartContainerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StartContainerRequest {
    const NAME: &'static str = "StartContainerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartContainerRequest {
        StartContainerRequest::new()
    }

    fn clear(&mut self) {
        self.container_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartContainerRequest {
        static instance: StartContainerRequest = StartContainerRequest {
            container_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StartContainerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StartContainerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StartContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartContainerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.RemoveContainerRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct RemoveContainerRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.RemoveContainerRequest.container_id)
    pub container_id: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.RemoveContainerRequest.timeout)
    pub timeout: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.RemoveContainerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveContainerRequest {
    fn default() -> &'a RemoveContainerRequest {
        <RemoveContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveContainerRequest {
    pub fn new() -> RemoveContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;

    pub fn container_id(&self) -> &str {
        &self.container_id
    }

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // uint32 timeout = 2;

    pub fn timeout(&self) -> u32 {
        self.timeout
    }

    pub fn clear_timeout(&mut self) {
        self.timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_id",
            |m: &RemoveContainerRequest| { &m.container_id },
            |m: &mut RemoveContainerRequest| { &mut m.container_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timeout",
            |m: &RemoveContainerRequest| { &m.timeout },
            |m: &mut RemoveContainerRequest| { &mut m.timeout },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveContainerRequest>(
            "RemoveContainerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoveContainerRequest {
    const NAME: &'static str = "RemoveContainerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_id = is.read_string()?;
                },
                16 => {
                    self.timeout = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if self.timeout != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.timeout);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if self.timeout != 0 {
            os.write_uint32(2, self.timeout)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveContainerRequest {
        RemoveContainerRequest::new()
    }

    fn clear(&mut self) {
        self.container_id.clear();
        self.timeout = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveContainerRequest {
        static instance: RemoveContainerRequest = RemoveContainerRequest {
            container_id: ::std::string::String::new(),
            timeout: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemoveContainerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoveContainerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoveContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveContainerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.ExecProcessRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct ExecProcessRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.ExecProcessRequest.container_id)
    pub container_id: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.ExecProcessRequest.exec_id)
    pub exec_id: ::std::string::String,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.ExecProcessRequest.string_user)
    pub string_user: ::protobuf::MessageField<StringUser>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.ExecProcessRequest.process)
    pub process: ::protobuf::MessageField<super::oci::Process>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.ExecProcessRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExecProcessRequest {
    fn default() -> &'a ExecProcessRequest {
        <ExecProcessRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecProcessRequest {
    pub fn new() -> ExecProcessRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;

    pub fn container_id(&self) -> &str {
        &self.container_id
    }

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // .grpc.StringUser string_user = 3;

    pub fn string_user(&self) -> &StringUser {
        self.string_user.as_ref().unwrap_or_else(|| <StringUser as ::protobuf::Message>::default_instance())
    }

    pub fn clear_string_user(&mut self) {
        self.string_user.clear();
    }

    pub fn has_string_user(&self) -> bool {
        self.string_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_user(&mut self, v: StringUser) {
        self.string_user = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_user(&mut self) -> &mut StringUser {
        self.string_user.mut_or_insert_default()
    }

    // Take field
    pub fn take_string_user(&mut self) -> StringUser {
        self.string_user.take().unwrap_or_else(|| StringUser::new())
    }

    // .grpc.Process process = 4;

    pub fn process(&self) -> &super::oci::Process {
        self.process.as_ref().unwrap_or_else(|| <super::oci::Process as ::protobuf::Message>::default_instance())
    }

    pub fn clear_process(&mut self) {
        self.process.clear();
    }

    pub fn has_process(&self) -> bool {
        self.process.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process(&mut self, v: super::oci::Process) {
        self.process = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_process(&mut self) -> &mut super::oci::Process {
        self.process.mut_or_insert_default()
    }

    // Take field
    pub fn take_process(&mut self) -> super::oci::Process {
        self.process.take().unwrap_or_else(|| super::oci::Process::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_id",
            |m: &ExecProcessRequest| { &m.container_id },
            |m: &mut ExecProcessRequest| { &mut m.container_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &ExecProcessRequest| { &m.exec_id },
            |m: &mut ExecProcessRequest| { &mut m.exec_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StringUser>(
            "string_user",
            |m: &ExecProcessRequest| { &m.string_user },
            |m: &mut ExecProcessRequest| { &mut m.string_user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::oci::Process>(
            "process",
            |m: &ExecProcessRequest| { &m.process },
            |m: &mut ExecProcessRequest| { &mut m.process },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecProcessRequest>(
            "ExecProcessRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExecProcessRequest {
    const NAME: &'static str = "ExecProcessRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.string_user)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.process)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if let Some(v) = self.string_user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.process.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if let Some(v) = self.string_user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.process.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExecProcessRequest {
        ExecProcessRequest::new()
    }

    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.string_user.clear();
        self.process.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExecProcessRequest {
        static instance: ExecProcessRequest = ExecProcessRequest {
            container_id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            string_user: ::protobuf::MessageField::none(),
            process: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExecProcessRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExecProcessRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExecProcessRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecProcessRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.SignalProcessRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct SignalProcessRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.SignalProcessRequest.container_id)
    pub container_id: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.SignalProcessRequest.exec_id)
    pub exec_id: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.SignalProcessRequest.signal)
    pub signal: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.SignalProcessRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignalProcessRequest {
    fn default() -> &'a SignalProcessRequest {
        <SignalProcessRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignalProcessRequest {
    pub fn new() -> SignalProcessRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;

    pub fn container_id(&self) -> &str {
        &self.container_id
    }

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // uint32 signal = 3;

    pub fn signal(&self) -> u32 {
        self.signal
    }

    pub fn clear_signal(&mut self) {
        self.signal = 0;
    }

    // Param is passed by value, moved
    pub fn set_signal(&mut self, v: u32) {
        self.signal = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_id",
            |m: &SignalProcessRequest| { &m.container_id },
            |m: &mut SignalProcessRequest| { &mut m.container_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &SignalProcessRequest| { &m.exec_id },
            |m: &mut SignalProcessRequest| { &mut m.exec_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signal",
            |m: &SignalProcessRequest| { &m.signal },
            |m: &mut SignalProcessRequest| { &mut m.signal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignalProcessRequest>(
            "SignalProcessRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignalProcessRequest {
    const NAME: &'static str = "SignalProcessRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                24 => {
                    self.signal = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if self.signal != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.signal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if self.signal != 0 {
            os.write_uint32(3, self.signal)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignalProcessRequest {
        SignalProcessRequest::new()
    }

    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.signal = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignalProcessRequest {
        static instance: SignalProcessRequest = SignalProcessRequest {
            container_id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            signal: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignalProcessRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignalProcessRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignalProcessRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignalProcessRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.WaitProcessRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct WaitProcessRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.WaitProcessRequest.container_id)
    pub container_id: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.WaitProcessRequest.exec_id)
    pub exec_id: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.WaitProcessRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WaitProcessRequest {
    fn default() -> &'a WaitProcessRequest {
        <WaitProcessRequest as ::protobuf::Message>::default_instance()
    }
}

impl WaitProcessRequest {
    pub fn new() -> WaitProcessRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;

    pub fn container_id(&self) -> &str {
        &self.container_id
    }

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_id",
            |m: &WaitProcessRequest| { &m.container_id },
            |m: &mut WaitProcessRequest| { &mut m.container_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &WaitProcessRequest| { &m.exec_id },
            |m: &mut WaitProcessRequest| { &mut m.exec_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WaitProcessRequest>(
            "WaitProcessRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WaitProcessRequest {
    const NAME: &'static str = "WaitProcessRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WaitProcessRequest {
        WaitProcessRequest::new()
    }

    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WaitProcessRequest {
        static instance: WaitProcessRequest = WaitProcessRequest {
            container_id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WaitProcessRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WaitProcessRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WaitProcessRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitProcessRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.WaitProcessResponse)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct WaitProcessResponse {
    // message fields
    // @@protoc_insertion_point(field:grpc.WaitProcessResponse.status)
    pub status: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.WaitProcessResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WaitProcessResponse {
    fn default() -> &'a WaitProcessResponse {
        <WaitProcessResponse as ::protobuf::Message>::default_instance()
    }
}

impl WaitProcessResponse {
    pub fn new() -> WaitProcessResponse {
        ::std::default::Default::default()
    }

    // int32 status = 1;

    pub fn status(&self) -> i32 {
        self.status
    }

    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &WaitProcessResponse| { &m.status },
            |m: &mut WaitProcessResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WaitProcessResponse>(
            "WaitProcessResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WaitProcessResponse {
    const NAME: &'static str = "WaitProcessResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.status != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.status != 0 {
            os.write_int32(1, self.status)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WaitProcessResponse {
        WaitProcessResponse::new()
    }

    fn clear(&mut self) {
        self.status = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WaitProcessResponse {
        static instance: WaitProcessResponse = WaitProcessResponse {
            status: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WaitProcessResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WaitProcessResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WaitProcessResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitProcessResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.UpdateContainerRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct UpdateContainerRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.UpdateContainerRequest.container_id)
    pub container_id: ::std::string::String,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.UpdateContainerRequest.resources)
    pub resources: ::protobuf::MessageField<super::oci::LinuxResources>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.UpdateContainerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateContainerRequest {
    fn default() -> &'a UpdateContainerRequest {
        <UpdateContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateContainerRequest {
    pub fn new() -> UpdateContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;

    pub fn container_id(&self) -> &str {
        &self.container_id
    }

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // .grpc.LinuxResources resources = 2;

    pub fn resources(&self) -> &super::oci::LinuxResources {
        self.resources.as_ref().unwrap_or_else(|| <super::oci::LinuxResources as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    pub fn has_resources(&self) -> bool {
        self.resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: super::oci::LinuxResources) {
        self.resources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resources(&mut self) -> &mut super::oci::LinuxResources {
        self.resources.mut_or_insert_default()
    }

    // Take field
    pub fn take_resources(&mut self) -> super::oci::LinuxResources {
        self.resources.take().unwrap_or_else(|| super::oci::LinuxResources::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_id",
            |m: &UpdateContainerRequest| { &m.container_id },
            |m: &mut UpdateContainerRequest| { &mut m.container_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::oci::LinuxResources>(
            "resources",
            |m: &UpdateContainerRequest| { &m.resources },
            |m: &mut UpdateContainerRequest| { &mut m.resources },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateContainerRequest>(
            "UpdateContainerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateContainerRequest {
    const NAME: &'static str = "UpdateContainerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resources)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if let Some(v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if let Some(v) = self.resources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateContainerRequest {
        UpdateContainerRequest::new()
    }

    fn clear(&mut self) {
        self.container_id.clear();
        self.resources.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateContainerRequest {
        static instance: UpdateContainerRequest = UpdateContainerRequest {
            container_id: ::std::string::String::new(),
            resources: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateContainerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateContainerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateContainerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.StatsContainerRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct StatsContainerRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.StatsContainerRequest.container_id)
    pub container_id: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.StatsContainerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatsContainerRequest {
    fn default() -> &'a StatsContainerRequest {
        <StatsContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatsContainerRequest {
    pub fn new() -> StatsContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;

    pub fn container_id(&self) -> &str {
        &self.container_id
    }

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_id",
            |m: &StatsContainerRequest| { &m.container_id },
            |m: &mut StatsContainerRequest| { &mut m.container_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatsContainerRequest>(
            "StatsContainerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatsContainerRequest {
    const NAME: &'static str = "StatsContainerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatsContainerRequest {
        StatsContainerRequest::new()
    }

    fn clear(&mut self) {
        self.container_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatsContainerRequest {
        static instance: StatsContainerRequest = StatsContainerRequest {
            container_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatsContainerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatsContainerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatsContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatsContainerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.PauseContainerRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct PauseContainerRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.PauseContainerRequest.container_id)
    pub container_id: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.PauseContainerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PauseContainerRequest {
    fn default() -> &'a PauseContainerRequest {
        <PauseContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl PauseContainerRequest {
    pub fn new() -> PauseContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;

    pub fn container_id(&self) -> &str {
        &self.container_id
    }

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_id",
            |m: &PauseContainerRequest| { &m.container_id },
            |m: &mut PauseContainerRequest| { &mut m.container_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PauseContainerRequest>(
            "PauseContainerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PauseContainerRequest {
    const NAME: &'static str = "PauseContainerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PauseContainerRequest {
        PauseContainerRequest::new()
    }

    fn clear(&mut self) {
        self.container_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PauseContainerRequest {
        static instance: PauseContainerRequest = PauseContainerRequest {
            container_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PauseContainerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PauseContainerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PauseContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PauseContainerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.ResumeContainerRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct ResumeContainerRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.ResumeContainerRequest.container_id)
    pub container_id: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.ResumeContainerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResumeContainerRequest {
    fn default() -> &'a ResumeContainerRequest {
        <ResumeContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResumeContainerRequest {
    pub fn new() -> ResumeContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;

    pub fn container_id(&self) -> &str {
        &self.container_id
    }

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_id",
            |m: &ResumeContainerRequest| { &m.container_id },
            |m: &mut ResumeContainerRequest| { &mut m.container_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResumeContainerRequest>(
            "ResumeContainerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResumeContainerRequest {
    const NAME: &'static str = "ResumeContainerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResumeContainerRequest {
        ResumeContainerRequest::new()
    }

    fn clear(&mut self) {
        self.container_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResumeContainerRequest {
        static instance: ResumeContainerRequest = ResumeContainerRequest {
            container_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResumeContainerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResumeContainerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResumeContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResumeContainerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.CpuUsage)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct CpuUsage {
    // message fields
    // @@protoc_insertion_point(field:grpc.CpuUsage.total_usage)
    pub total_usage: u64,
    // @@protoc_insertion_point(field:grpc.CpuUsage.percpu_usage)
    pub percpu_usage: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:grpc.CpuUsage.usage_in_kernelmode)
    pub usage_in_kernelmode: u64,
    // @@protoc_insertion_point(field:grpc.CpuUsage.usage_in_usermode)
    pub usage_in_usermode: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.CpuUsage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CpuUsage {
    fn default() -> &'a CpuUsage {
        <CpuUsage as ::protobuf::Message>::default_instance()
    }
}

impl CpuUsage {
    pub fn new() -> CpuUsage {
        ::std::default::Default::default()
    }

    // uint64 total_usage = 1;

    pub fn total_usage(&self) -> u64 {
        self.total_usage
    }

    pub fn clear_total_usage(&mut self) {
        self.total_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_usage(&mut self, v: u64) {
        self.total_usage = v;
    }

    // repeated uint64 percpu_usage = 2;

    pub fn percpu_usage(&self) -> &[u64] {
        &self.percpu_usage
    }

    pub fn clear_percpu_usage(&mut self) {
        self.percpu_usage.clear();
    }

    // Param is passed by value, moved
    pub fn set_percpu_usage(&mut self, v: ::std::vec::Vec<u64>) {
        self.percpu_usage = v;
    }

    // Mutable pointer to the field.
    pub fn mut_percpu_usage(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.percpu_usage
    }

    // Take field
    pub fn take_percpu_usage(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.percpu_usage, ::std::vec::Vec::new())
    }

    // uint64 usage_in_kernelmode = 3;

    pub fn usage_in_kernelmode(&self) -> u64 {
        self.usage_in_kernelmode
    }

    pub fn clear_usage_in_kernelmode(&mut self) {
        self.usage_in_kernelmode = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage_in_kernelmode(&mut self, v: u64) {
        self.usage_in_kernelmode = v;
    }

    // uint64 usage_in_usermode = 4;

    pub fn usage_in_usermode(&self) -> u64 {
        self.usage_in_usermode
    }

    pub fn clear_usage_in_usermode(&mut self) {
        self.usage_in_usermode = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage_in_usermode(&mut self, v: u64) {
        self.usage_in_usermode = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_usage",
            |m: &CpuUsage| { &m.total_usage },
            |m: &mut CpuUsage| { &mut m.total_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "percpu_usage",
            |m: &CpuUsage| { &m.percpu_usage },
            |m: &mut CpuUsage| { &mut m.percpu_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "usage_in_kernelmode",
            |m: &CpuUsage| { &m.usage_in_kernelmode },
            |m: &mut CpuUsage| { &mut m.usage_in_kernelmode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "usage_in_usermode",
            |m: &CpuUsage| { &m.usage_in_usermode },
            |m: &mut CpuUsage| { &mut m.usage_in_usermode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CpuUsage>(
            "CpuUsage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CpuUsage {
    const NAME: &'static str = "CpuUsage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.total_usage = is.read_uint64()?;
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.percpu_usage)?;
                },
                16 => {
                    self.percpu_usage.push(is.read_uint64()?);
                },
                24 => {
                    self.usage_in_kernelmode = is.read_uint64()?;
                },
                32 => {
                    self.usage_in_usermode = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.total_usage != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.total_usage);
        }
        for value in &self.percpu_usage {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        if self.usage_in_kernelmode != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.usage_in_kernelmode);
        }
        if self.usage_in_usermode != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.usage_in_usermode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.total_usage != 0 {
            os.write_uint64(1, self.total_usage)?;
        }
        for v in &self.percpu_usage {
            os.write_uint64(2, *v)?;
        };
        if self.usage_in_kernelmode != 0 {
            os.write_uint64(3, self.usage_in_kernelmode)?;
        }
        if self.usage_in_usermode != 0 {
            os.write_uint64(4, self.usage_in_usermode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CpuUsage {
        CpuUsage::new()
    }

    fn clear(&mut self) {
        self.total_usage = 0;
        self.percpu_usage.clear();
        self.usage_in_kernelmode = 0;
        self.usage_in_usermode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CpuUsage {
        static instance: CpuUsage = CpuUsage {
            total_usage: 0,
            percpu_usage: ::std::vec::Vec::new(),
            usage_in_kernelmode: 0,
            usage_in_usermode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CpuUsage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CpuUsage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CpuUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CpuUsage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.ThrottlingData)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct ThrottlingData {
    // message fields
    // @@protoc_insertion_point(field:grpc.ThrottlingData.periods)
    pub periods: u64,
    // @@protoc_insertion_point(field:grpc.ThrottlingData.throttled_periods)
    pub throttled_periods: u64,
    // @@protoc_insertion_point(field:grpc.ThrottlingData.throttled_time)
    pub throttled_time: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.ThrottlingData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ThrottlingData {
    fn default() -> &'a ThrottlingData {
        <ThrottlingData as ::protobuf::Message>::default_instance()
    }
}

impl ThrottlingData {
    pub fn new() -> ThrottlingData {
        ::std::default::Default::default()
    }

    // uint64 periods = 1;

    pub fn periods(&self) -> u64 {
        self.periods
    }

    pub fn clear_periods(&mut self) {
        self.periods = 0;
    }

    // Param is passed by value, moved
    pub fn set_periods(&mut self, v: u64) {
        self.periods = v;
    }

    // uint64 throttled_periods = 2;

    pub fn throttled_periods(&self) -> u64 {
        self.throttled_periods
    }

    pub fn clear_throttled_periods(&mut self) {
        self.throttled_periods = 0;
    }

    // Param is passed by value, moved
    pub fn set_throttled_periods(&mut self, v: u64) {
        self.throttled_periods = v;
    }

    // uint64 throttled_time = 3;

    pub fn throttled_time(&self) -> u64 {
        self.throttled_time
    }

    pub fn clear_throttled_time(&mut self) {
        self.throttled_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_throttled_time(&mut self, v: u64) {
        self.throttled_time = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "periods",
            |m: &ThrottlingData| { &m.periods },
            |m: &mut ThrottlingData| { &mut m.periods },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "throttled_periods",
            |m: &ThrottlingData| { &m.throttled_periods },
            |m: &mut ThrottlingData| { &mut m.throttled_periods },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "throttled_time",
            |m: &ThrottlingData| { &m.throttled_time },
            |m: &mut ThrottlingData| { &mut m.throttled_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ThrottlingData>(
            "ThrottlingData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ThrottlingData {
    const NAME: &'static str = "ThrottlingData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.periods = is.read_uint64()?;
                },
                16 => {
                    self.throttled_periods = is.read_uint64()?;
                },
                24 => {
                    self.throttled_time = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.periods != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.periods);
        }
        if self.throttled_periods != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.throttled_periods);
        }
        if self.throttled_time != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.throttled_time);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.periods != 0 {
            os.write_uint64(1, self.periods)?;
        }
        if self.throttled_periods != 0 {
            os.write_uint64(2, self.throttled_periods)?;
        }
        if self.throttled_time != 0 {
            os.write_uint64(3, self.throttled_time)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ThrottlingData {
        ThrottlingData::new()
    }

    fn clear(&mut self) {
        self.periods = 0;
        self.throttled_periods = 0;
        self.throttled_time = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ThrottlingData {
        static instance: ThrottlingData = ThrottlingData {
            periods: 0,
            throttled_periods: 0,
            throttled_time: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ThrottlingData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ThrottlingData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ThrottlingData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThrottlingData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.CpuStats)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct CpuStats {
    // message fields
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.CpuStats.cpu_usage)
    pub cpu_usage: ::protobuf::MessageField<CpuUsage>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.CpuStats.throttling_data)
    pub throttling_data: ::protobuf::MessageField<ThrottlingData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.CpuStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CpuStats {
    fn default() -> &'a CpuStats {
        <CpuStats as ::protobuf::Message>::default_instance()
    }
}

impl CpuStats {
    pub fn new() -> CpuStats {
        ::std::default::Default::default()
    }

    // .grpc.CpuUsage cpu_usage = 1;

    pub fn cpu_usage(&self) -> &CpuUsage {
        self.cpu_usage.as_ref().unwrap_or_else(|| <CpuUsage as ::protobuf::Message>::default_instance())
    }

    pub fn clear_cpu_usage(&mut self) {
        self.cpu_usage.clear();
    }

    pub fn has_cpu_usage(&self) -> bool {
        self.cpu_usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_usage(&mut self, v: CpuUsage) {
        self.cpu_usage = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu_usage(&mut self) -> &mut CpuUsage {
        self.cpu_usage.mut_or_insert_default()
    }

    // Take field
    pub fn take_cpu_usage(&mut self) -> CpuUsage {
        self.cpu_usage.take().unwrap_or_else(|| CpuUsage::new())
    }

    // .grpc.ThrottlingData throttling_data = 2;

    pub fn throttling_data(&self) -> &ThrottlingData {
        self.throttling_data.as_ref().unwrap_or_else(|| <ThrottlingData as ::protobuf::Message>::default_instance())
    }

    pub fn clear_throttling_data(&mut self) {
        self.throttling_data.clear();
    }

    pub fn has_throttling_data(&self) -> bool {
        self.throttling_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttling_data(&mut self, v: ThrottlingData) {
        self.throttling_data = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_throttling_data(&mut self) -> &mut ThrottlingData {
        self.throttling_data.mut_or_insert_default()
    }

    // Take field
    pub fn take_throttling_data(&mut self) -> ThrottlingData {
        self.throttling_data.take().unwrap_or_else(|| ThrottlingData::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CpuUsage>(
            "cpu_usage",
            |m: &CpuStats| { &m.cpu_usage },
            |m: &mut CpuStats| { &mut m.cpu_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ThrottlingData>(
            "throttling_data",
            |m: &CpuStats| { &m.throttling_data },
            |m: &mut CpuStats| { &mut m.throttling_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CpuStats>(
            "CpuStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CpuStats {
    const NAME: &'static str = "CpuStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cpu_usage)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.throttling_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cpu_usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.throttling_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cpu_usage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.throttling_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CpuStats {
        CpuStats::new()
    }

    fn clear(&mut self) {
        self.cpu_usage.clear();
        self.throttling_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CpuStats {
        static instance: CpuStats = CpuStats {
            cpu_usage: ::protobuf::MessageField::none(),
            throttling_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CpuStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CpuStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CpuStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CpuStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.PidsStats)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct PidsStats {
    // message fields
    // @@protoc_insertion_point(field:grpc.PidsStats.current)
    pub current: u64,
    // @@protoc_insertion_point(field:grpc.PidsStats.limit)
    pub limit: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.PidsStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PidsStats {
    fn default() -> &'a PidsStats {
        <PidsStats as ::protobuf::Message>::default_instance()
    }
}

impl PidsStats {
    pub fn new() -> PidsStats {
        ::std::default::Default::default()
    }

    // uint64 current = 1;

    pub fn current(&self) -> u64 {
        self.current
    }

    pub fn clear_current(&mut self) {
        self.current = 0;
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: u64) {
        self.current = v;
    }

    // uint64 limit = 2;

    pub fn limit(&self) -> u64 {
        self.limit
    }

    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current",
            |m: &PidsStats| { &m.current },
            |m: &mut PidsStats| { &mut m.current },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &PidsStats| { &m.limit },
            |m: &mut PidsStats| { &mut m.limit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PidsStats>(
            "PidsStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PidsStats {
    const NAME: &'static str = "PidsStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.current = is.read_uint64()?;
                },
                16 => {
                    self.limit = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.current != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.current);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.current != 0 {
            os.write_uint64(1, self.current)?;
        }
        if self.limit != 0 {
            os.write_uint64(2, self.limit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PidsStats {
        PidsStats::new()
    }

    fn clear(&mut self) {
        self.current = 0;
        self.limit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PidsStats {
        static instance: PidsStats = PidsStats {
            current: 0,
            limit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PidsStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PidsStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PidsStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PidsStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.MemoryData)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct MemoryData {
    // message fields
    // @@protoc_insertion_point(field:grpc.MemoryData.usage)
    pub usage: u64,
    // @@protoc_insertion_point(field:grpc.MemoryData.max_usage)
    pub max_usage: u64,
    // @@protoc_insertion_point(field:grpc.MemoryData.failcnt)
    pub failcnt: u64,
    // @@protoc_insertion_point(field:grpc.MemoryData.limit)
    pub limit: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.MemoryData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MemoryData {
    fn default() -> &'a MemoryData {
        <MemoryData as ::protobuf::Message>::default_instance()
    }
}

impl MemoryData {
    pub fn new() -> MemoryData {
        ::std::default::Default::default()
    }

    // uint64 usage = 1;

    pub fn usage(&self) -> u64 {
        self.usage
    }

    pub fn clear_usage(&mut self) {
        self.usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: u64) {
        self.usage = v;
    }

    // uint64 max_usage = 2;

    pub fn max_usage(&self) -> u64 {
        self.max_usage
    }

    pub fn clear_max_usage(&mut self) {
        self.max_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_usage(&mut self, v: u64) {
        self.max_usage = v;
    }

    // uint64 failcnt = 3;

    pub fn failcnt(&self) -> u64 {
        self.failcnt
    }

    pub fn clear_failcnt(&mut self) {
        self.failcnt = 0;
    }

    // Param is passed by value, moved
    pub fn set_failcnt(&mut self, v: u64) {
        self.failcnt = v;
    }

    // uint64 limit = 4;

    pub fn limit(&self) -> u64 {
        self.limit
    }

    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "usage",
            |m: &MemoryData| { &m.usage },
            |m: &mut MemoryData| { &mut m.usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_usage",
            |m: &MemoryData| { &m.max_usage },
            |m: &mut MemoryData| { &mut m.max_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "failcnt",
            |m: &MemoryData| { &m.failcnt },
            |m: &mut MemoryData| { &mut m.failcnt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &MemoryData| { &m.limit },
            |m: &mut MemoryData| { &mut m.limit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MemoryData>(
            "MemoryData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MemoryData {
    const NAME: &'static str = "MemoryData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.usage = is.read_uint64()?;
                },
                16 => {
                    self.max_usage = is.read_uint64()?;
                },
                24 => {
                    self.failcnt = is.read_uint64()?;
                },
                32 => {
                    self.limit = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.usage != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.usage);
        }
        if self.max_usage != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.max_usage);
        }
        if self.failcnt != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.failcnt);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.usage != 0 {
            os.write_uint64(1, self.usage)?;
        }
        if self.max_usage != 0 {
            os.write_uint64(2, self.max_usage)?;
        }
        if self.failcnt != 0 {
            os.write_uint64(3, self.failcnt)?;
        }
        if self.limit != 0 {
            os.write_uint64(4, self.limit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MemoryData {
        MemoryData::new()
    }

    fn clear(&mut self) {
        self.usage = 0;
        self.max_usage = 0;
        self.failcnt = 0;
        self.limit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MemoryData {
        static instance: MemoryData = MemoryData {
            usage: 0,
            max_usage: 0,
            failcnt: 0,
            limit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MemoryData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MemoryData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MemoryData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemoryData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.MemoryStats)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct MemoryStats {
    // message fields
    // @@protoc_insertion_point(field:grpc.MemoryStats.cache)
    pub cache: u64,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.MemoryStats.usage)
    pub usage: ::protobuf::MessageField<MemoryData>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.MemoryStats.swap_usage)
    pub swap_usage: ::protobuf::MessageField<MemoryData>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.MemoryStats.kernel_usage)
    pub kernel_usage: ::protobuf::MessageField<MemoryData>,
    // @@protoc_insertion_point(field:grpc.MemoryStats.use_hierarchy)
    pub use_hierarchy: bool,
    // @@protoc_insertion_point(field:grpc.MemoryStats.stats)
    pub stats: ::std::collections::HashMap<::std::string::String, u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.MemoryStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MemoryStats {
    fn default() -> &'a MemoryStats {
        <MemoryStats as ::protobuf::Message>::default_instance()
    }
}

impl MemoryStats {
    pub fn new() -> MemoryStats {
        ::std::default::Default::default()
    }

    // uint64 cache = 1;

    pub fn cache(&self) -> u64 {
        self.cache
    }

    pub fn clear_cache(&mut self) {
        self.cache = 0;
    }

    // Param is passed by value, moved
    pub fn set_cache(&mut self, v: u64) {
        self.cache = v;
    }

    // .grpc.MemoryData usage = 2;

    pub fn usage(&self) -> &MemoryData {
        self.usage.as_ref().unwrap_or_else(|| <MemoryData as ::protobuf::Message>::default_instance())
    }

    pub fn clear_usage(&mut self) {
        self.usage.clear();
    }

    pub fn has_usage(&self) -> bool {
        self.usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: MemoryData) {
        self.usage = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_usage(&mut self) -> &mut MemoryData {
        self.usage.mut_or_insert_default()
    }

    // Take field
    pub fn take_usage(&mut self) -> MemoryData {
        self.usage.take().unwrap_or_else(|| MemoryData::new())
    }

    // .grpc.MemoryData swap_usage = 3;

    pub fn swap_usage(&self) -> &MemoryData {
        self.swap_usage.as_ref().unwrap_or_else(|| <MemoryData as ::protobuf::Message>::default_instance())
    }

    pub fn clear_swap_usage(&mut self) {
        self.swap_usage.clear();
    }

    pub fn has_swap_usage(&self) -> bool {
        self.swap_usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swap_usage(&mut self, v: MemoryData) {
        self.swap_usage = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_swap_usage(&mut self) -> &mut MemoryData {
        self.swap_usage.mut_or_insert_default()
    }

    // Take field
    pub fn take_swap_usage(&mut self) -> MemoryData {
        self.swap_usage.take().unwrap_or_else(|| MemoryData::new())
    }

    // .grpc.MemoryData kernel_usage = 4;

    pub fn kernel_usage(&self) -> &MemoryData {
        self.kernel_usage.as_ref().unwrap_or_else(|| <MemoryData as ::protobuf::Message>::default_instance())
    }

    pub fn clear_kernel_usage(&mut self) {
        self.kernel_usage.clear();
    }

    pub fn has_kernel_usage(&self) -> bool {
        self.kernel_usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kernel_usage(&mut self, v: MemoryData) {
        self.kernel_usage = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kernel_usage(&mut self) -> &mut MemoryData {
        self.kernel_usage.mut_or_insert_default()
    }

    // Take field
    pub fn take_kernel_usage(&mut self) -> MemoryData {
        self.kernel_usage.take().unwrap_or_else(|| MemoryData::new())
    }

    // bool use_hierarchy = 5;

    pub fn use_hierarchy(&self) -> bool {
        self.use_hierarchy
    }

    pub fn clear_use_hierarchy(&mut self) {
        self.use_hierarchy = false;
    }

    // Param is passed by value, moved
    pub fn set_use_hierarchy(&mut self, v: bool) {
        self.use_hierarchy = v;
    }

    // repeated .grpc.MemoryStats.StatsEntry stats = 6;

    pub fn stats(&self) -> &::std::collections::HashMap<::std::string::String, u64> {
        &self.stats
    }

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::std::collections::HashMap<::std::string::String, u64>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, u64> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::std::collections::HashMap<::std::string::String, u64> {
        ::std::mem::replace(&mut self.stats, ::std::collections::HashMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cache",
            |m: &MemoryStats| { &m.cache },
            |m: &mut MemoryStats| { &mut m.cache },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MemoryData>(
            "usage",
            |m: &MemoryStats| { &m.usage },
            |m: &mut MemoryStats| { &mut m.usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MemoryData>(
            "swap_usage",
            |m: &MemoryStats| { &m.swap_usage },
            |m: &mut MemoryStats| { &mut m.swap_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MemoryData>(
            "kernel_usage",
            |m: &MemoryStats| { &m.kernel_usage },
            |m: &mut MemoryStats| { &mut m.kernel_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "use_hierarchy",
            |m: &MemoryStats| { &m.use_hierarchy },
            |m: &mut MemoryStats| { &mut m.use_hierarchy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "stats",
            |m: &MemoryStats| { &m.stats },
            |m: &mut MemoryStats| { &mut m.stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MemoryStats>(
            "MemoryStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MemoryStats {
    const NAME: &'static str = "MemoryStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cache = is.read_uint64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.usage)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.swap_usage)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.kernel_usage)?;
                },
                40 => {
                    self.use_hierarchy = is.read_bool()?;
                },
                50 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            16 => value = is.read_uint64()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.stats.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.cache != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.cache);
        }
        if let Some(v) = self.usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.swap_usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.kernel_usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.use_hierarchy != false {
            my_size += 1 + 1;
        }
        for (k, v) in &self.stats {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::uint64_size(2, *v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.cache != 0 {
            os.write_uint64(1, self.cache)?;
        }
        if let Some(v) = self.usage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.swap_usage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.kernel_usage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.use_hierarchy != false {
            os.write_bool(5, self.use_hierarchy)?;
        }
        for (k, v) in &self.stats {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::uint64_size(2, *v);
            os.write_raw_varint32(50)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MemoryStats {
        MemoryStats::new()
    }

    fn clear(&mut self) {
        self.cache = 0;
        self.usage.clear();
        self.swap_usage.clear();
        self.kernel_usage.clear();
        self.use_hierarchy = false;
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MemoryStats {
        static instance: ::protobuf::rt::Lazy<MemoryStats> = ::protobuf::rt::Lazy::new();
        instance.get(MemoryStats::new)
    }
}

impl ::protobuf::MessageFull for MemoryStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MemoryStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MemoryStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemoryStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.BlkioStatsEntry)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct BlkioStatsEntry {
    // message fields
    // @@protoc_insertion_point(field:grpc.BlkioStatsEntry.major)
    pub major: u64,
    // @@protoc_insertion_point(field:grpc.BlkioStatsEntry.minor)
    pub minor: u64,
    // @@protoc_insertion_point(field:grpc.BlkioStatsEntry.op)
    pub op: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.BlkioStatsEntry.value)
    pub value: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.BlkioStatsEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlkioStatsEntry {
    fn default() -> &'a BlkioStatsEntry {
        <BlkioStatsEntry as ::protobuf::Message>::default_instance()
    }
}

impl BlkioStatsEntry {
    pub fn new() -> BlkioStatsEntry {
        ::std::default::Default::default()
    }

    // uint64 major = 1;

    pub fn major(&self) -> u64 {
        self.major
    }

    pub fn clear_major(&mut self) {
        self.major = 0;
    }

    // Param is passed by value, moved
    pub fn set_major(&mut self, v: u64) {
        self.major = v;
    }

    // uint64 minor = 2;

    pub fn minor(&self) -> u64 {
        self.minor
    }

    pub fn clear_minor(&mut self) {
        self.minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_minor(&mut self, v: u64) {
        self.minor = v;
    }

    // string op = 3;

    pub fn op(&self) -> &str {
        &self.op
    }

    pub fn clear_op(&mut self) {
        self.op.clear();
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: ::std::string::String) {
        self.op = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op(&mut self) -> &mut ::std::string::String {
        &mut self.op
    }

    // Take field
    pub fn take_op(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.op, ::std::string::String::new())
    }

    // uint64 value = 4;

    pub fn value(&self) -> u64 {
        self.value
    }

    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "major",
            |m: &BlkioStatsEntry| { &m.major },
            |m: &mut BlkioStatsEntry| { &mut m.major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minor",
            |m: &BlkioStatsEntry| { &m.minor },
            |m: &mut BlkioStatsEntry| { &mut m.minor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "op",
            |m: &BlkioStatsEntry| { &m.op },
            |m: &mut BlkioStatsEntry| { &mut m.op },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &BlkioStatsEntry| { &m.value },
            |m: &mut BlkioStatsEntry| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlkioStatsEntry>(
            "BlkioStatsEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlkioStatsEntry {
    const NAME: &'static str = "BlkioStatsEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.major = is.read_uint64()?;
                },
                16 => {
                    self.minor = is.read_uint64()?;
                },
                26 => {
                    self.op = is.read_string()?;
                },
                32 => {
                    self.value = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.major != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.major);
        }
        if self.minor != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.minor);
        }
        if !self.op.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.op);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.major != 0 {
            os.write_uint64(1, self.major)?;
        }
        if self.minor != 0 {
            os.write_uint64(2, self.minor)?;
        }
        if !self.op.is_empty() {
            os.write_string(3, &self.op)?;
        }
        if self.value != 0 {
            os.write_uint64(4, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlkioStatsEntry {
        BlkioStatsEntry::new()
    }

    fn clear(&mut self) {
        self.major = 0;
        self.minor = 0;
        self.op.clear();
        self.value = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlkioStatsEntry {
        static instance: BlkioStatsEntry = BlkioStatsEntry {
            major: 0,
            minor: 0,
            op: ::std::string::String::new(),
            value: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlkioStatsEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlkioStatsEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlkioStatsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlkioStatsEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.BlkioStats)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct BlkioStats {
    // message fields
    // @@protoc_insertion_point(field:grpc.BlkioStats.io_service_bytes_recursive)
    pub io_service_bytes_recursive: ::std::vec::Vec<BlkioStatsEntry>,
    // @@protoc_insertion_point(field:grpc.BlkioStats.io_serviced_recursive)
    pub io_serviced_recursive: ::std::vec::Vec<BlkioStatsEntry>,
    // @@protoc_insertion_point(field:grpc.BlkioStats.io_queued_recursive)
    pub io_queued_recursive: ::std::vec::Vec<BlkioStatsEntry>,
    // @@protoc_insertion_point(field:grpc.BlkioStats.io_service_time_recursive)
    pub io_service_time_recursive: ::std::vec::Vec<BlkioStatsEntry>,
    // @@protoc_insertion_point(field:grpc.BlkioStats.io_wait_time_recursive)
    pub io_wait_time_recursive: ::std::vec::Vec<BlkioStatsEntry>,
    // @@protoc_insertion_point(field:grpc.BlkioStats.io_merged_recursive)
    pub io_merged_recursive: ::std::vec::Vec<BlkioStatsEntry>,
    // @@protoc_insertion_point(field:grpc.BlkioStats.io_time_recursive)
    pub io_time_recursive: ::std::vec::Vec<BlkioStatsEntry>,
    // @@protoc_insertion_point(field:grpc.BlkioStats.sectors_recursive)
    pub sectors_recursive: ::std::vec::Vec<BlkioStatsEntry>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.BlkioStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlkioStats {
    fn default() -> &'a BlkioStats {
        <BlkioStats as ::protobuf::Message>::default_instance()
    }
}

impl BlkioStats {
    pub fn new() -> BlkioStats {
        ::std::default::Default::default()
    }

    // repeated .grpc.BlkioStatsEntry io_service_bytes_recursive = 1;

    pub fn io_service_bytes_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_service_bytes_recursive
    }

    pub fn clear_io_service_bytes_recursive(&mut self) {
        self.io_service_bytes_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_service_bytes_recursive(&mut self, v: ::std::vec::Vec<BlkioStatsEntry>) {
        self.io_service_bytes_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_service_bytes_recursive(&mut self) -> &mut ::std::vec::Vec<BlkioStatsEntry> {
        &mut self.io_service_bytes_recursive
    }

    // Take field
    pub fn take_io_service_bytes_recursive(&mut self) -> ::std::vec::Vec<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_service_bytes_recursive, ::std::vec::Vec::new())
    }

    // repeated .grpc.BlkioStatsEntry io_serviced_recursive = 2;

    pub fn io_serviced_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_serviced_recursive
    }

    pub fn clear_io_serviced_recursive(&mut self) {
        self.io_serviced_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_serviced_recursive(&mut self, v: ::std::vec::Vec<BlkioStatsEntry>) {
        self.io_serviced_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_serviced_recursive(&mut self) -> &mut ::std::vec::Vec<BlkioStatsEntry> {
        &mut self.io_serviced_recursive
    }

    // Take field
    pub fn take_io_serviced_recursive(&mut self) -> ::std::vec::Vec<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_serviced_recursive, ::std::vec::Vec::new())
    }

    // repeated .grpc.BlkioStatsEntry io_queued_recursive = 3;

    pub fn io_queued_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_queued_recursive
    }

    pub fn clear_io_queued_recursive(&mut self) {
        self.io_queued_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_queued_recursive(&mut self, v: ::std::vec::Vec<BlkioStatsEntry>) {
        self.io_queued_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_queued_recursive(&mut self) -> &mut ::std::vec::Vec<BlkioStatsEntry> {
        &mut self.io_queued_recursive
    }

    // Take field
    pub fn take_io_queued_recursive(&mut self) -> ::std::vec::Vec<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_queued_recursive, ::std::vec::Vec::new())
    }

    // repeated .grpc.BlkioStatsEntry io_service_time_recursive = 4;

    pub fn io_service_time_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_service_time_recursive
    }

    pub fn clear_io_service_time_recursive(&mut self) {
        self.io_service_time_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_service_time_recursive(&mut self, v: ::std::vec::Vec<BlkioStatsEntry>) {
        self.io_service_time_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_service_time_recursive(&mut self) -> &mut ::std::vec::Vec<BlkioStatsEntry> {
        &mut self.io_service_time_recursive
    }

    // Take field
    pub fn take_io_service_time_recursive(&mut self) -> ::std::vec::Vec<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_service_time_recursive, ::std::vec::Vec::new())
    }

    // repeated .grpc.BlkioStatsEntry io_wait_time_recursive = 5;

    pub fn io_wait_time_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_wait_time_recursive
    }

    pub fn clear_io_wait_time_recursive(&mut self) {
        self.io_wait_time_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_wait_time_recursive(&mut self, v: ::std::vec::Vec<BlkioStatsEntry>) {
        self.io_wait_time_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_wait_time_recursive(&mut self) -> &mut ::std::vec::Vec<BlkioStatsEntry> {
        &mut self.io_wait_time_recursive
    }

    // Take field
    pub fn take_io_wait_time_recursive(&mut self) -> ::std::vec::Vec<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_wait_time_recursive, ::std::vec::Vec::new())
    }

    // repeated .grpc.BlkioStatsEntry io_merged_recursive = 6;

    pub fn io_merged_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_merged_recursive
    }

    pub fn clear_io_merged_recursive(&mut self) {
        self.io_merged_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_merged_recursive(&mut self, v: ::std::vec::Vec<BlkioStatsEntry>) {
        self.io_merged_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_merged_recursive(&mut self) -> &mut ::std::vec::Vec<BlkioStatsEntry> {
        &mut self.io_merged_recursive
    }

    // Take field
    pub fn take_io_merged_recursive(&mut self) -> ::std::vec::Vec<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_merged_recursive, ::std::vec::Vec::new())
    }

    // repeated .grpc.BlkioStatsEntry io_time_recursive = 7;

    pub fn io_time_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_time_recursive
    }

    pub fn clear_io_time_recursive(&mut self) {
        self.io_time_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_time_recursive(&mut self, v: ::std::vec::Vec<BlkioStatsEntry>) {
        self.io_time_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_time_recursive(&mut self) -> &mut ::std::vec::Vec<BlkioStatsEntry> {
        &mut self.io_time_recursive
    }

    // Take field
    pub fn take_io_time_recursive(&mut self) -> ::std::vec::Vec<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_time_recursive, ::std::vec::Vec::new())
    }

    // repeated .grpc.BlkioStatsEntry sectors_recursive = 8;

    pub fn sectors_recursive(&self) -> &[BlkioStatsEntry] {
        &self.sectors_recursive
    }

    pub fn clear_sectors_recursive(&mut self) {
        self.sectors_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_sectors_recursive(&mut self, v: ::std::vec::Vec<BlkioStatsEntry>) {
        self.sectors_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sectors_recursive(&mut self) -> &mut ::std::vec::Vec<BlkioStatsEntry> {
        &mut self.sectors_recursive
    }

    // Take field
    pub fn take_sectors_recursive(&mut self) -> ::std::vec::Vec<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.sectors_recursive, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "io_service_bytes_recursive",
            |m: &BlkioStats| { &m.io_service_bytes_recursive },
            |m: &mut BlkioStats| { &mut m.io_service_bytes_recursive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "io_serviced_recursive",
            |m: &BlkioStats| { &m.io_serviced_recursive },
            |m: &mut BlkioStats| { &mut m.io_serviced_recursive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "io_queued_recursive",
            |m: &BlkioStats| { &m.io_queued_recursive },
            |m: &mut BlkioStats| { &mut m.io_queued_recursive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "io_service_time_recursive",
            |m: &BlkioStats| { &m.io_service_time_recursive },
            |m: &mut BlkioStats| { &mut m.io_service_time_recursive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "io_wait_time_recursive",
            |m: &BlkioStats| { &m.io_wait_time_recursive },
            |m: &mut BlkioStats| { &mut m.io_wait_time_recursive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "io_merged_recursive",
            |m: &BlkioStats| { &m.io_merged_recursive },
            |m: &mut BlkioStats| { &mut m.io_merged_recursive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "io_time_recursive",
            |m: &BlkioStats| { &m.io_time_recursive },
            |m: &mut BlkioStats| { &mut m.io_time_recursive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sectors_recursive",
            |m: &BlkioStats| { &m.sectors_recursive },
            |m: &mut BlkioStats| { &mut m.sectors_recursive },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlkioStats>(
            "BlkioStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlkioStats {
    const NAME: &'static str = "BlkioStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.io_service_bytes_recursive.push(is.read_message()?);
                },
                18 => {
                    self.io_serviced_recursive.push(is.read_message()?);
                },
                26 => {
                    self.io_queued_recursive.push(is.read_message()?);
                },
                34 => {
                    self.io_service_time_recursive.push(is.read_message()?);
                },
                42 => {
                    self.io_wait_time_recursive.push(is.read_message()?);
                },
                50 => {
                    self.io_merged_recursive.push(is.read_message()?);
                },
                58 => {
                    self.io_time_recursive.push(is.read_message()?);
                },
                66 => {
                    self.sectors_recursive.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.io_service_bytes_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.io_serviced_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.io_queued_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.io_service_time_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.io_wait_time_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.io_merged_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.io_time_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.sectors_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.io_service_bytes_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.io_serviced_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.io_queued_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.io_service_time_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.io_wait_time_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.io_merged_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.io_time_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.sectors_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlkioStats {
        BlkioStats::new()
    }

    fn clear(&mut self) {
        self.io_service_bytes_recursive.clear();
        self.io_serviced_recursive.clear();
        self.io_queued_recursive.clear();
        self.io_service_time_recursive.clear();
        self.io_wait_time_recursive.clear();
        self.io_merged_recursive.clear();
        self.io_time_recursive.clear();
        self.sectors_recursive.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlkioStats {
        static instance: BlkioStats = BlkioStats {
            io_service_bytes_recursive: ::std::vec::Vec::new(),
            io_serviced_recursive: ::std::vec::Vec::new(),
            io_queued_recursive: ::std::vec::Vec::new(),
            io_service_time_recursive: ::std::vec::Vec::new(),
            io_wait_time_recursive: ::std::vec::Vec::new(),
            io_merged_recursive: ::std::vec::Vec::new(),
            io_time_recursive: ::std::vec::Vec::new(),
            sectors_recursive: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlkioStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlkioStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlkioStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlkioStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.HugetlbStats)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct HugetlbStats {
    // message fields
    // @@protoc_insertion_point(field:grpc.HugetlbStats.usage)
    pub usage: u64,
    // @@protoc_insertion_point(field:grpc.HugetlbStats.max_usage)
    pub max_usage: u64,
    // @@protoc_insertion_point(field:grpc.HugetlbStats.failcnt)
    pub failcnt: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.HugetlbStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HugetlbStats {
    fn default() -> &'a HugetlbStats {
        <HugetlbStats as ::protobuf::Message>::default_instance()
    }
}

impl HugetlbStats {
    pub fn new() -> HugetlbStats {
        ::std::default::Default::default()
    }

    // uint64 usage = 1;

    pub fn usage(&self) -> u64 {
        self.usage
    }

    pub fn clear_usage(&mut self) {
        self.usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: u64) {
        self.usage = v;
    }

    // uint64 max_usage = 2;

    pub fn max_usage(&self) -> u64 {
        self.max_usage
    }

    pub fn clear_max_usage(&mut self) {
        self.max_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_usage(&mut self, v: u64) {
        self.max_usage = v;
    }

    // uint64 failcnt = 3;

    pub fn failcnt(&self) -> u64 {
        self.failcnt
    }

    pub fn clear_failcnt(&mut self) {
        self.failcnt = 0;
    }

    // Param is passed by value, moved
    pub fn set_failcnt(&mut self, v: u64) {
        self.failcnt = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "usage",
            |m: &HugetlbStats| { &m.usage },
            |m: &mut HugetlbStats| { &mut m.usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_usage",
            |m: &HugetlbStats| { &m.max_usage },
            |m: &mut HugetlbStats| { &mut m.max_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "failcnt",
            |m: &HugetlbStats| { &m.failcnt },
            |m: &mut HugetlbStats| { &mut m.failcnt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HugetlbStats>(
            "HugetlbStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HugetlbStats {
    const NAME: &'static str = "HugetlbStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.usage = is.read_uint64()?;
                },
                16 => {
                    self.max_usage = is.read_uint64()?;
                },
                24 => {
                    self.failcnt = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.usage != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.usage);
        }
        if self.max_usage != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.max_usage);
        }
        if self.failcnt != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.failcnt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.usage != 0 {
            os.write_uint64(1, self.usage)?;
        }
        if self.max_usage != 0 {
            os.write_uint64(2, self.max_usage)?;
        }
        if self.failcnt != 0 {
            os.write_uint64(3, self.failcnt)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HugetlbStats {
        HugetlbStats::new()
    }

    fn clear(&mut self) {
        self.usage = 0;
        self.max_usage = 0;
        self.failcnt = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HugetlbStats {
        static instance: HugetlbStats = HugetlbStats {
            usage: 0,
            max_usage: 0,
            failcnt: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HugetlbStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HugetlbStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HugetlbStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HugetlbStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.CgroupStats)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct CgroupStats {
    // message fields
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.CgroupStats.cpu_stats)
    pub cpu_stats: ::protobuf::MessageField<CpuStats>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.CgroupStats.memory_stats)
    pub memory_stats: ::protobuf::MessageField<MemoryStats>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.CgroupStats.pids_stats)
    pub pids_stats: ::protobuf::MessageField<PidsStats>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.CgroupStats.blkio_stats)
    pub blkio_stats: ::protobuf::MessageField<BlkioStats>,
    // @@protoc_insertion_point(field:grpc.CgroupStats.hugetlb_stats)
    pub hugetlb_stats: ::std::collections::HashMap<::std::string::String, HugetlbStats>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.CgroupStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CgroupStats {
    fn default() -> &'a CgroupStats {
        <CgroupStats as ::protobuf::Message>::default_instance()
    }
}

impl CgroupStats {
    pub fn new() -> CgroupStats {
        ::std::default::Default::default()
    }

    // .grpc.CpuStats cpu_stats = 1;

    pub fn cpu_stats(&self) -> &CpuStats {
        self.cpu_stats.as_ref().unwrap_or_else(|| <CpuStats as ::protobuf::Message>::default_instance())
    }

    pub fn clear_cpu_stats(&mut self) {
        self.cpu_stats.clear();
    }

    pub fn has_cpu_stats(&self) -> bool {
        self.cpu_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_stats(&mut self, v: CpuStats) {
        self.cpu_stats = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu_stats(&mut self) -> &mut CpuStats {
        self.cpu_stats.mut_or_insert_default()
    }

    // Take field
    pub fn take_cpu_stats(&mut self) -> CpuStats {
        self.cpu_stats.take().unwrap_or_else(|| CpuStats::new())
    }

    // .grpc.MemoryStats memory_stats = 2;

    pub fn memory_stats(&self) -> &MemoryStats {
        self.memory_stats.as_ref().unwrap_or_else(|| <MemoryStats as ::protobuf::Message>::default_instance())
    }

    pub fn clear_memory_stats(&mut self) {
        self.memory_stats.clear();
    }

    pub fn has_memory_stats(&self) -> bool {
        self.memory_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory_stats(&mut self, v: MemoryStats) {
        self.memory_stats = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memory_stats(&mut self) -> &mut MemoryStats {
        self.memory_stats.mut_or_insert_default()
    }

    // Take field
    pub fn take_memory_stats(&mut self) -> MemoryStats {
        self.memory_stats.take().unwrap_or_else(|| MemoryStats::new())
    }

    // .grpc.PidsStats pids_stats = 3;

    pub fn pids_stats(&self) -> &PidsStats {
        self.pids_stats.as_ref().unwrap_or_else(|| <PidsStats as ::protobuf::Message>::default_instance())
    }

    pub fn clear_pids_stats(&mut self) {
        self.pids_stats.clear();
    }

    pub fn has_pids_stats(&self) -> bool {
        self.pids_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pids_stats(&mut self, v: PidsStats) {
        self.pids_stats = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pids_stats(&mut self) -> &mut PidsStats {
        self.pids_stats.mut_or_insert_default()
    }

    // Take field
    pub fn take_pids_stats(&mut self) -> PidsStats {
        self.pids_stats.take().unwrap_or_else(|| PidsStats::new())
    }

    // .grpc.BlkioStats blkio_stats = 4;

    pub fn blkio_stats(&self) -> &BlkioStats {
        self.blkio_stats.as_ref().unwrap_or_else(|| <BlkioStats as ::protobuf::Message>::default_instance())
    }

    pub fn clear_blkio_stats(&mut self) {
        self.blkio_stats.clear();
    }

    pub fn has_blkio_stats(&self) -> bool {
        self.blkio_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blkio_stats(&mut self, v: BlkioStats) {
        self.blkio_stats = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blkio_stats(&mut self) -> &mut BlkioStats {
        self.blkio_stats.mut_or_insert_default()
    }

    // Take field
    pub fn take_blkio_stats(&mut self) -> BlkioStats {
        self.blkio_stats.take().unwrap_or_else(|| BlkioStats::new())
    }

    // repeated .grpc.CgroupStats.HugetlbStatsEntry hugetlb_stats = 5;

    pub fn hugetlb_stats(&self) -> &::std::collections::HashMap<::std::string::String, HugetlbStats> {
        &self.hugetlb_stats
    }

    pub fn clear_hugetlb_stats(&mut self) {
        self.hugetlb_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_hugetlb_stats(&mut self, v: ::std::collections::HashMap<::std::string::String, HugetlbStats>) {
        self.hugetlb_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hugetlb_stats(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, HugetlbStats> {
        &mut self.hugetlb_stats
    }

    // Take field
    pub fn take_hugetlb_stats(&mut self) -> ::std::collections::HashMap<::std::string::String, HugetlbStats> {
        ::std::mem::replace(&mut self.hugetlb_stats, ::std::collections::HashMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CpuStats>(
            "cpu_stats",
            |m: &CgroupStats| { &m.cpu_stats },
            |m: &mut CgroupStats| { &mut m.cpu_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MemoryStats>(
            "memory_stats",
            |m: &CgroupStats| { &m.memory_stats },
            |m: &mut CgroupStats| { &mut m.memory_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PidsStats>(
            "pids_stats",
            |m: &CgroupStats| { &m.pids_stats },
            |m: &mut CgroupStats| { &mut m.pids_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlkioStats>(
            "blkio_stats",
            |m: &CgroupStats| { &m.blkio_stats },
            |m: &mut CgroupStats| { &mut m.blkio_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "hugetlb_stats",
            |m: &CgroupStats| { &m.hugetlb_stats },
            |m: &mut CgroupStats| { &mut m.hugetlb_stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CgroupStats>(
            "CgroupStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CgroupStats {
    const NAME: &'static str = "CgroupStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cpu_stats)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.memory_stats)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pids_stats)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.blkio_stats)?;
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.hugetlb_stats.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cpu_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.memory_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pids_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.blkio_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.hugetlb_stats {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cpu_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.memory_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.pids_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.blkio_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for (k, v) in &self.hugetlb_stats {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CgroupStats {
        CgroupStats::new()
    }

    fn clear(&mut self) {
        self.cpu_stats.clear();
        self.memory_stats.clear();
        self.pids_stats.clear();
        self.blkio_stats.clear();
        self.hugetlb_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CgroupStats {
        static instance: ::protobuf::rt::Lazy<CgroupStats> = ::protobuf::rt::Lazy::new();
        instance.get(CgroupStats::new)
    }
}

impl ::protobuf::MessageFull for CgroupStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CgroupStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CgroupStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CgroupStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.NetworkStats)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct NetworkStats {
    // message fields
    // @@protoc_insertion_point(field:grpc.NetworkStats.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.NetworkStats.rx_bytes)
    pub rx_bytes: u64,
    // @@protoc_insertion_point(field:grpc.NetworkStats.rx_packets)
    pub rx_packets: u64,
    // @@protoc_insertion_point(field:grpc.NetworkStats.rx_errors)
    pub rx_errors: u64,
    // @@protoc_insertion_point(field:grpc.NetworkStats.rx_dropped)
    pub rx_dropped: u64,
    // @@protoc_insertion_point(field:grpc.NetworkStats.tx_bytes)
    pub tx_bytes: u64,
    // @@protoc_insertion_point(field:grpc.NetworkStats.tx_packets)
    pub tx_packets: u64,
    // @@protoc_insertion_point(field:grpc.NetworkStats.tx_errors)
    pub tx_errors: u64,
    // @@protoc_insertion_point(field:grpc.NetworkStats.tx_dropped)
    pub tx_dropped: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.NetworkStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkStats {
    fn default() -> &'a NetworkStats {
        <NetworkStats as ::protobuf::Message>::default_instance()
    }
}

impl NetworkStats {
    pub fn new() -> NetworkStats {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 rx_bytes = 2;

    pub fn rx_bytes(&self) -> u64 {
        self.rx_bytes
    }

    pub fn clear_rx_bytes(&mut self) {
        self.rx_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_bytes(&mut self, v: u64) {
        self.rx_bytes = v;
    }

    // uint64 rx_packets = 3;

    pub fn rx_packets(&self) -> u64 {
        self.rx_packets
    }

    pub fn clear_rx_packets(&mut self) {
        self.rx_packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_packets(&mut self, v: u64) {
        self.rx_packets = v;
    }

    // uint64 rx_errors = 4;

    pub fn rx_errors(&self) -> u64 {
        self.rx_errors
    }

    pub fn clear_rx_errors(&mut self) {
        self.rx_errors = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_errors(&mut self, v: u64) {
        self.rx_errors = v;
    }

    // uint64 rx_dropped = 5;

    pub fn rx_dropped(&self) -> u64 {
        self.rx_dropped
    }

    pub fn clear_rx_dropped(&mut self) {
        self.rx_dropped = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_dropped(&mut self, v: u64) {
        self.rx_dropped = v;
    }

    // uint64 tx_bytes = 6;

    pub fn tx_bytes(&self) -> u64 {
        self.tx_bytes
    }

    pub fn clear_tx_bytes(&mut self) {
        self.tx_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_bytes(&mut self, v: u64) {
        self.tx_bytes = v;
    }

    // uint64 tx_packets = 7;

    pub fn tx_packets(&self) -> u64 {
        self.tx_packets
    }

    pub fn clear_tx_packets(&mut self) {
        self.tx_packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_packets(&mut self, v: u64) {
        self.tx_packets = v;
    }

    // uint64 tx_errors = 8;

    pub fn tx_errors(&self) -> u64 {
        self.tx_errors
    }

    pub fn clear_tx_errors(&mut self) {
        self.tx_errors = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_errors(&mut self, v: u64) {
        self.tx_errors = v;
    }

    // uint64 tx_dropped = 9;

    pub fn tx_dropped(&self) -> u64 {
        self.tx_dropped
    }

    pub fn clear_tx_dropped(&mut self) {
        self.tx_dropped = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_dropped(&mut self, v: u64) {
        self.tx_dropped = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &NetworkStats| { &m.name },
            |m: &mut NetworkStats| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rx_bytes",
            |m: &NetworkStats| { &m.rx_bytes },
            |m: &mut NetworkStats| { &mut m.rx_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rx_packets",
            |m: &NetworkStats| { &m.rx_packets },
            |m: &mut NetworkStats| { &mut m.rx_packets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rx_errors",
            |m: &NetworkStats| { &m.rx_errors },
            |m: &mut NetworkStats| { &mut m.rx_errors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rx_dropped",
            |m: &NetworkStats| { &m.rx_dropped },
            |m: &mut NetworkStats| { &mut m.rx_dropped },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx_bytes",
            |m: &NetworkStats| { &m.tx_bytes },
            |m: &mut NetworkStats| { &mut m.tx_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx_packets",
            |m: &NetworkStats| { &m.tx_packets },
            |m: &mut NetworkStats| { &mut m.tx_packets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx_errors",
            |m: &NetworkStats| { &m.tx_errors },
            |m: &mut NetworkStats| { &mut m.tx_errors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx_dropped",
            |m: &NetworkStats| { &m.tx_dropped },
            |m: &mut NetworkStats| { &mut m.tx_dropped },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkStats>(
            "NetworkStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkStats {
    const NAME: &'static str = "NetworkStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.rx_bytes = is.read_uint64()?;
                },
                24 => {
                    self.rx_packets = is.read_uint64()?;
                },
                32 => {
                    self.rx_errors = is.read_uint64()?;
                },
                40 => {
                    self.rx_dropped = is.read_uint64()?;
                },
                48 => {
                    self.tx_bytes = is.read_uint64()?;
                },
                56 => {
                    self.tx_packets = is.read_uint64()?;
                },
                64 => {
                    self.tx_errors = is.read_uint64()?;
                },
                72 => {
                    self.tx_dropped = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.rx_bytes != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.rx_bytes);
        }
        if self.rx_packets != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.rx_packets);
        }
        if self.rx_errors != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.rx_errors);
        }
        if self.rx_dropped != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.rx_dropped);
        }
        if self.tx_bytes != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.tx_bytes);
        }
        if self.tx_packets != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.tx_packets);
        }
        if self.tx_errors != 0 {
            my_size += ::protobuf::rt::uint64_size(8, self.tx_errors);
        }
        if self.tx_dropped != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.tx_dropped);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.rx_bytes != 0 {
            os.write_uint64(2, self.rx_bytes)?;
        }
        if self.rx_packets != 0 {
            os.write_uint64(3, self.rx_packets)?;
        }
        if self.rx_errors != 0 {
            os.write_uint64(4, self.rx_errors)?;
        }
        if self.rx_dropped != 0 {
            os.write_uint64(5, self.rx_dropped)?;
        }
        if self.tx_bytes != 0 {
            os.write_uint64(6, self.tx_bytes)?;
        }
        if self.tx_packets != 0 {
            os.write_uint64(7, self.tx_packets)?;
        }
        if self.tx_errors != 0 {
            os.write_uint64(8, self.tx_errors)?;
        }
        if self.tx_dropped != 0 {
            os.write_uint64(9, self.tx_dropped)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkStats {
        NetworkStats::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.rx_bytes = 0;
        self.rx_packets = 0;
        self.rx_errors = 0;
        self.rx_dropped = 0;
        self.tx_bytes = 0;
        self.tx_packets = 0;
        self.tx_errors = 0;
        self.tx_dropped = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkStats {
        static instance: NetworkStats = NetworkStats {
            name: ::std::string::String::new(),
            rx_bytes: 0,
            rx_packets: 0,
            rx_errors: 0,
            rx_dropped: 0,
            tx_bytes: 0,
            tx_packets: 0,
            tx_errors: 0,
            tx_dropped: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.StatsContainerResponse)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct StatsContainerResponse {
    // message fields
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.StatsContainerResponse.cgroup_stats)
    pub cgroup_stats: ::protobuf::MessageField<CgroupStats>,
    // @@protoc_insertion_point(field:grpc.StatsContainerResponse.network_stats)
    pub network_stats: ::std::vec::Vec<NetworkStats>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.StatsContainerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatsContainerResponse {
    fn default() -> &'a StatsContainerResponse {
        <StatsContainerResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatsContainerResponse {
    pub fn new() -> StatsContainerResponse {
        ::std::default::Default::default()
    }

    // .grpc.CgroupStats cgroup_stats = 1;

    pub fn cgroup_stats(&self) -> &CgroupStats {
        self.cgroup_stats.as_ref().unwrap_or_else(|| <CgroupStats as ::protobuf::Message>::default_instance())
    }

    pub fn clear_cgroup_stats(&mut self) {
        self.cgroup_stats.clear();
    }

    pub fn has_cgroup_stats(&self) -> bool {
        self.cgroup_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cgroup_stats(&mut self, v: CgroupStats) {
        self.cgroup_stats = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cgroup_stats(&mut self) -> &mut CgroupStats {
        self.cgroup_stats.mut_or_insert_default()
    }

    // Take field
    pub fn take_cgroup_stats(&mut self) -> CgroupStats {
        self.cgroup_stats.take().unwrap_or_else(|| CgroupStats::new())
    }

    // repeated .grpc.NetworkStats network_stats = 2;

    pub fn network_stats(&self) -> &[NetworkStats] {
        &self.network_stats
    }

    pub fn clear_network_stats(&mut self) {
        self.network_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_network_stats(&mut self, v: ::std::vec::Vec<NetworkStats>) {
        self.network_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_network_stats(&mut self) -> &mut ::std::vec::Vec<NetworkStats> {
        &mut self.network_stats
    }

    // Take field
    pub fn take_network_stats(&mut self) -> ::std::vec::Vec<NetworkStats> {
        ::std::mem::replace(&mut self.network_stats, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CgroupStats>(
            "cgroup_stats",
            |m: &StatsContainerResponse| { &m.cgroup_stats },
            |m: &mut StatsContainerResponse| { &mut m.cgroup_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "network_stats",
            |m: &StatsContainerResponse| { &m.network_stats },
            |m: &mut StatsContainerResponse| { &mut m.network_stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatsContainerResponse>(
            "StatsContainerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatsContainerResponse {
    const NAME: &'static str = "StatsContainerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cgroup_stats)?;
                },
                18 => {
                    self.network_stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cgroup_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.network_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cgroup_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.network_stats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatsContainerResponse {
        StatsContainerResponse::new()
    }

    fn clear(&mut self) {
        self.cgroup_stats.clear();
        self.network_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatsContainerResponse {
        static instance: StatsContainerResponse = StatsContainerResponse {
            cgroup_stats: ::protobuf::MessageField::none(),
            network_stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatsContainerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatsContainerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatsContainerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatsContainerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.WriteStreamRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct WriteStreamRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.WriteStreamRequest.container_id)
    pub container_id: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.WriteStreamRequest.exec_id)
    pub exec_id: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.WriteStreamRequest.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.WriteStreamRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteStreamRequest {
    fn default() -> &'a WriteStreamRequest {
        <WriteStreamRequest as ::protobuf::Message>::default_instance()
    }
}

impl WriteStreamRequest {
    pub fn new() -> WriteStreamRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;

    pub fn container_id(&self) -> &str {
        &self.container_id
    }

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // bytes data = 3;

    pub fn data(&self) -> &[u8] {
        &self.data
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_id",
            |m: &WriteStreamRequest| { &m.container_id },
            |m: &mut WriteStreamRequest| { &mut m.container_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &WriteStreamRequest| { &m.exec_id },
            |m: &mut WriteStreamRequest| { &mut m.exec_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &WriteStreamRequest| { &m.data },
            |m: &mut WriteStreamRequest| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteStreamRequest>(
            "WriteStreamRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteStreamRequest {
    const NAME: &'static str = "WriteStreamRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                26 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteStreamRequest {
        WriteStreamRequest::new()
    }

    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteStreamRequest {
        static instance: WriteStreamRequest = WriteStreamRequest {
            container_id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteStreamRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteStreamRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteStreamRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteStreamRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.WriteStreamResponse)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct WriteStreamResponse {
    // message fields
    // @@protoc_insertion_point(field:grpc.WriteStreamResponse.len)
    pub len: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.WriteStreamResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteStreamResponse {
    fn default() -> &'a WriteStreamResponse {
        <WriteStreamResponse as ::protobuf::Message>::default_instance()
    }
}

impl WriteStreamResponse {
    pub fn new() -> WriteStreamResponse {
        ::std::default::Default::default()
    }

    // uint32 len = 1;

    pub fn len(&self) -> u32 {
        self.len
    }

    pub fn clear_len(&mut self) {
        self.len = 0;
    }

    // Param is passed by value, moved
    pub fn set_len(&mut self, v: u32) {
        self.len = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "len",
            |m: &WriteStreamResponse| { &m.len },
            |m: &mut WriteStreamResponse| { &mut m.len },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteStreamResponse>(
            "WriteStreamResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteStreamResponse {
    const NAME: &'static str = "WriteStreamResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.len = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.len != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.len);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.len != 0 {
            os.write_uint32(1, self.len)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteStreamResponse {
        WriteStreamResponse::new()
    }

    fn clear(&mut self) {
        self.len = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteStreamResponse {
        static instance: WriteStreamResponse = WriteStreamResponse {
            len: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteStreamResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteStreamResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteStreamResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteStreamResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.ReadStreamRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct ReadStreamRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.ReadStreamRequest.container_id)
    pub container_id: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.ReadStreamRequest.exec_id)
    pub exec_id: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.ReadStreamRequest.len)
    pub len: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.ReadStreamRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadStreamRequest {
    fn default() -> &'a ReadStreamRequest {
        <ReadStreamRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReadStreamRequest {
    pub fn new() -> ReadStreamRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;

    pub fn container_id(&self) -> &str {
        &self.container_id
    }

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // uint32 len = 3;

    pub fn len(&self) -> u32 {
        self.len
    }

    pub fn clear_len(&mut self) {
        self.len = 0;
    }

    // Param is passed by value, moved
    pub fn set_len(&mut self, v: u32) {
        self.len = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_id",
            |m: &ReadStreamRequest| { &m.container_id },
            |m: &mut ReadStreamRequest| { &mut m.container_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &ReadStreamRequest| { &m.exec_id },
            |m: &mut ReadStreamRequest| { &mut m.exec_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "len",
            |m: &ReadStreamRequest| { &m.len },
            |m: &mut ReadStreamRequest| { &mut m.len },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadStreamRequest>(
            "ReadStreamRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadStreamRequest {
    const NAME: &'static str = "ReadStreamRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                24 => {
                    self.len = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if self.len != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.len);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if self.len != 0 {
            os.write_uint32(3, self.len)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadStreamRequest {
        ReadStreamRequest::new()
    }

    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.len = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadStreamRequest {
        static instance: ReadStreamRequest = ReadStreamRequest {
            container_id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            len: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadStreamRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadStreamRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadStreamRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadStreamRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.ReadStreamResponse)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct ReadStreamResponse {
    // message fields
    // @@protoc_insertion_point(field:grpc.ReadStreamResponse.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.ReadStreamResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadStreamResponse {
    fn default() -> &'a ReadStreamResponse {
        <ReadStreamResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReadStreamResponse {
    pub fn new() -> ReadStreamResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;

    pub fn data(&self) -> &[u8] {
        &self.data
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &ReadStreamResponse| { &m.data },
            |m: &mut ReadStreamResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadStreamResponse>(
            "ReadStreamResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadStreamResponse {
    const NAME: &'static str = "ReadStreamResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadStreamResponse {
        ReadStreamResponse::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadStreamResponse {
        static instance: ReadStreamResponse = ReadStreamResponse {
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadStreamResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadStreamResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadStreamResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadStreamResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.CloseStdinRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct CloseStdinRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.CloseStdinRequest.container_id)
    pub container_id: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.CloseStdinRequest.exec_id)
    pub exec_id: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.CloseStdinRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CloseStdinRequest {
    fn default() -> &'a CloseStdinRequest {
        <CloseStdinRequest as ::protobuf::Message>::default_instance()
    }
}

impl CloseStdinRequest {
    pub fn new() -> CloseStdinRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;

    pub fn container_id(&self) -> &str {
        &self.container_id
    }

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_id",
            |m: &CloseStdinRequest| { &m.container_id },
            |m: &mut CloseStdinRequest| { &mut m.container_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &CloseStdinRequest| { &m.exec_id },
            |m: &mut CloseStdinRequest| { &mut m.exec_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CloseStdinRequest>(
            "CloseStdinRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CloseStdinRequest {
    const NAME: &'static str = "CloseStdinRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CloseStdinRequest {
        CloseStdinRequest::new()
    }

    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CloseStdinRequest {
        static instance: CloseStdinRequest = CloseStdinRequest {
            container_id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CloseStdinRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CloseStdinRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CloseStdinRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseStdinRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.TtyWinResizeRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct TtyWinResizeRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.TtyWinResizeRequest.container_id)
    pub container_id: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.TtyWinResizeRequest.exec_id)
    pub exec_id: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.TtyWinResizeRequest.row)
    pub row: u32,
    // @@protoc_insertion_point(field:grpc.TtyWinResizeRequest.column)
    pub column: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.TtyWinResizeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TtyWinResizeRequest {
    fn default() -> &'a TtyWinResizeRequest {
        <TtyWinResizeRequest as ::protobuf::Message>::default_instance()
    }
}

impl TtyWinResizeRequest {
    pub fn new() -> TtyWinResizeRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;

    pub fn container_id(&self) -> &str {
        &self.container_id
    }

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // uint32 row = 3;

    pub fn row(&self) -> u32 {
        self.row
    }

    pub fn clear_row(&mut self) {
        self.row = 0;
    }

    // Param is passed by value, moved
    pub fn set_row(&mut self, v: u32) {
        self.row = v;
    }

    // uint32 column = 4;

    pub fn column(&self) -> u32 {
        self.column
    }

    pub fn clear_column(&mut self) {
        self.column = 0;
    }

    // Param is passed by value, moved
    pub fn set_column(&mut self, v: u32) {
        self.column = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_id",
            |m: &TtyWinResizeRequest| { &m.container_id },
            |m: &mut TtyWinResizeRequest| { &mut m.container_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &TtyWinResizeRequest| { &m.exec_id },
            |m: &mut TtyWinResizeRequest| { &mut m.exec_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "row",
            |m: &TtyWinResizeRequest| { &m.row },
            |m: &mut TtyWinResizeRequest| { &mut m.row },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "column",
            |m: &TtyWinResizeRequest| { &m.column },
            |m: &mut TtyWinResizeRequest| { &mut m.column },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TtyWinResizeRequest>(
            "TtyWinResizeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TtyWinResizeRequest {
    const NAME: &'static str = "TtyWinResizeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                24 => {
                    self.row = is.read_uint32()?;
                },
                32 => {
                    self.column = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if self.row != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.row);
        }
        if self.column != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.column);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if self.row != 0 {
            os.write_uint32(3, self.row)?;
        }
        if self.column != 0 {
            os.write_uint32(4, self.column)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TtyWinResizeRequest {
        TtyWinResizeRequest::new()
    }

    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.row = 0;
        self.column = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TtyWinResizeRequest {
        static instance: TtyWinResizeRequest = TtyWinResizeRequest {
            container_id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            row: 0,
            column: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TtyWinResizeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TtyWinResizeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TtyWinResizeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TtyWinResizeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.KernelModule)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct KernelModule {
    // message fields
    // @@protoc_insertion_point(field:grpc.KernelModule.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.KernelModule.parameters)
    pub parameters: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.KernelModule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KernelModule {
    fn default() -> &'a KernelModule {
        <KernelModule as ::protobuf::Message>::default_instance()
    }
}

impl KernelModule {
    pub fn new() -> KernelModule {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string parameters = 2;

    pub fn parameters(&self) -> &[::std::string::String] {
        &self.parameters
    }

    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameters(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.parameters
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.parameters, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &KernelModule| { &m.name },
            |m: &mut KernelModule| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "parameters",
            |m: &KernelModule| { &m.parameters },
            |m: &mut KernelModule| { &mut m.parameters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KernelModule>(
            "KernelModule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KernelModule {
    const NAME: &'static str = "KernelModule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.parameters.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.parameters {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.parameters {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KernelModule {
        KernelModule::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.parameters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KernelModule {
        static instance: KernelModule = KernelModule {
            name: ::std::string::String::new(),
            parameters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KernelModule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KernelModule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KernelModule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KernelModule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.CreateSandboxRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct CreateSandboxRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.CreateSandboxRequest.hostname)
    pub hostname: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.CreateSandboxRequest.dns)
    pub dns: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.CreateSandboxRequest.storages)
    pub storages: ::std::vec::Vec<Storage>,
    // @@protoc_insertion_point(field:grpc.CreateSandboxRequest.sandbox_pidns)
    pub sandbox_pidns: bool,
    // @@protoc_insertion_point(field:grpc.CreateSandboxRequest.sandbox_id)
    pub sandbox_id: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.CreateSandboxRequest.guest_hook_path)
    pub guest_hook_path: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.CreateSandboxRequest.kernel_modules)
    pub kernel_modules: ::std::vec::Vec<KernelModule>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.CreateSandboxRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateSandboxRequest {
    fn default() -> &'a CreateSandboxRequest {
        <CreateSandboxRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateSandboxRequest {
    pub fn new() -> CreateSandboxRequest {
        ::std::default::Default::default()
    }

    // string hostname = 1;

    pub fn hostname(&self) -> &str {
        &self.hostname
    }

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        &mut self.hostname
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hostname, ::std::string::String::new())
    }

    // repeated string dns = 2;

    pub fn dns(&self) -> &[::std::string::String] {
        &self.dns
    }

    pub fn clear_dns(&mut self) {
        self.dns.clear();
    }

    // Param is passed by value, moved
    pub fn set_dns(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.dns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dns(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.dns
    }

    // Take field
    pub fn take_dns(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.dns, ::std::vec::Vec::new())
    }

    // repeated .grpc.Storage storages = 3;

    pub fn storages(&self) -> &[Storage] {
        &self.storages
    }

    pub fn clear_storages(&mut self) {
        self.storages.clear();
    }

    // Param is passed by value, moved
    pub fn set_storages(&mut self, v: ::std::vec::Vec<Storage>) {
        self.storages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storages(&mut self) -> &mut ::std::vec::Vec<Storage> {
        &mut self.storages
    }

    // Take field
    pub fn take_storages(&mut self) -> ::std::vec::Vec<Storage> {
        ::std::mem::replace(&mut self.storages, ::std::vec::Vec::new())
    }

    // bool sandbox_pidns = 4;

    pub fn sandbox_pidns(&self) -> bool {
        self.sandbox_pidns
    }

    pub fn clear_sandbox_pidns(&mut self) {
        self.sandbox_pidns = false;
    }

    // Param is passed by value, moved
    pub fn set_sandbox_pidns(&mut self, v: bool) {
        self.sandbox_pidns = v;
    }

    // string sandbox_id = 5;

    pub fn sandbox_id(&self) -> &str {
        &self.sandbox_id
    }

    pub fn clear_sandbox_id(&mut self) {
        self.sandbox_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_sandbox_id(&mut self, v: ::std::string::String) {
        self.sandbox_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sandbox_id(&mut self) -> &mut ::std::string::String {
        &mut self.sandbox_id
    }

    // Take field
    pub fn take_sandbox_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sandbox_id, ::std::string::String::new())
    }

    // string guest_hook_path = 6;

    pub fn guest_hook_path(&self) -> &str {
        &self.guest_hook_path
    }

    pub fn clear_guest_hook_path(&mut self) {
        self.guest_hook_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_guest_hook_path(&mut self, v: ::std::string::String) {
        self.guest_hook_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guest_hook_path(&mut self) -> &mut ::std::string::String {
        &mut self.guest_hook_path
    }

    // Take field
    pub fn take_guest_hook_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.guest_hook_path, ::std::string::String::new())
    }

    // repeated .grpc.KernelModule kernel_modules = 7;

    pub fn kernel_modules(&self) -> &[KernelModule] {
        &self.kernel_modules
    }

    pub fn clear_kernel_modules(&mut self) {
        self.kernel_modules.clear();
    }

    // Param is passed by value, moved
    pub fn set_kernel_modules(&mut self, v: ::std::vec::Vec<KernelModule>) {
        self.kernel_modules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kernel_modules(&mut self) -> &mut ::std::vec::Vec<KernelModule> {
        &mut self.kernel_modules
    }

    // Take field
    pub fn take_kernel_modules(&mut self) -> ::std::vec::Vec<KernelModule> {
        ::std::mem::replace(&mut self.kernel_modules, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hostname",
            |m: &CreateSandboxRequest| { &m.hostname },
            |m: &mut CreateSandboxRequest| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dns",
            |m: &CreateSandboxRequest| { &m.dns },
            |m: &mut CreateSandboxRequest| { &mut m.dns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "storages",
            |m: &CreateSandboxRequest| { &m.storages },
            |m: &mut CreateSandboxRequest| { &mut m.storages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sandbox_pidns",
            |m: &CreateSandboxRequest| { &m.sandbox_pidns },
            |m: &mut CreateSandboxRequest| { &mut m.sandbox_pidns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sandbox_id",
            |m: &CreateSandboxRequest| { &m.sandbox_id },
            |m: &mut CreateSandboxRequest| { &mut m.sandbox_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "guest_hook_path",
            |m: &CreateSandboxRequest| { &m.guest_hook_path },
            |m: &mut CreateSandboxRequest| { &mut m.guest_hook_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "kernel_modules",
            |m: &CreateSandboxRequest| { &m.kernel_modules },
            |m: &mut CreateSandboxRequest| { &mut m.kernel_modules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateSandboxRequest>(
            "CreateSandboxRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateSandboxRequest {
    const NAME: &'static str = "CreateSandboxRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hostname = is.read_string()?;
                },
                18 => {
                    self.dns.push(is.read_string()?);
                },
                26 => {
                    self.storages.push(is.read_message()?);
                },
                32 => {
                    self.sandbox_pidns = is.read_bool()?;
                },
                42 => {
                    self.sandbox_id = is.read_string()?;
                },
                50 => {
                    self.guest_hook_path = is.read_string()?;
                },
                58 => {
                    self.kernel_modules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hostname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hostname);
        }
        for value in &self.dns {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.storages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.sandbox_pidns != false {
            my_size += 1 + 1;
        }
        if !self.sandbox_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.sandbox_id);
        }
        if !self.guest_hook_path.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.guest_hook_path);
        }
        for value in &self.kernel_modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hostname.is_empty() {
            os.write_string(1, &self.hostname)?;
        }
        for v in &self.dns {
            os.write_string(2, &v)?;
        };
        for v in &self.storages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if self.sandbox_pidns != false {
            os.write_bool(4, self.sandbox_pidns)?;
        }
        if !self.sandbox_id.is_empty() {
            os.write_string(5, &self.sandbox_id)?;
        }
        if !self.guest_hook_path.is_empty() {
            os.write_string(6, &self.guest_hook_path)?;
        }
        for v in &self.kernel_modules {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateSandboxRequest {
        CreateSandboxRequest::new()
    }

    fn clear(&mut self) {
        self.hostname.clear();
        self.dns.clear();
        self.storages.clear();
        self.sandbox_pidns = false;
        self.sandbox_id.clear();
        self.guest_hook_path.clear();
        self.kernel_modules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateSandboxRequest {
        static instance: CreateSandboxRequest = CreateSandboxRequest {
            hostname: ::std::string::String::new(),
            dns: ::std::vec::Vec::new(),
            storages: ::std::vec::Vec::new(),
            sandbox_pidns: false,
            sandbox_id: ::std::string::String::new(),
            guest_hook_path: ::std::string::String::new(),
            kernel_modules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateSandboxRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateSandboxRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateSandboxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSandboxRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.DestroySandboxRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct DestroySandboxRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.DestroySandboxRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DestroySandboxRequest {
    fn default() -> &'a DestroySandboxRequest {
        <DestroySandboxRequest as ::protobuf::Message>::default_instance()
    }
}

impl DestroySandboxRequest {
    pub fn new() -> DestroySandboxRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DestroySandboxRequest>(
            "DestroySandboxRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DestroySandboxRequest {
    const NAME: &'static str = "DestroySandboxRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DestroySandboxRequest {
        DestroySandboxRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DestroySandboxRequest {
        static instance: DestroySandboxRequest = DestroySandboxRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DestroySandboxRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DestroySandboxRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DestroySandboxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DestroySandboxRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.RemoveStaleVirtiofsShareMountsRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct RemoveStaleVirtiofsShareMountsRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.RemoveStaleVirtiofsShareMountsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveStaleVirtiofsShareMountsRequest {
    fn default() -> &'a RemoveStaleVirtiofsShareMountsRequest {
        <RemoveStaleVirtiofsShareMountsRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveStaleVirtiofsShareMountsRequest {
    pub fn new() -> RemoveStaleVirtiofsShareMountsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveStaleVirtiofsShareMountsRequest>(
            "RemoveStaleVirtiofsShareMountsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoveStaleVirtiofsShareMountsRequest {
    const NAME: &'static str = "RemoveStaleVirtiofsShareMountsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveStaleVirtiofsShareMountsRequest {
        RemoveStaleVirtiofsShareMountsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveStaleVirtiofsShareMountsRequest {
        static instance: RemoveStaleVirtiofsShareMountsRequest = RemoveStaleVirtiofsShareMountsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemoveStaleVirtiofsShareMountsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoveStaleVirtiofsShareMountsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoveStaleVirtiofsShareMountsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveStaleVirtiofsShareMountsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.Interfaces)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct Interfaces {
    // message fields
    // @@protoc_insertion_point(field:grpc.Interfaces.Interfaces)
    pub Interfaces: ::std::vec::Vec<super::types::Interface>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.Interfaces.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Interfaces {
    fn default() -> &'a Interfaces {
        <Interfaces as ::protobuf::Message>::default_instance()
    }
}

impl Interfaces {
    pub fn new() -> Interfaces {
        ::std::default::Default::default()
    }

    // repeated .types.Interface Interfaces = 1;

    pub fn Interfaces(&self) -> &[super::types::Interface] {
        &self.Interfaces
    }

    pub fn clear_Interfaces(&mut self) {
        self.Interfaces.clear();
    }

    // Param is passed by value, moved
    pub fn set_Interfaces(&mut self, v: ::std::vec::Vec<super::types::Interface>) {
        self.Interfaces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Interfaces(&mut self) -> &mut ::std::vec::Vec<super::types::Interface> {
        &mut self.Interfaces
    }

    // Take field
    pub fn take_Interfaces(&mut self) -> ::std::vec::Vec<super::types::Interface> {
        ::std::mem::replace(&mut self.Interfaces, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Interfaces",
            |m: &Interfaces| { &m.Interfaces },
            |m: &mut Interfaces| { &mut m.Interfaces },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Interfaces>(
            "Interfaces",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Interfaces {
    const NAME: &'static str = "Interfaces";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Interfaces.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.Interfaces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.Interfaces {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Interfaces {
        Interfaces::new()
    }

    fn clear(&mut self) {
        self.Interfaces.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Interfaces {
        static instance: Interfaces = Interfaces {
            Interfaces: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Interfaces {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Interfaces").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Interfaces {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Interfaces {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.Routes)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct Routes {
    // message fields
    // @@protoc_insertion_point(field:grpc.Routes.Routes)
    pub Routes: ::std::vec::Vec<super::types::Route>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.Routes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Routes {
    fn default() -> &'a Routes {
        <Routes as ::protobuf::Message>::default_instance()
    }
}

impl Routes {
    pub fn new() -> Routes {
        ::std::default::Default::default()
    }

    // repeated .types.Route Routes = 1;

    pub fn Routes(&self) -> &[super::types::Route] {
        &self.Routes
    }

    pub fn clear_Routes(&mut self) {
        self.Routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_Routes(&mut self, v: ::std::vec::Vec<super::types::Route>) {
        self.Routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Routes(&mut self) -> &mut ::std::vec::Vec<super::types::Route> {
        &mut self.Routes
    }

    // Take field
    pub fn take_Routes(&mut self) -> ::std::vec::Vec<super::types::Route> {
        ::std::mem::replace(&mut self.Routes, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Routes",
            |m: &Routes| { &m.Routes },
            |m: &mut Routes| { &mut m.Routes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Routes>(
            "Routes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Routes {
    const NAME: &'static str = "Routes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Routes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.Routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.Routes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Routes {
        Routes::new()
    }

    fn clear(&mut self) {
        self.Routes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Routes {
        static instance: Routes = Routes {
            Routes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Routes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Routes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Routes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Routes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.UpdateInterfaceRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct UpdateInterfaceRequest {
    // message fields
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.UpdateInterfaceRequest.interface)
    pub interface: ::protobuf::MessageField<super::types::Interface>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.UpdateInterfaceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateInterfaceRequest {
    fn default() -> &'a UpdateInterfaceRequest {
        <UpdateInterfaceRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateInterfaceRequest {
    pub fn new() -> UpdateInterfaceRequest {
        ::std::default::Default::default()
    }

    // .types.Interface interface = 1;

    pub fn interface(&self) -> &super::types::Interface {
        self.interface.as_ref().unwrap_or_else(|| <super::types::Interface as ::protobuf::Message>::default_instance())
    }

    pub fn clear_interface(&mut self) {
        self.interface.clear();
    }

    pub fn has_interface(&self) -> bool {
        self.interface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interface(&mut self, v: super::types::Interface) {
        self.interface = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interface(&mut self) -> &mut super::types::Interface {
        self.interface.mut_or_insert_default()
    }

    // Take field
    pub fn take_interface(&mut self) -> super::types::Interface {
        self.interface.take().unwrap_or_else(|| super::types::Interface::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::Interface>(
            "interface",
            |m: &UpdateInterfaceRequest| { &m.interface },
            |m: &mut UpdateInterfaceRequest| { &mut m.interface },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateInterfaceRequest>(
            "UpdateInterfaceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateInterfaceRequest {
    const NAME: &'static str = "UpdateInterfaceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.interface)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.interface.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.interface.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateInterfaceRequest {
        UpdateInterfaceRequest::new()
    }

    fn clear(&mut self) {
        self.interface.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateInterfaceRequest {
        static instance: UpdateInterfaceRequest = UpdateInterfaceRequest {
            interface: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateInterfaceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateInterfaceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateInterfaceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateInterfaceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.UpdateRoutesRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct UpdateRoutesRequest {
    // message fields
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.UpdateRoutesRequest.routes)
    pub routes: ::protobuf::MessageField<Routes>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.UpdateRoutesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateRoutesRequest {
    fn default() -> &'a UpdateRoutesRequest {
        <UpdateRoutesRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateRoutesRequest {
    pub fn new() -> UpdateRoutesRequest {
        ::std::default::Default::default()
    }

    // .grpc.Routes routes = 1;

    pub fn routes(&self) -> &Routes {
        self.routes.as_ref().unwrap_or_else(|| <Routes as ::protobuf::Message>::default_instance())
    }

    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    pub fn has_routes(&self) -> bool {
        self.routes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: Routes) {
        self.routes = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routes(&mut self) -> &mut Routes {
        self.routes.mut_or_insert_default()
    }

    // Take field
    pub fn take_routes(&mut self) -> Routes {
        self.routes.take().unwrap_or_else(|| Routes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Routes>(
            "routes",
            |m: &UpdateRoutesRequest| { &m.routes },
            |m: &mut UpdateRoutesRequest| { &mut m.routes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateRoutesRequest>(
            "UpdateRoutesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateRoutesRequest {
    const NAME: &'static str = "UpdateRoutesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.routes)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.routes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.routes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateRoutesRequest {
        UpdateRoutesRequest::new()
    }

    fn clear(&mut self) {
        self.routes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateRoutesRequest {
        static instance: UpdateRoutesRequest = UpdateRoutesRequest {
            routes: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateRoutesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateRoutesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateRoutesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateRoutesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.UpdateEphemeralMountsRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct UpdateEphemeralMountsRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.UpdateEphemeralMountsRequest.storages)
    pub storages: ::std::vec::Vec<Storage>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.UpdateEphemeralMountsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateEphemeralMountsRequest {
    fn default() -> &'a UpdateEphemeralMountsRequest {
        <UpdateEphemeralMountsRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateEphemeralMountsRequest {
    pub fn new() -> UpdateEphemeralMountsRequest {
        ::std::default::Default::default()
    }

    // repeated .grpc.Storage storages = 1;

    pub fn storages(&self) -> &[Storage] {
        &self.storages
    }

    pub fn clear_storages(&mut self) {
        self.storages.clear();
    }

    // Param is passed by value, moved
    pub fn set_storages(&mut self, v: ::std::vec::Vec<Storage>) {
        self.storages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storages(&mut self) -> &mut ::std::vec::Vec<Storage> {
        &mut self.storages
    }

    // Take field
    pub fn take_storages(&mut self) -> ::std::vec::Vec<Storage> {
        ::std::mem::replace(&mut self.storages, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "storages",
            |m: &UpdateEphemeralMountsRequest| { &m.storages },
            |m: &mut UpdateEphemeralMountsRequest| { &mut m.storages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateEphemeralMountsRequest>(
            "UpdateEphemeralMountsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateEphemeralMountsRequest {
    const NAME: &'static str = "UpdateEphemeralMountsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.storages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.storages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.storages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateEphemeralMountsRequest {
        UpdateEphemeralMountsRequest::new()
    }

    fn clear(&mut self) {
        self.storages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateEphemeralMountsRequest {
        static instance: UpdateEphemeralMountsRequest = UpdateEphemeralMountsRequest {
            storages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateEphemeralMountsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateEphemeralMountsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateEphemeralMountsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateEphemeralMountsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.ListInterfacesRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct ListInterfacesRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.ListInterfacesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListInterfacesRequest {
    fn default() -> &'a ListInterfacesRequest {
        <ListInterfacesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInterfacesRequest {
    pub fn new() -> ListInterfacesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListInterfacesRequest>(
            "ListInterfacesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListInterfacesRequest {
    const NAME: &'static str = "ListInterfacesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListInterfacesRequest {
        ListInterfacesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListInterfacesRequest {
        static instance: ListInterfacesRequest = ListInterfacesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListInterfacesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListInterfacesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListInterfacesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInterfacesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.ListRoutesRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct ListRoutesRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.ListRoutesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListRoutesRequest {
    fn default() -> &'a ListRoutesRequest {
        <ListRoutesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRoutesRequest {
    pub fn new() -> ListRoutesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListRoutesRequest>(
            "ListRoutesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListRoutesRequest {
    const NAME: &'static str = "ListRoutesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListRoutesRequest {
        ListRoutesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListRoutesRequest {
        static instance: ListRoutesRequest = ListRoutesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListRoutesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListRoutesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListRoutesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRoutesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.ARPNeighbors)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct ARPNeighbors {
    // message fields
    // @@protoc_insertion_point(field:grpc.ARPNeighbors.ARPNeighbors)
    pub ARPNeighbors: ::std::vec::Vec<super::types::ARPNeighbor>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.ARPNeighbors.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ARPNeighbors {
    fn default() -> &'a ARPNeighbors {
        <ARPNeighbors as ::protobuf::Message>::default_instance()
    }
}

impl ARPNeighbors {
    pub fn new() -> ARPNeighbors {
        ::std::default::Default::default()
    }

    // repeated .types.ARPNeighbor ARPNeighbors = 1;

    pub fn ARPNeighbors(&self) -> &[super::types::ARPNeighbor] {
        &self.ARPNeighbors
    }

    pub fn clear_ARPNeighbors(&mut self) {
        self.ARPNeighbors.clear();
    }

    // Param is passed by value, moved
    pub fn set_ARPNeighbors(&mut self, v: ::std::vec::Vec<super::types::ARPNeighbor>) {
        self.ARPNeighbors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ARPNeighbors(&mut self) -> &mut ::std::vec::Vec<super::types::ARPNeighbor> {
        &mut self.ARPNeighbors
    }

    // Take field
    pub fn take_ARPNeighbors(&mut self) -> ::std::vec::Vec<super::types::ARPNeighbor> {
        ::std::mem::replace(&mut self.ARPNeighbors, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ARPNeighbors",
            |m: &ARPNeighbors| { &m.ARPNeighbors },
            |m: &mut ARPNeighbors| { &mut m.ARPNeighbors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ARPNeighbors>(
            "ARPNeighbors",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ARPNeighbors {
    const NAME: &'static str = "ARPNeighbors";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ARPNeighbors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ARPNeighbors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ARPNeighbors {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ARPNeighbors {
        ARPNeighbors::new()
    }

    fn clear(&mut self) {
        self.ARPNeighbors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ARPNeighbors {
        static instance: ARPNeighbors = ARPNeighbors {
            ARPNeighbors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ARPNeighbors {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ARPNeighbors").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ARPNeighbors {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ARPNeighbors {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.AddARPNeighborsRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct AddARPNeighborsRequest {
    // message fields
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.AddARPNeighborsRequest.neighbors)
    pub neighbors: ::protobuf::MessageField<ARPNeighbors>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.AddARPNeighborsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddARPNeighborsRequest {
    fn default() -> &'a AddARPNeighborsRequest {
        <AddARPNeighborsRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddARPNeighborsRequest {
    pub fn new() -> AddARPNeighborsRequest {
        ::std::default::Default::default()
    }

    // .grpc.ARPNeighbors neighbors = 1;

    pub fn neighbors(&self) -> &ARPNeighbors {
        self.neighbors.as_ref().unwrap_or_else(|| <ARPNeighbors as ::protobuf::Message>::default_instance())
    }

    pub fn clear_neighbors(&mut self) {
        self.neighbors.clear();
    }

    pub fn has_neighbors(&self) -> bool {
        self.neighbors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_neighbors(&mut self, v: ARPNeighbors) {
        self.neighbors = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_neighbors(&mut self) -> &mut ARPNeighbors {
        self.neighbors.mut_or_insert_default()
    }

    // Take field
    pub fn take_neighbors(&mut self) -> ARPNeighbors {
        self.neighbors.take().unwrap_or_else(|| ARPNeighbors::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ARPNeighbors>(
            "neighbors",
            |m: &AddARPNeighborsRequest| { &m.neighbors },
            |m: &mut AddARPNeighborsRequest| { &mut m.neighbors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddARPNeighborsRequest>(
            "AddARPNeighborsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddARPNeighborsRequest {
    const NAME: &'static str = "AddARPNeighborsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.neighbors)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.neighbors.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.neighbors.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddARPNeighborsRequest {
        AddARPNeighborsRequest::new()
    }

    fn clear(&mut self) {
        self.neighbors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddARPNeighborsRequest {
        static instance: AddARPNeighborsRequest = AddARPNeighborsRequest {
            neighbors: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddARPNeighborsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddARPNeighborsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddARPNeighborsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddARPNeighborsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.GetIPTablesRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct GetIPTablesRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.GetIPTablesRequest.is_ipv6)
    pub is_ipv6: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.GetIPTablesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetIPTablesRequest {
    fn default() -> &'a GetIPTablesRequest {
        <GetIPTablesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetIPTablesRequest {
    pub fn new() -> GetIPTablesRequest {
        ::std::default::Default::default()
    }

    // bool is_ipv6 = 1;

    pub fn is_ipv6(&self) -> bool {
        self.is_ipv6
    }

    pub fn clear_is_ipv6(&mut self) {
        self.is_ipv6 = false;
    }

    // Param is passed by value, moved
    pub fn set_is_ipv6(&mut self, v: bool) {
        self.is_ipv6 = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_ipv6",
            |m: &GetIPTablesRequest| { &m.is_ipv6 },
            |m: &mut GetIPTablesRequest| { &mut m.is_ipv6 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetIPTablesRequest>(
            "GetIPTablesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetIPTablesRequest {
    const NAME: &'static str = "GetIPTablesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_ipv6 = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.is_ipv6 != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.is_ipv6 != false {
            os.write_bool(1, self.is_ipv6)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetIPTablesRequest {
        GetIPTablesRequest::new()
    }

    fn clear(&mut self) {
        self.is_ipv6 = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetIPTablesRequest {
        static instance: GetIPTablesRequest = GetIPTablesRequest {
            is_ipv6: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetIPTablesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetIPTablesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetIPTablesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIPTablesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.GetIPTablesResponse)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct GetIPTablesResponse {
    // message fields
    // @@protoc_insertion_point(field:grpc.GetIPTablesResponse.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.GetIPTablesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetIPTablesResponse {
    fn default() -> &'a GetIPTablesResponse {
        <GetIPTablesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetIPTablesResponse {
    pub fn new() -> GetIPTablesResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;

    pub fn data(&self) -> &[u8] {
        &self.data
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &GetIPTablesResponse| { &m.data },
            |m: &mut GetIPTablesResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetIPTablesResponse>(
            "GetIPTablesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetIPTablesResponse {
    const NAME: &'static str = "GetIPTablesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetIPTablesResponse {
        GetIPTablesResponse::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetIPTablesResponse {
        static instance: GetIPTablesResponse = GetIPTablesResponse {
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetIPTablesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetIPTablesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetIPTablesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIPTablesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.SetIPTablesRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct SetIPTablesRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.SetIPTablesRequest.is_ipv6)
    pub is_ipv6: bool,
    // @@protoc_insertion_point(field:grpc.SetIPTablesRequest.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.SetIPTablesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetIPTablesRequest {
    fn default() -> &'a SetIPTablesRequest {
        <SetIPTablesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetIPTablesRequest {
    pub fn new() -> SetIPTablesRequest {
        ::std::default::Default::default()
    }

    // bool is_ipv6 = 1;

    pub fn is_ipv6(&self) -> bool {
        self.is_ipv6
    }

    pub fn clear_is_ipv6(&mut self) {
        self.is_ipv6 = false;
    }

    // Param is passed by value, moved
    pub fn set_is_ipv6(&mut self, v: bool) {
        self.is_ipv6 = v;
    }

    // bytes data = 2;

    pub fn data(&self) -> &[u8] {
        &self.data
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_ipv6",
            |m: &SetIPTablesRequest| { &m.is_ipv6 },
            |m: &mut SetIPTablesRequest| { &mut m.is_ipv6 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &SetIPTablesRequest| { &m.data },
            |m: &mut SetIPTablesRequest| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetIPTablesRequest>(
            "SetIPTablesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetIPTablesRequest {
    const NAME: &'static str = "SetIPTablesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_ipv6 = is.read_bool()?;
                },
                18 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.is_ipv6 != false {
            my_size += 1 + 1;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.is_ipv6 != false {
            os.write_bool(1, self.is_ipv6)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetIPTablesRequest {
        SetIPTablesRequest::new()
    }

    fn clear(&mut self) {
        self.is_ipv6 = false;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetIPTablesRequest {
        static instance: SetIPTablesRequest = SetIPTablesRequest {
            is_ipv6: false,
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetIPTablesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetIPTablesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetIPTablesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetIPTablesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.SetIPTablesResponse)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct SetIPTablesResponse {
    // message fields
    // @@protoc_insertion_point(field:grpc.SetIPTablesResponse.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.SetIPTablesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetIPTablesResponse {
    fn default() -> &'a SetIPTablesResponse {
        <SetIPTablesResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetIPTablesResponse {
    pub fn new() -> SetIPTablesResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;

    pub fn data(&self) -> &[u8] {
        &self.data
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &SetIPTablesResponse| { &m.data },
            |m: &mut SetIPTablesResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetIPTablesResponse>(
            "SetIPTablesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetIPTablesResponse {
    const NAME: &'static str = "SetIPTablesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetIPTablesResponse {
        SetIPTablesResponse::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetIPTablesResponse {
        static instance: SetIPTablesResponse = SetIPTablesResponse {
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetIPTablesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetIPTablesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetIPTablesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetIPTablesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.OnlineCPUMemRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct OnlineCPUMemRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.OnlineCPUMemRequest.wait)
    pub wait: bool,
    // @@protoc_insertion_point(field:grpc.OnlineCPUMemRequest.nb_cpus)
    pub nb_cpus: u32,
    // @@protoc_insertion_point(field:grpc.OnlineCPUMemRequest.cpu_only)
    pub cpu_only: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.OnlineCPUMemRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OnlineCPUMemRequest {
    fn default() -> &'a OnlineCPUMemRequest {
        <OnlineCPUMemRequest as ::protobuf::Message>::default_instance()
    }
}

impl OnlineCPUMemRequest {
    pub fn new() -> OnlineCPUMemRequest {
        ::std::default::Default::default()
    }

    // bool wait = 1;

    pub fn wait(&self) -> bool {
        self.wait
    }

    pub fn clear_wait(&mut self) {
        self.wait = false;
    }

    // Param is passed by value, moved
    pub fn set_wait(&mut self, v: bool) {
        self.wait = v;
    }

    // uint32 nb_cpus = 2;

    pub fn nb_cpus(&self) -> u32 {
        self.nb_cpus
    }

    pub fn clear_nb_cpus(&mut self) {
        self.nb_cpus = 0;
    }

    // Param is passed by value, moved
    pub fn set_nb_cpus(&mut self, v: u32) {
        self.nb_cpus = v;
    }

    // bool cpu_only = 3;

    pub fn cpu_only(&self) -> bool {
        self.cpu_only
    }

    pub fn clear_cpu_only(&mut self) {
        self.cpu_only = false;
    }

    // Param is passed by value, moved
    pub fn set_cpu_only(&mut self, v: bool) {
        self.cpu_only = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wait",
            |m: &OnlineCPUMemRequest| { &m.wait },
            |m: &mut OnlineCPUMemRequest| { &mut m.wait },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nb_cpus",
            |m: &OnlineCPUMemRequest| { &m.nb_cpus },
            |m: &mut OnlineCPUMemRequest| { &mut m.nb_cpus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cpu_only",
            |m: &OnlineCPUMemRequest| { &m.cpu_only },
            |m: &mut OnlineCPUMemRequest| { &mut m.cpu_only },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OnlineCPUMemRequest>(
            "OnlineCPUMemRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OnlineCPUMemRequest {
    const NAME: &'static str = "OnlineCPUMemRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.wait = is.read_bool()?;
                },
                16 => {
                    self.nb_cpus = is.read_uint32()?;
                },
                24 => {
                    self.cpu_only = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.wait != false {
            my_size += 1 + 1;
        }
        if self.nb_cpus != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.nb_cpus);
        }
        if self.cpu_only != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.wait != false {
            os.write_bool(1, self.wait)?;
        }
        if self.nb_cpus != 0 {
            os.write_uint32(2, self.nb_cpus)?;
        }
        if self.cpu_only != false {
            os.write_bool(3, self.cpu_only)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OnlineCPUMemRequest {
        OnlineCPUMemRequest::new()
    }

    fn clear(&mut self) {
        self.wait = false;
        self.nb_cpus = 0;
        self.cpu_only = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OnlineCPUMemRequest {
        static instance: OnlineCPUMemRequest = OnlineCPUMemRequest {
            wait: false,
            nb_cpus: 0,
            cpu_only: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OnlineCPUMemRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OnlineCPUMemRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OnlineCPUMemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnlineCPUMemRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.ReseedRandomDevRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct ReseedRandomDevRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.ReseedRandomDevRequest.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.ReseedRandomDevRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReseedRandomDevRequest {
    fn default() -> &'a ReseedRandomDevRequest {
        <ReseedRandomDevRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReseedRandomDevRequest {
    pub fn new() -> ReseedRandomDevRequest {
        ::std::default::Default::default()
    }

    // bytes data = 2;

    pub fn data(&self) -> &[u8] {
        &self.data
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &ReseedRandomDevRequest| { &m.data },
            |m: &mut ReseedRandomDevRequest| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReseedRandomDevRequest>(
            "ReseedRandomDevRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReseedRandomDevRequest {
    const NAME: &'static str = "ReseedRandomDevRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReseedRandomDevRequest {
        ReseedRandomDevRequest::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReseedRandomDevRequest {
        static instance: ReseedRandomDevRequest = ReseedRandomDevRequest {
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReseedRandomDevRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReseedRandomDevRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReseedRandomDevRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReseedRandomDevRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.AgentDetails)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct AgentDetails {
    // message fields
    // @@protoc_insertion_point(field:grpc.AgentDetails.version)
    pub version: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.AgentDetails.init_daemon)
    pub init_daemon: bool,
    // @@protoc_insertion_point(field:grpc.AgentDetails.device_handlers)
    pub device_handlers: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.AgentDetails.storage_handlers)
    pub storage_handlers: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.AgentDetails.supports_seccomp)
    pub supports_seccomp: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.AgentDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AgentDetails {
    fn default() -> &'a AgentDetails {
        <AgentDetails as ::protobuf::Message>::default_instance()
    }
}

impl AgentDetails {
    pub fn new() -> AgentDetails {
        ::std::default::Default::default()
    }

    // string version = 1;

    pub fn version(&self) -> &str {
        &self.version
    }

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // bool init_daemon = 2;

    pub fn init_daemon(&self) -> bool {
        self.init_daemon
    }

    pub fn clear_init_daemon(&mut self) {
        self.init_daemon = false;
    }

    // Param is passed by value, moved
    pub fn set_init_daemon(&mut self, v: bool) {
        self.init_daemon = v;
    }

    // repeated string device_handlers = 3;

    pub fn device_handlers(&self) -> &[::std::string::String] {
        &self.device_handlers
    }

    pub fn clear_device_handlers(&mut self) {
        self.device_handlers.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_handlers(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.device_handlers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_handlers(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.device_handlers
    }

    // Take field
    pub fn take_device_handlers(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.device_handlers, ::std::vec::Vec::new())
    }

    // repeated string storage_handlers = 4;

    pub fn storage_handlers(&self) -> &[::std::string::String] {
        &self.storage_handlers
    }

    pub fn clear_storage_handlers(&mut self) {
        self.storage_handlers.clear();
    }

    // Param is passed by value, moved
    pub fn set_storage_handlers(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.storage_handlers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storage_handlers(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.storage_handlers
    }

    // Take field
    pub fn take_storage_handlers(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.storage_handlers, ::std::vec::Vec::new())
    }

    // bool supports_seccomp = 5;

    pub fn supports_seccomp(&self) -> bool {
        self.supports_seccomp
    }

    pub fn clear_supports_seccomp(&mut self) {
        self.supports_seccomp = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_seccomp(&mut self, v: bool) {
        self.supports_seccomp = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &AgentDetails| { &m.version },
            |m: &mut AgentDetails| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "init_daemon",
            |m: &AgentDetails| { &m.init_daemon },
            |m: &mut AgentDetails| { &mut m.init_daemon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "device_handlers",
            |m: &AgentDetails| { &m.device_handlers },
            |m: &mut AgentDetails| { &mut m.device_handlers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "storage_handlers",
            |m: &AgentDetails| { &m.storage_handlers },
            |m: &mut AgentDetails| { &mut m.storage_handlers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_seccomp",
            |m: &AgentDetails| { &m.supports_seccomp },
            |m: &mut AgentDetails| { &mut m.supports_seccomp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AgentDetails>(
            "AgentDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AgentDetails {
    const NAME: &'static str = "AgentDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version = is.read_string()?;
                },
                16 => {
                    self.init_daemon = is.read_bool()?;
                },
                26 => {
                    self.device_handlers.push(is.read_string()?);
                },
                34 => {
                    self.storage_handlers.push(is.read_string()?);
                },
                40 => {
                    self.supports_seccomp = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if self.init_daemon != false {
            my_size += 1 + 1;
        }
        for value in &self.device_handlers {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.storage_handlers {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.supports_seccomp != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if self.init_daemon != false {
            os.write_bool(2, self.init_daemon)?;
        }
        for v in &self.device_handlers {
            os.write_string(3, &v)?;
        };
        for v in &self.storage_handlers {
            os.write_string(4, &v)?;
        };
        if self.supports_seccomp != false {
            os.write_bool(5, self.supports_seccomp)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AgentDetails {
        AgentDetails::new()
    }

    fn clear(&mut self) {
        self.version.clear();
        self.init_daemon = false;
        self.device_handlers.clear();
        self.storage_handlers.clear();
        self.supports_seccomp = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AgentDetails {
        static instance: AgentDetails = AgentDetails {
            version: ::std::string::String::new(),
            init_daemon: false,
            device_handlers: ::std::vec::Vec::new(),
            storage_handlers: ::std::vec::Vec::new(),
            supports_seccomp: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AgentDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AgentDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AgentDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AgentDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.GuestDetailsRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct GuestDetailsRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.GuestDetailsRequest.mem_block_size)
    pub mem_block_size: bool,
    // @@protoc_insertion_point(field:grpc.GuestDetailsRequest.mem_hotplug_probe)
    pub mem_hotplug_probe: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.GuestDetailsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GuestDetailsRequest {
    fn default() -> &'a GuestDetailsRequest {
        <GuestDetailsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GuestDetailsRequest {
    pub fn new() -> GuestDetailsRequest {
        ::std::default::Default::default()
    }

    // bool mem_block_size = 1;

    pub fn mem_block_size(&self) -> bool {
        self.mem_block_size
    }

    pub fn clear_mem_block_size(&mut self) {
        self.mem_block_size = false;
    }

    // Param is passed by value, moved
    pub fn set_mem_block_size(&mut self, v: bool) {
        self.mem_block_size = v;
    }

    // bool mem_hotplug_probe = 2;

    pub fn mem_hotplug_probe(&self) -> bool {
        self.mem_hotplug_probe
    }

    pub fn clear_mem_hotplug_probe(&mut self) {
        self.mem_hotplug_probe = false;
    }

    // Param is passed by value, moved
    pub fn set_mem_hotplug_probe(&mut self, v: bool) {
        self.mem_hotplug_probe = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mem_block_size",
            |m: &GuestDetailsRequest| { &m.mem_block_size },
            |m: &mut GuestDetailsRequest| { &mut m.mem_block_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mem_hotplug_probe",
            |m: &GuestDetailsRequest| { &m.mem_hotplug_probe },
            |m: &mut GuestDetailsRequest| { &mut m.mem_hotplug_probe },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GuestDetailsRequest>(
            "GuestDetailsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GuestDetailsRequest {
    const NAME: &'static str = "GuestDetailsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mem_block_size = is.read_bool()?;
                },
                16 => {
                    self.mem_hotplug_probe = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.mem_block_size != false {
            my_size += 1 + 1;
        }
        if self.mem_hotplug_probe != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.mem_block_size != false {
            os.write_bool(1, self.mem_block_size)?;
        }
        if self.mem_hotplug_probe != false {
            os.write_bool(2, self.mem_hotplug_probe)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GuestDetailsRequest {
        GuestDetailsRequest::new()
    }

    fn clear(&mut self) {
        self.mem_block_size = false;
        self.mem_hotplug_probe = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GuestDetailsRequest {
        static instance: GuestDetailsRequest = GuestDetailsRequest {
            mem_block_size: false,
            mem_hotplug_probe: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GuestDetailsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GuestDetailsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GuestDetailsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GuestDetailsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.GuestDetailsResponse)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct GuestDetailsResponse {
    // message fields
    // @@protoc_insertion_point(field:grpc.GuestDetailsResponse.mem_block_size_bytes)
    pub mem_block_size_bytes: u64,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.GuestDetailsResponse.agent_details)
    pub agent_details: ::protobuf::MessageField<AgentDetails>,
    // @@protoc_insertion_point(field:grpc.GuestDetailsResponse.support_mem_hotplug_probe)
    pub support_mem_hotplug_probe: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.GuestDetailsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GuestDetailsResponse {
    fn default() -> &'a GuestDetailsResponse {
        <GuestDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GuestDetailsResponse {
    pub fn new() -> GuestDetailsResponse {
        ::std::default::Default::default()
    }

    // uint64 mem_block_size_bytes = 1;

    pub fn mem_block_size_bytes(&self) -> u64 {
        self.mem_block_size_bytes
    }

    pub fn clear_mem_block_size_bytes(&mut self) {
        self.mem_block_size_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_mem_block_size_bytes(&mut self, v: u64) {
        self.mem_block_size_bytes = v;
    }

    // .grpc.AgentDetails agent_details = 2;

    pub fn agent_details(&self) -> &AgentDetails {
        self.agent_details.as_ref().unwrap_or_else(|| <AgentDetails as ::protobuf::Message>::default_instance())
    }

    pub fn clear_agent_details(&mut self) {
        self.agent_details.clear();
    }

    pub fn has_agent_details(&self) -> bool {
        self.agent_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_details(&mut self, v: AgentDetails) {
        self.agent_details = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_details(&mut self) -> &mut AgentDetails {
        self.agent_details.mut_or_insert_default()
    }

    // Take field
    pub fn take_agent_details(&mut self) -> AgentDetails {
        self.agent_details.take().unwrap_or_else(|| AgentDetails::new())
    }

    // bool support_mem_hotplug_probe = 3;

    pub fn support_mem_hotplug_probe(&self) -> bool {
        self.support_mem_hotplug_probe
    }

    pub fn clear_support_mem_hotplug_probe(&mut self) {
        self.support_mem_hotplug_probe = false;
    }

    // Param is passed by value, moved
    pub fn set_support_mem_hotplug_probe(&mut self, v: bool) {
        self.support_mem_hotplug_probe = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mem_block_size_bytes",
            |m: &GuestDetailsResponse| { &m.mem_block_size_bytes },
            |m: &mut GuestDetailsResponse| { &mut m.mem_block_size_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AgentDetails>(
            "agent_details",
            |m: &GuestDetailsResponse| { &m.agent_details },
            |m: &mut GuestDetailsResponse| { &mut m.agent_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "support_mem_hotplug_probe",
            |m: &GuestDetailsResponse| { &m.support_mem_hotplug_probe },
            |m: &mut GuestDetailsResponse| { &mut m.support_mem_hotplug_probe },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GuestDetailsResponse>(
            "GuestDetailsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GuestDetailsResponse {
    const NAME: &'static str = "GuestDetailsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mem_block_size_bytes = is.read_uint64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.agent_details)?;
                },
                24 => {
                    self.support_mem_hotplug_probe = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.mem_block_size_bytes != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.mem_block_size_bytes);
        }
        if let Some(v) = self.agent_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.support_mem_hotplug_probe != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.mem_block_size_bytes != 0 {
            os.write_uint64(1, self.mem_block_size_bytes)?;
        }
        if let Some(v) = self.agent_details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.support_mem_hotplug_probe != false {
            os.write_bool(3, self.support_mem_hotplug_probe)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GuestDetailsResponse {
        GuestDetailsResponse::new()
    }

    fn clear(&mut self) {
        self.mem_block_size_bytes = 0;
        self.agent_details.clear();
        self.support_mem_hotplug_probe = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GuestDetailsResponse {
        static instance: GuestDetailsResponse = GuestDetailsResponse {
            mem_block_size_bytes: 0,
            agent_details: ::protobuf::MessageField::none(),
            support_mem_hotplug_probe: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GuestDetailsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GuestDetailsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GuestDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GuestDetailsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.MemHotplugByProbeRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct MemHotplugByProbeRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.MemHotplugByProbeRequest.memHotplugProbeAddr)
    pub memHotplugProbeAddr: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.MemHotplugByProbeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MemHotplugByProbeRequest {
    fn default() -> &'a MemHotplugByProbeRequest {
        <MemHotplugByProbeRequest as ::protobuf::Message>::default_instance()
    }
}

impl MemHotplugByProbeRequest {
    pub fn new() -> MemHotplugByProbeRequest {
        ::std::default::Default::default()
    }

    // repeated uint64 memHotplugProbeAddr = 1;

    pub fn memHotplugProbeAddr(&self) -> &[u64] {
        &self.memHotplugProbeAddr
    }

    pub fn clear_memHotplugProbeAddr(&mut self) {
        self.memHotplugProbeAddr.clear();
    }

    // Param is passed by value, moved
    pub fn set_memHotplugProbeAddr(&mut self, v: ::std::vec::Vec<u64>) {
        self.memHotplugProbeAddr = v;
    }

    // Mutable pointer to the field.
    pub fn mut_memHotplugProbeAddr(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.memHotplugProbeAddr
    }

    // Take field
    pub fn take_memHotplugProbeAddr(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.memHotplugProbeAddr, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "memHotplugProbeAddr",
            |m: &MemHotplugByProbeRequest| { &m.memHotplugProbeAddr },
            |m: &mut MemHotplugByProbeRequest| { &mut m.memHotplugProbeAddr },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MemHotplugByProbeRequest>(
            "MemHotplugByProbeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MemHotplugByProbeRequest {
    const NAME: &'static str = "MemHotplugByProbeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.memHotplugProbeAddr)?;
                },
                8 => {
                    self.memHotplugProbeAddr.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.memHotplugProbeAddr {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.memHotplugProbeAddr {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MemHotplugByProbeRequest {
        MemHotplugByProbeRequest::new()
    }

    fn clear(&mut self) {
        self.memHotplugProbeAddr.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MemHotplugByProbeRequest {
        static instance: MemHotplugByProbeRequest = MemHotplugByProbeRequest {
            memHotplugProbeAddr: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MemHotplugByProbeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MemHotplugByProbeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MemHotplugByProbeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemHotplugByProbeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.SetGuestDateTimeRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct SetGuestDateTimeRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.SetGuestDateTimeRequest.Sec)
    pub Sec: i64,
    // @@protoc_insertion_point(field:grpc.SetGuestDateTimeRequest.Usec)
    pub Usec: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.SetGuestDateTimeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetGuestDateTimeRequest {
    fn default() -> &'a SetGuestDateTimeRequest {
        <SetGuestDateTimeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetGuestDateTimeRequest {
    pub fn new() -> SetGuestDateTimeRequest {
        ::std::default::Default::default()
    }

    // int64 Sec = 1;

    pub fn Sec(&self) -> i64 {
        self.Sec
    }

    pub fn clear_Sec(&mut self) {
        self.Sec = 0;
    }

    // Param is passed by value, moved
    pub fn set_Sec(&mut self, v: i64) {
        self.Sec = v;
    }

    // int64 Usec = 2;

    pub fn Usec(&self) -> i64 {
        self.Usec
    }

    pub fn clear_Usec(&mut self) {
        self.Usec = 0;
    }

    // Param is passed by value, moved
    pub fn set_Usec(&mut self, v: i64) {
        self.Usec = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Sec",
            |m: &SetGuestDateTimeRequest| { &m.Sec },
            |m: &mut SetGuestDateTimeRequest| { &mut m.Sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Usec",
            |m: &SetGuestDateTimeRequest| { &m.Usec },
            |m: &mut SetGuestDateTimeRequest| { &mut m.Usec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetGuestDateTimeRequest>(
            "SetGuestDateTimeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetGuestDateTimeRequest {
    const NAME: &'static str = "SetGuestDateTimeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Sec = is.read_int64()?;
                },
                16 => {
                    self.Usec = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.Sec != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.Sec);
        }
        if self.Usec != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.Usec);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.Sec != 0 {
            os.write_int64(1, self.Sec)?;
        }
        if self.Usec != 0 {
            os.write_int64(2, self.Usec)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetGuestDateTimeRequest {
        SetGuestDateTimeRequest::new()
    }

    fn clear(&mut self) {
        self.Sec = 0;
        self.Usec = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetGuestDateTimeRequest {
        static instance: SetGuestDateTimeRequest = SetGuestDateTimeRequest {
            Sec: 0,
            Usec: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetGuestDateTimeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetGuestDateTimeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetGuestDateTimeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetGuestDateTimeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.FSGroup)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct FSGroup {
    // message fields
    // @@protoc_insertion_point(field:grpc.FSGroup.group_id)
    pub group_id: u32,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_enum_or_unknown", deserialize_with = "crate::deserialize_enum_or_unknown"))]
    // @@protoc_insertion_point(field:grpc.FSGroup.group_change_policy)
    pub group_change_policy: ::protobuf::EnumOrUnknown<super::types::FSGroupChangePolicy>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.FSGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FSGroup {
    fn default() -> &'a FSGroup {
        <FSGroup as ::protobuf::Message>::default_instance()
    }
}

impl FSGroup {
    pub fn new() -> FSGroup {
        ::std::default::Default::default()
    }

    // uint32 group_id = 2;

    pub fn group_id(&self) -> u32 {
        self.group_id
    }

    pub fn clear_group_id(&mut self) {
        self.group_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u32) {
        self.group_id = v;
    }

    // .types.FSGroupChangePolicy group_change_policy = 3;

    pub fn group_change_policy(&self) -> super::types::FSGroupChangePolicy {
        self.group_change_policy.enum_value_or_default()
    }

    pub fn clear_group_change_policy(&mut self) {
        self.group_change_policy = ::protobuf::EnumOrUnknown::new(super::types::FSGroupChangePolicy::Always);
    }

    // Param is passed by value, moved
    pub fn set_group_change_policy(&mut self, v: super::types::FSGroupChangePolicy) {
        self.group_change_policy = ::protobuf::EnumOrUnknown::new(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_id",
            |m: &FSGroup| { &m.group_id },
            |m: &mut FSGroup| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_change_policy",
            |m: &FSGroup| { &m.group_change_policy },
            |m: &mut FSGroup| { &mut m.group_change_policy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FSGroup>(
            "FSGroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FSGroup {
    const NAME: &'static str = "FSGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.group_id = is.read_uint32()?;
                },
                24 => {
                    self.group_change_policy = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.group_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.group_id);
        }
        if self.group_change_policy != ::protobuf::EnumOrUnknown::new(super::types::FSGroupChangePolicy::Always) {
            my_size += ::protobuf::rt::int32_size(3, self.group_change_policy.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.group_id != 0 {
            os.write_uint32(2, self.group_id)?;
        }
        if self.group_change_policy != ::protobuf::EnumOrUnknown::new(super::types::FSGroupChangePolicy::Always) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.group_change_policy))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FSGroup {
        FSGroup::new()
    }

    fn clear(&mut self) {
        self.group_id = 0;
        self.group_change_policy = ::protobuf::EnumOrUnknown::new(super::types::FSGroupChangePolicy::Always);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FSGroup {
        static instance: FSGroup = FSGroup {
            group_id: 0,
            group_change_policy: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FSGroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FSGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FSGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FSGroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.Storage)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct Storage {
    // message fields
    // @@protoc_insertion_point(field:grpc.Storage.driver)
    pub driver: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Storage.driver_options)
    pub driver_options: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.Storage.source)
    pub source: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Storage.fstype)
    pub fstype: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Storage.options)
    pub options: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.Storage.mount_point)
    pub mount_point: ::std::string::String,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.Storage.fs_group)
    pub fs_group: ::protobuf::MessageField<FSGroup>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.Storage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Storage {
    fn default() -> &'a Storage {
        <Storage as ::protobuf::Message>::default_instance()
    }
}

impl Storage {
    pub fn new() -> Storage {
        ::std::default::Default::default()
    }

    // string driver = 1;

    pub fn driver(&self) -> &str {
        &self.driver
    }

    pub fn clear_driver(&mut self) {
        self.driver.clear();
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        &mut self.driver
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.driver, ::std::string::String::new())
    }

    // repeated string driver_options = 2;

    pub fn driver_options(&self) -> &[::std::string::String] {
        &self.driver_options
    }

    pub fn clear_driver_options(&mut self) {
        self.driver_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_driver_options(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.driver_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_driver_options(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.driver_options
    }

    // Take field
    pub fn take_driver_options(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.driver_options, ::std::vec::Vec::new())
    }

    // string source = 3;

    pub fn source(&self) -> &str {
        &self.source
    }

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        &mut self.source
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source, ::std::string::String::new())
    }

    // string fstype = 4;

    pub fn fstype(&self) -> &str {
        &self.fstype
    }

    pub fn clear_fstype(&mut self) {
        self.fstype.clear();
    }

    // Param is passed by value, moved
    pub fn set_fstype(&mut self, v: ::std::string::String) {
        self.fstype = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fstype(&mut self) -> &mut ::std::string::String {
        &mut self.fstype
    }

    // Take field
    pub fn take_fstype(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fstype, ::std::string::String::new())
    }

    // repeated string options = 5;

    pub fn options(&self) -> &[::std::string::String] {
        &self.options
    }

    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.options, ::std::vec::Vec::new())
    }

    // string mount_point = 6;

    pub fn mount_point(&self) -> &str {
        &self.mount_point
    }

    pub fn clear_mount_point(&mut self) {
        self.mount_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_mount_point(&mut self, v: ::std::string::String) {
        self.mount_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mount_point(&mut self) -> &mut ::std::string::String {
        &mut self.mount_point
    }

    // Take field
    pub fn take_mount_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mount_point, ::std::string::String::new())
    }

    // .grpc.FSGroup fs_group = 7;

    pub fn fs_group(&self) -> &FSGroup {
        self.fs_group.as_ref().unwrap_or_else(|| <FSGroup as ::protobuf::Message>::default_instance())
    }

    pub fn clear_fs_group(&mut self) {
        self.fs_group.clear();
    }

    pub fn has_fs_group(&self) -> bool {
        self.fs_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs_group(&mut self, v: FSGroup) {
        self.fs_group = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs_group(&mut self) -> &mut FSGroup {
        self.fs_group.mut_or_insert_default()
    }

    // Take field
    pub fn take_fs_group(&mut self) -> FSGroup {
        self.fs_group.take().unwrap_or_else(|| FSGroup::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "driver",
            |m: &Storage| { &m.driver },
            |m: &mut Storage| { &mut m.driver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "driver_options",
            |m: &Storage| { &m.driver_options },
            |m: &mut Storage| { &mut m.driver_options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source",
            |m: &Storage| { &m.source },
            |m: &mut Storage| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fstype",
            |m: &Storage| { &m.fstype },
            |m: &mut Storage| { &mut m.fstype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "options",
            |m: &Storage| { &m.options },
            |m: &mut Storage| { &mut m.options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mount_point",
            |m: &Storage| { &m.mount_point },
            |m: &mut Storage| { &mut m.mount_point },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FSGroup>(
            "fs_group",
            |m: &Storage| { &m.fs_group },
            |m: &mut Storage| { &mut m.fs_group },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Storage>(
            "Storage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Storage {
    const NAME: &'static str = "Storage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driver = is.read_string()?;
                },
                18 => {
                    self.driver_options.push(is.read_string()?);
                },
                26 => {
                    self.source = is.read_string()?;
                },
                34 => {
                    self.fstype = is.read_string()?;
                },
                42 => {
                    self.options.push(is.read_string()?);
                },
                50 => {
                    self.mount_point = is.read_string()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fs_group)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.driver.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.driver);
        }
        for value in &self.driver_options {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source);
        }
        if !self.fstype.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.fstype);
        }
        for value in &self.options {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if !self.mount_point.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.mount_point);
        }
        if let Some(v) = self.fs_group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.driver.is_empty() {
            os.write_string(1, &self.driver)?;
        }
        for v in &self.driver_options {
            os.write_string(2, &v)?;
        };
        if !self.source.is_empty() {
            os.write_string(3, &self.source)?;
        }
        if !self.fstype.is_empty() {
            os.write_string(4, &self.fstype)?;
        }
        for v in &self.options {
            os.write_string(5, &v)?;
        };
        if !self.mount_point.is_empty() {
            os.write_string(6, &self.mount_point)?;
        }
        if let Some(v) = self.fs_group.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Storage {
        Storage::new()
    }

    fn clear(&mut self) {
        self.driver.clear();
        self.driver_options.clear();
        self.source.clear();
        self.fstype.clear();
        self.options.clear();
        self.mount_point.clear();
        self.fs_group.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Storage {
        static instance: Storage = Storage {
            driver: ::std::string::String::new(),
            driver_options: ::std::vec::Vec::new(),
            source: ::std::string::String::new(),
            fstype: ::std::string::String::new(),
            options: ::std::vec::Vec::new(),
            mount_point: ::std::string::String::new(),
            fs_group: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Storage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Storage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Storage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Storage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.Device)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct Device {
    // message fields
    // @@protoc_insertion_point(field:grpc.Device.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Device.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Device.vm_path)
    pub vm_path: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Device.container_path)
    pub container_path: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Device.options)
    pub options: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.Device.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Device {
    fn default() -> &'a Device {
        <Device as ::protobuf::Message>::default_instance()
    }
}

impl Device {
    pub fn new() -> Device {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string type = 2;

    pub fn type_(&self) -> &str {
        &self.type_
    }

    pub fn clear_type_(&mut self) {
        self.type_.clear();
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        &mut self.type_
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.type_, ::std::string::String::new())
    }

    // string vm_path = 3;

    pub fn vm_path(&self) -> &str {
        &self.vm_path
    }

    pub fn clear_vm_path(&mut self) {
        self.vm_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_vm_path(&mut self, v: ::std::string::String) {
        self.vm_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vm_path(&mut self) -> &mut ::std::string::String {
        &mut self.vm_path
    }

    // Take field
    pub fn take_vm_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.vm_path, ::std::string::String::new())
    }

    // string container_path = 4;

    pub fn container_path(&self) -> &str {
        &self.container_path
    }

    pub fn clear_container_path(&mut self) {
        self.container_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_path(&mut self, v: ::std::string::String) {
        self.container_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_path(&mut self) -> &mut ::std::string::String {
        &mut self.container_path
    }

    // Take field
    pub fn take_container_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_path, ::std::string::String::new())
    }

    // repeated string options = 5;

    pub fn options(&self) -> &[::std::string::String] {
        &self.options
    }

    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.options, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Device| { &m.id },
            |m: &mut Device| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Device| { &m.type_ },
            |m: &mut Device| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vm_path",
            |m: &Device| { &m.vm_path },
            |m: &mut Device| { &mut m.vm_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_path",
            |m: &Device| { &m.container_path },
            |m: &mut Device| { &mut m.container_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "options",
            |m: &Device| { &m.options },
            |m: &mut Device| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Device>(
            "Device",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Device {
    const NAME: &'static str = "Device";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.type_ = is.read_string()?;
                },
                26 => {
                    self.vm_path = is.read_string()?;
                },
                34 => {
                    self.container_path = is.read_string()?;
                },
                42 => {
                    self.options.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.type_);
        }
        if !self.vm_path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.vm_path);
        }
        if !self.container_path.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.container_path);
        }
        for value in &self.options {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.type_.is_empty() {
            os.write_string(2, &self.type_)?;
        }
        if !self.vm_path.is_empty() {
            os.write_string(3, &self.vm_path)?;
        }
        if !self.container_path.is_empty() {
            os.write_string(4, &self.container_path)?;
        }
        for v in &self.options {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Device {
        Device::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.type_.clear();
        self.vm_path.clear();
        self.container_path.clear();
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Device {
        static instance: Device = Device {
            id: ::std::string::String::new(),
            type_: ::std::string::String::new(),
            vm_path: ::std::string::String::new(),
            container_path: ::std::string::String::new(),
            options: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Device {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Device").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.StringUser)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct StringUser {
    // message fields
    // @@protoc_insertion_point(field:grpc.StringUser.uid)
    pub uid: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.StringUser.gid)
    pub gid: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.StringUser.additionalGids)
    pub additionalGids: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.StringUser.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StringUser {
    fn default() -> &'a StringUser {
        <StringUser as ::protobuf::Message>::default_instance()
    }
}

impl StringUser {
    pub fn new() -> StringUser {
        ::std::default::Default::default()
    }

    // string uid = 1;

    pub fn uid(&self) -> &str {
        &self.uid
    }

    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // string gid = 2;

    pub fn gid(&self) -> &str {
        &self.gid
    }

    pub fn clear_gid(&mut self) {
        self.gid.clear();
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::string::String) {
        self.gid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::string::String {
        &mut self.gid
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gid, ::std::string::String::new())
    }

    // repeated string additionalGids = 3;

    pub fn additionalGids(&self) -> &[::std::string::String] {
        &self.additionalGids
    }

    pub fn clear_additionalGids(&mut self) {
        self.additionalGids.clear();
    }

    // Param is passed by value, moved
    pub fn set_additionalGids(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.additionalGids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additionalGids(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.additionalGids
    }

    // Take field
    pub fn take_additionalGids(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.additionalGids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uid",
            |m: &StringUser| { &m.uid },
            |m: &mut StringUser| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gid",
            |m: &StringUser| { &m.gid },
            |m: &mut StringUser| { &mut m.gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additionalGids",
            |m: &StringUser| { &m.additionalGids },
            |m: &mut StringUser| { &mut m.additionalGids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StringUser>(
            "StringUser",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StringUser {
    const NAME: &'static str = "StringUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uid = is.read_string()?;
                },
                18 => {
                    self.gid = is.read_string()?;
                },
                26 => {
                    self.additionalGids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if !self.gid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.gid);
        }
        for value in &self.additionalGids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if !self.gid.is_empty() {
            os.write_string(2, &self.gid)?;
        }
        for v in &self.additionalGids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StringUser {
        StringUser::new()
    }

    fn clear(&mut self) {
        self.uid.clear();
        self.gid.clear();
        self.additionalGids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StringUser {
        static instance: StringUser = StringUser {
            uid: ::std::string::String::new(),
            gid: ::std::string::String::new(),
            additionalGids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StringUser {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StringUser").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StringUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringUser {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.CopyFileRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct CopyFileRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.CopyFileRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.CopyFileRequest.file_size)
    pub file_size: i64,
    // @@protoc_insertion_point(field:grpc.CopyFileRequest.file_mode)
    pub file_mode: u32,
    // @@protoc_insertion_point(field:grpc.CopyFileRequest.dir_mode)
    pub dir_mode: u32,
    // @@protoc_insertion_point(field:grpc.CopyFileRequest.uid)
    pub uid: i32,
    // @@protoc_insertion_point(field:grpc.CopyFileRequest.gid)
    pub gid: i32,
    // @@protoc_insertion_point(field:grpc.CopyFileRequest.offset)
    pub offset: i64,
    // @@protoc_insertion_point(field:grpc.CopyFileRequest.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.CopyFileRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CopyFileRequest {
    fn default() -> &'a CopyFileRequest {
        <CopyFileRequest as ::protobuf::Message>::default_instance()
    }
}

impl CopyFileRequest {
    pub fn new() -> CopyFileRequest {
        ::std::default::Default::default()
    }

    // string path = 1;

    pub fn path(&self) -> &str {
        &self.path
    }

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // int64 file_size = 2;

    pub fn file_size(&self) -> i64 {
        self.file_size
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: i64) {
        self.file_size = v;
    }

    // uint32 file_mode = 3;

    pub fn file_mode(&self) -> u32 {
        self.file_mode
    }

    pub fn clear_file_mode(&mut self) {
        self.file_mode = 0;
    }

    // Param is passed by value, moved
    pub fn set_file_mode(&mut self, v: u32) {
        self.file_mode = v;
    }

    // uint32 dir_mode = 4;

    pub fn dir_mode(&self) -> u32 {
        self.dir_mode
    }

    pub fn clear_dir_mode(&mut self) {
        self.dir_mode = 0;
    }

    // Param is passed by value, moved
    pub fn set_dir_mode(&mut self, v: u32) {
        self.dir_mode = v;
    }

    // int32 uid = 5;

    pub fn uid(&self) -> i32 {
        self.uid
    }

    pub fn clear_uid(&mut self) {
        self.uid = 0;
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: i32) {
        self.uid = v;
    }

    // int32 gid = 6;

    pub fn gid(&self) -> i32 {
        self.gid
    }

    pub fn clear_gid(&mut self) {
        self.gid = 0;
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: i32) {
        self.gid = v;
    }

    // int64 offset = 7;

    pub fn offset(&self) -> i64 {
        self.offset
    }

    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // bytes data = 8;

    pub fn data(&self) -> &[u8] {
        &self.data
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &CopyFileRequest| { &m.path },
            |m: &mut CopyFileRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_size",
            |m: &CopyFileRequest| { &m.file_size },
            |m: &mut CopyFileRequest| { &mut m.file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_mode",
            |m: &CopyFileRequest| { &m.file_mode },
            |m: &mut CopyFileRequest| { &mut m.file_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dir_mode",
            |m: &CopyFileRequest| { &m.dir_mode },
            |m: &mut CopyFileRequest| { &mut m.dir_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uid",
            |m: &CopyFileRequest| { &m.uid },
            |m: &mut CopyFileRequest| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gid",
            |m: &CopyFileRequest| { &m.gid },
            |m: &mut CopyFileRequest| { &mut m.gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "offset",
            |m: &CopyFileRequest| { &m.offset },
            |m: &mut CopyFileRequest| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &CopyFileRequest| { &m.data },
            |m: &mut CopyFileRequest| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CopyFileRequest>(
            "CopyFileRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CopyFileRequest {
    const NAME: &'static str = "CopyFileRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                16 => {
                    self.file_size = is.read_int64()?;
                },
                24 => {
                    self.file_mode = is.read_uint32()?;
                },
                32 => {
                    self.dir_mode = is.read_uint32()?;
                },
                40 => {
                    self.uid = is.read_int32()?;
                },
                48 => {
                    self.gid = is.read_int32()?;
                },
                56 => {
                    self.offset = is.read_int64()?;
                },
                66 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if self.file_size != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.file_size);
        }
        if self.file_mode != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.file_mode);
        }
        if self.dir_mode != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.dir_mode);
        }
        if self.uid != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.uid);
        }
        if self.gid != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.gid);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.offset);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if self.file_size != 0 {
            os.write_int64(2, self.file_size)?;
        }
        if self.file_mode != 0 {
            os.write_uint32(3, self.file_mode)?;
        }
        if self.dir_mode != 0 {
            os.write_uint32(4, self.dir_mode)?;
        }
        if self.uid != 0 {
            os.write_int32(5, self.uid)?;
        }
        if self.gid != 0 {
            os.write_int32(6, self.gid)?;
        }
        if self.offset != 0 {
            os.write_int64(7, self.offset)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(8, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CopyFileRequest {
        CopyFileRequest::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.file_size = 0;
        self.file_mode = 0;
        self.dir_mode = 0;
        self.uid = 0;
        self.gid = 0;
        self.offset = 0;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CopyFileRequest {
        static instance: CopyFileRequest = CopyFileRequest {
            path: ::std::string::String::new(),
            file_size: 0,
            file_mode: 0,
            dir_mode: 0,
            uid: 0,
            gid: 0,
            offset: 0,
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CopyFileRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CopyFileRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CopyFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyFileRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.GetOOMEventRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct GetOOMEventRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.GetOOMEventRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetOOMEventRequest {
    fn default() -> &'a GetOOMEventRequest {
        <GetOOMEventRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetOOMEventRequest {
    pub fn new() -> GetOOMEventRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetOOMEventRequest>(
            "GetOOMEventRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetOOMEventRequest {
    const NAME: &'static str = "GetOOMEventRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetOOMEventRequest {
        GetOOMEventRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetOOMEventRequest {
        static instance: GetOOMEventRequest = GetOOMEventRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetOOMEventRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetOOMEventRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetOOMEventRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOOMEventRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.OOMEvent)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct OOMEvent {
    // message fields
    // @@protoc_insertion_point(field:grpc.OOMEvent.container_id)
    pub container_id: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.OOMEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OOMEvent {
    fn default() -> &'a OOMEvent {
        <OOMEvent as ::protobuf::Message>::default_instance()
    }
}

impl OOMEvent {
    pub fn new() -> OOMEvent {
        ::std::default::Default::default()
    }

    // string container_id = 1;

    pub fn container_id(&self) -> &str {
        &self.container_id
    }

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_id",
            |m: &OOMEvent| { &m.container_id },
            |m: &mut OOMEvent| { &mut m.container_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OOMEvent>(
            "OOMEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OOMEvent {
    const NAME: &'static str = "OOMEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OOMEvent {
        OOMEvent::new()
    }

    fn clear(&mut self) {
        self.container_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OOMEvent {
        static instance: OOMEvent = OOMEvent {
            container_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OOMEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OOMEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OOMEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OOMEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.AddSwapRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct AddSwapRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.AddSwapRequest.PCIPath)
    pub PCIPath: ::std::vec::Vec<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.AddSwapRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddSwapRequest {
    fn default() -> &'a AddSwapRequest {
        <AddSwapRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddSwapRequest {
    pub fn new() -> AddSwapRequest {
        ::std::default::Default::default()
    }

    // repeated uint32 PCIPath = 1;

    pub fn PCIPath(&self) -> &[u32] {
        &self.PCIPath
    }

    pub fn clear_PCIPath(&mut self) {
        self.PCIPath.clear();
    }

    // Param is passed by value, moved
    pub fn set_PCIPath(&mut self, v: ::std::vec::Vec<u32>) {
        self.PCIPath = v;
    }

    // Mutable pointer to the field.
    pub fn mut_PCIPath(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.PCIPath
    }

    // Take field
    pub fn take_PCIPath(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.PCIPath, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "PCIPath",
            |m: &AddSwapRequest| { &m.PCIPath },
            |m: &mut AddSwapRequest| { &mut m.PCIPath },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddSwapRequest>(
            "AddSwapRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddSwapRequest {
    const NAME: &'static str = "AddSwapRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.PCIPath)?;
                },
                8 => {
                    self.PCIPath.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.PCIPath {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.PCIPath {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddSwapRequest {
        AddSwapRequest::new()
    }

    fn clear(&mut self) {
        self.PCIPath.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddSwapRequest {
        static instance: AddSwapRequest = AddSwapRequest {
            PCIPath: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddSwapRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddSwapRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddSwapRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddSwapRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.GetMetricsRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct GetMetricsRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.GetMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetMetricsRequest {
    fn default() -> &'a GetMetricsRequest {
        <GetMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetMetricsRequest {
    pub fn new() -> GetMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetMetricsRequest>(
            "GetMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetMetricsRequest {
    const NAME: &'static str = "GetMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetMetricsRequest {
        GetMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetMetricsRequest {
        static instance: GetMetricsRequest = GetMetricsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.Metrics)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct Metrics {
    // message fields
    // @@protoc_insertion_point(field:grpc.Metrics.metrics)
    pub metrics: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.Metrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Metrics {
    fn default() -> &'a Metrics {
        <Metrics as ::protobuf::Message>::default_instance()
    }
}

impl Metrics {
    pub fn new() -> Metrics {
        ::std::default::Default::default()
    }

    // string metrics = 1;

    pub fn metrics(&self) -> &str {
        &self.metrics
    }

    pub fn clear_metrics(&mut self) {
        self.metrics.clear();
    }

    // Param is passed by value, moved
    pub fn set_metrics(&mut self, v: ::std::string::String) {
        self.metrics = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metrics(&mut self) -> &mut ::std::string::String {
        &mut self.metrics
    }

    // Take field
    pub fn take_metrics(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.metrics, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metrics",
            |m: &Metrics| { &m.metrics },
            |m: &mut Metrics| { &mut m.metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Metrics>(
            "Metrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Metrics {
    const NAME: &'static str = "Metrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.metrics = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.metrics.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.metrics);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.metrics.is_empty() {
            os.write_string(1, &self.metrics)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Metrics {
        Metrics::new()
    }

    fn clear(&mut self) {
        self.metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Metrics {
        static instance: Metrics = Metrics {
            metrics: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Metrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Metrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Metrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.VolumeStatsRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct VolumeStatsRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.VolumeStatsRequest.volume_guest_path)
    pub volume_guest_path: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.VolumeStatsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VolumeStatsRequest {
    fn default() -> &'a VolumeStatsRequest {
        <VolumeStatsRequest as ::protobuf::Message>::default_instance()
    }
}

impl VolumeStatsRequest {
    pub fn new() -> VolumeStatsRequest {
        ::std::default::Default::default()
    }

    // string volume_guest_path = 1;

    pub fn volume_guest_path(&self) -> &str {
        &self.volume_guest_path
    }

    pub fn clear_volume_guest_path(&mut self) {
        self.volume_guest_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_volume_guest_path(&mut self, v: ::std::string::String) {
        self.volume_guest_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume_guest_path(&mut self) -> &mut ::std::string::String {
        &mut self.volume_guest_path
    }

    // Take field
    pub fn take_volume_guest_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.volume_guest_path, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "volume_guest_path",
            |m: &VolumeStatsRequest| { &m.volume_guest_path },
            |m: &mut VolumeStatsRequest| { &mut m.volume_guest_path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VolumeStatsRequest>(
            "VolumeStatsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VolumeStatsRequest {
    const NAME: &'static str = "VolumeStatsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.volume_guest_path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.volume_guest_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.volume_guest_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.volume_guest_path.is_empty() {
            os.write_string(1, &self.volume_guest_path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VolumeStatsRequest {
        VolumeStatsRequest::new()
    }

    fn clear(&mut self) {
        self.volume_guest_path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VolumeStatsRequest {
        static instance: VolumeStatsRequest = VolumeStatsRequest {
            volume_guest_path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VolumeStatsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VolumeStatsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VolumeStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeStatsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.ResizeVolumeRequest)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct ResizeVolumeRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.ResizeVolumeRequest.volume_guest_path)
    pub volume_guest_path: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.ResizeVolumeRequest.size)
    pub size: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.ResizeVolumeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResizeVolumeRequest {
    fn default() -> &'a ResizeVolumeRequest {
        <ResizeVolumeRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResizeVolumeRequest {
    pub fn new() -> ResizeVolumeRequest {
        ::std::default::Default::default()
    }

    // string volume_guest_path = 1;

    pub fn volume_guest_path(&self) -> &str {
        &self.volume_guest_path
    }

    pub fn clear_volume_guest_path(&mut self) {
        self.volume_guest_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_volume_guest_path(&mut self, v: ::std::string::String) {
        self.volume_guest_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume_guest_path(&mut self) -> &mut ::std::string::String {
        &mut self.volume_guest_path
    }

    // Take field
    pub fn take_volume_guest_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.volume_guest_path, ::std::string::String::new())
    }

    // uint64 size = 2;

    pub fn size(&self) -> u64 {
        self.size
    }

    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "volume_guest_path",
            |m: &ResizeVolumeRequest| { &m.volume_guest_path },
            |m: &mut ResizeVolumeRequest| { &mut m.volume_guest_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "size",
            |m: &ResizeVolumeRequest| { &m.size },
            |m: &mut ResizeVolumeRequest| { &mut m.size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResizeVolumeRequest>(
            "ResizeVolumeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResizeVolumeRequest {
    const NAME: &'static str = "ResizeVolumeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.volume_guest_path = is.read_string()?;
                },
                16 => {
                    self.size = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.volume_guest_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.volume_guest_path);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.volume_guest_path.is_empty() {
            os.write_string(1, &self.volume_guest_path)?;
        }
        if self.size != 0 {
            os.write_uint64(2, self.size)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResizeVolumeRequest {
        ResizeVolumeRequest::new()
    }

    fn clear(&mut self) {
        self.volume_guest_path.clear();
        self.size = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResizeVolumeRequest {
        static instance: ResizeVolumeRequest = ResizeVolumeRequest {
            volume_guest_path: ::std::string::String::new(),
            size: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResizeVolumeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResizeVolumeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResizeVolumeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResizeVolumeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bagent.proto\x12\x04grpc\x1a\toci.proto\x1a\tcsi.proto\x1a\x0btypes\
    .proto\x1a\x1bgoogle/protobuf/empty.proto\"\x9d\x02\n\x16CreateContainer\
    Request\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcontainerId\x12\
    \x17\n\x07exec_id\x18\x02\x20\x01(\tR\x06execId\x121\n\x0bstring_user\
    \x18\x03\x20\x01(\x0b2\x10.grpc.StringUserR\nstringUser\x12&\n\x07device\
    s\x18\x04\x20\x03(\x0b2\x0c.grpc.DeviceR\x07devices\x12)\n\x08storages\
    \x18\x05\x20\x03(\x0b2\r.grpc.StorageR\x08storages\x12\x1c\n\x03OCI\x18\
    \x06\x20\x01(\x0b2\n.grpc.SpecR\x03OCI\x12#\n\rsandbox_pidns\x18\x07\x20\
    \x01(\x08R\x0csandboxPidns\":\n\x15StartContainerRequest\x12!\n\x0cconta\
    iner_id\x18\x01\x20\x01(\tR\x0bcontainerId\"U\n\x16RemoveContainerReques\
    t\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcontainerId\x12\x18\n\
    \x07timeout\x18\x02\x20\x01(\rR\x07timeout\"\xac\x01\n\x12ExecProcessReq\
    uest\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcontainerId\x12\x17\n\
    \x07exec_id\x18\x02\x20\x01(\tR\x06execId\x121\n\x0bstring_user\x18\x03\
    \x20\x01(\x0b2\x10.grpc.StringUserR\nstringUser\x12'\n\x07process\x18\
    \x04\x20\x01(\x0b2\r.grpc.ProcessR\x07process\"j\n\x14SignalProcessReque\
    st\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcontainerId\x12\x17\n\
    \x07exec_id\x18\x02\x20\x01(\tR\x06execId\x12\x16\n\x06signal\x18\x03\
    \x20\x01(\rR\x06signal\"P\n\x12WaitProcessRequest\x12!\n\x0ccontainer_id\
    \x18\x01\x20\x01(\tR\x0bcontainerId\x12\x17\n\x07exec_id\x18\x02\x20\x01\
    (\tR\x06execId\"-\n\x13WaitProcessResponse\x12\x16\n\x06status\x18\x01\
    \x20\x01(\x05R\x06status\"o\n\x16UpdateContainerRequest\x12!\n\x0ccontai\
    ner_id\x18\x01\x20\x01(\tR\x0bcontainerId\x122\n\tresources\x18\x02\x20\
    \x01(\x0b2\x14.grpc.LinuxResourcesR\tresources\":\n\x15StatsContainerReq\
    uest\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcontainerId\":\n\x15P\
    auseContainerRequest\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bconta\
    inerId\";\n\x16ResumeContainerRequest\x12!\n\x0ccontainer_id\x18\x01\x20\
    \x01(\tR\x0bcontainerId\"\xaa\x01\n\x08CpuUsage\x12\x1f\n\x0btotal_usage\
    \x18\x01\x20\x01(\x04R\ntotalUsage\x12!\n\x0cpercpu_usage\x18\x02\x20\
    \x03(\x04R\x0bpercpuUsage\x12.\n\x13usage_in_kernelmode\x18\x03\x20\x01(\
    \x04R\x11usageInKernelmode\x12*\n\x11usage_in_usermode\x18\x04\x20\x01(\
    \x04R\x0fusageInUsermode\"~\n\x0eThrottlingData\x12\x18\n\x07periods\x18\
    \x01\x20\x01(\x04R\x07periods\x12+\n\x11throttled_periods\x18\x02\x20\
    \x01(\x04R\x10throttledPeriods\x12%\n\x0ethrottled_time\x18\x03\x20\x01(\
    \x04R\rthrottledTime\"v\n\x08CpuStats\x12+\n\tcpu_usage\x18\x01\x20\x01(\
    \x0b2\x0e.grpc.CpuUsageR\x08cpuUsage\x12=\n\x0fthrottling_data\x18\x02\
    \x20\x01(\x0b2\x14.grpc.ThrottlingDataR\x0ethrottlingData\";\n\tPidsStat\
    s\x12\x18\n\x07current\x18\x01\x20\x01(\x04R\x07current\x12\x14\n\x05lim\
    it\x18\x02\x20\x01(\x04R\x05limit\"o\n\nMemoryData\x12\x14\n\x05usage\
    \x18\x01\x20\x01(\x04R\x05usage\x12\x1b\n\tmax_usage\x18\x02\x20\x01(\
    \x04R\x08maxUsage\x12\x18\n\x07failcnt\x18\x03\x20\x01(\x04R\x07failcnt\
    \x12\x14\n\x05limit\x18\x04\x20\x01(\x04R\x05limit\"\xc4\x02\n\x0bMemory\
    Stats\x12\x14\n\x05cache\x18\x01\x20\x01(\x04R\x05cache\x12&\n\x05usage\
    \x18\x02\x20\x01(\x0b2\x10.grpc.MemoryDataR\x05usage\x12/\n\nswap_usage\
    \x18\x03\x20\x01(\x0b2\x10.grpc.MemoryDataR\tswapUsage\x123\n\x0ckernel_\
    usage\x18\x04\x20\x01(\x0b2\x10.grpc.MemoryDataR\x0bkernelUsage\x12#\n\r\
    use_hierarchy\x18\x05\x20\x01(\x08R\x0cuseHierarchy\x122\n\x05stats\x18\
    \x06\x20\x03(\x0b2\x1c.grpc.MemoryStats.StatsEntryR\x05stats\x1a8\n\nSta\
    tsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x04R\x05value:\x028\x01\"c\n\x0fBlkioStatsEntry\x12\
    \x14\n\x05major\x18\x01\x20\x01(\x04R\x05major\x12\x14\n\x05minor\x18\
    \x02\x20\x01(\x04R\x05minor\x12\x0e\n\x02op\x18\x03\x20\x01(\tR\x02op\
    \x12\x14\n\x05value\x18\x04\x20\x01(\x04R\x05value\"\xde\x04\n\nBlkioSta\
    ts\x12R\n\x1aio_service_bytes_recursive\x18\x01\x20\x03(\x0b2\x15.grpc.B\
    lkioStatsEntryR\x17ioServiceBytesRecursive\x12I\n\x15io_serviced_recursi\
    ve\x18\x02\x20\x03(\x0b2\x15.grpc.BlkioStatsEntryR\x13ioServicedRecursiv\
    e\x12E\n\x13io_queued_recursive\x18\x03\x20\x03(\x0b2\x15.grpc.BlkioStat\
    sEntryR\x11ioQueuedRecursive\x12P\n\x19io_service_time_recursive\x18\x04\
    \x20\x03(\x0b2\x15.grpc.BlkioStatsEntryR\x16ioServiceTimeRecursive\x12J\
    \n\x16io_wait_time_recursive\x18\x05\x20\x03(\x0b2\x15.grpc.BlkioStatsEn\
    tryR\x13ioWaitTimeRecursive\x12E\n\x13io_merged_recursive\x18\x06\x20\
    \x03(\x0b2\x15.grpc.BlkioStatsEntryR\x11ioMergedRecursive\x12A\n\x11io_t\
    ime_recursive\x18\x07\x20\x03(\x0b2\x15.grpc.BlkioStatsEntryR\x0fioTimeR\
    ecursive\x12B\n\x11sectors_recursive\x18\x08\x20\x03(\x0b2\x15.grpc.Blki\
    oStatsEntryR\x10sectorsRecursive\"[\n\x0cHugetlbStats\x12\x14\n\x05usage\
    \x18\x01\x20\x01(\x04R\x05usage\x12\x1b\n\tmax_usage\x18\x02\x20\x01(\
    \x04R\x08maxUsage\x12\x18\n\x07failcnt\x18\x03\x20\x01(\x04R\x07failcnt\
    \"\xf2\x02\n\x0bCgroupStats\x12+\n\tcpu_stats\x18\x01\x20\x01(\x0b2\x0e.\
    grpc.CpuStatsR\x08cpuStats\x124\n\x0cmemory_stats\x18\x02\x20\x01(\x0b2\
    \x11.grpc.MemoryStatsR\x0bmemoryStats\x12.\n\npids_stats\x18\x03\x20\x01\
    (\x0b2\x0f.grpc.PidsStatsR\tpidsStats\x121\n\x0bblkio_stats\x18\x04\x20\
    \x01(\x0b2\x10.grpc.BlkioStatsR\nblkioStats\x12H\n\rhugetlb_stats\x18\
    \x05\x20\x03(\x0b2#.grpc.CgroupStats.HugetlbStatsEntryR\x0chugetlbStats\
    \x1aS\n\x11HugetlbStatsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12(\n\x05value\x18\x02\x20\x01(\x0b2\x12.grpc.HugetlbStatsR\x05value:\
    \x028\x01\"\x8e\x02\n\x0cNetworkStats\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12\x19\n\x08rx_bytes\x18\x02\x20\x01(\x04R\x07rxBytes\x12\
    \x1d\n\nrx_packets\x18\x03\x20\x01(\x04R\trxPackets\x12\x1b\n\trx_errors\
    \x18\x04\x20\x01(\x04R\x08rxErrors\x12\x1d\n\nrx_dropped\x18\x05\x20\x01\
    (\x04R\trxDropped\x12\x19\n\x08tx_bytes\x18\x06\x20\x01(\x04R\x07txBytes\
    \x12\x1d\n\ntx_packets\x18\x07\x20\x01(\x04R\ttxPackets\x12\x1b\n\ttx_er\
    rors\x18\x08\x20\x01(\x04R\x08txErrors\x12\x1d\n\ntx_dropped\x18\t\x20\
    \x01(\x04R\ttxDropped\"\x87\x01\n\x16StatsContainerResponse\x124\n\x0ccg\
    roup_stats\x18\x01\x20\x01(\x0b2\x11.grpc.CgroupStatsR\x0bcgroupStats\
    \x127\n\rnetwork_stats\x18\x02\x20\x03(\x0b2\x12.grpc.NetworkStatsR\x0cn\
    etworkStats\"d\n\x12WriteStreamRequest\x12!\n\x0ccontainer_id\x18\x01\
    \x20\x01(\tR\x0bcontainerId\x12\x17\n\x07exec_id\x18\x02\x20\x01(\tR\x06\
    execId\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"'\n\x13WriteStre\
    amResponse\x12\x10\n\x03len\x18\x01\x20\x01(\rR\x03len\"a\n\x11ReadStrea\
    mRequest\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcontainerId\x12\
    \x17\n\x07exec_id\x18\x02\x20\x01(\tR\x06execId\x12\x10\n\x03len\x18\x03\
    \x20\x01(\rR\x03len\"(\n\x12ReadStreamResponse\x12\x12\n\x04data\x18\x01\
    \x20\x01(\x0cR\x04data\"O\n\x11CloseStdinRequest\x12!\n\x0ccontainer_id\
    \x18\x01\x20\x01(\tR\x0bcontainerId\x12\x17\n\x07exec_id\x18\x02\x20\x01\
    (\tR\x06execId\"{\n\x13TtyWinResizeRequest\x12!\n\x0ccontainer_id\x18\
    \x01\x20\x01(\tR\x0bcontainerId\x12\x17\n\x07exec_id\x18\x02\x20\x01(\tR\
    \x06execId\x12\x10\n\x03row\x18\x03\x20\x01(\rR\x03row\x12\x16\n\x06colu\
    mn\x18\x04\x20\x01(\rR\x06column\"B\n\x0cKernelModule\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x1e\n\nparameters\x18\x02\x20\x03(\tR\n\
    parameters\"\x96\x02\n\x14CreateSandboxRequest\x12\x1a\n\x08hostname\x18\
    \x01\x20\x01(\tR\x08hostname\x12\x10\n\x03dns\x18\x02\x20\x03(\tR\x03dns\
    \x12)\n\x08storages\x18\x03\x20\x03(\x0b2\r.grpc.StorageR\x08storages\
    \x12#\n\rsandbox_pidns\x18\x04\x20\x01(\x08R\x0csandboxPidns\x12\x1d\n\n\
    sandbox_id\x18\x05\x20\x01(\tR\tsandboxId\x12&\n\x0fguest_hook_path\x18\
    \x06\x20\x01(\tR\rguestHookPath\x129\n\x0ekernel_modules\x18\x07\x20\x03\
    (\x0b2\x12.grpc.KernelModuleR\rkernelModules\"\x17\n\x15DestroySandboxRe\
    quest\"'\n%RemoveStaleVirtiofsShareMountsRequest\">\n\nInterfaces\x120\n\
    \nInterfaces\x18\x01\x20\x03(\x0b2\x10.types.InterfaceR\nInterfaces\".\n\
    \x06Routes\x12$\n\x06Routes\x18\x01\x20\x03(\x0b2\x0c.types.RouteR\x06Ro\
    utes\"H\n\x16UpdateInterfaceRequest\x12.\n\tinterface\x18\x01\x20\x01(\
    \x0b2\x10.types.InterfaceR\tinterface\";\n\x13UpdateRoutesRequest\x12$\n\
    \x06routes\x18\x01\x20\x01(\x0b2\x0c.grpc.RoutesR\x06routes\"I\n\x1cUpda\
    teEphemeralMountsRequest\x12)\n\x08storages\x18\x01\x20\x03(\x0b2\r.grpc\
    .StorageR\x08storages\"\x17\n\x15ListInterfacesRequest\"\x13\n\x11ListRo\
    utesRequest\"F\n\x0cARPNeighbors\x126\n\x0cARPNeighbors\x18\x01\x20\x03(\
    \x0b2\x12.types.ARPNeighborR\x0cARPNeighbors\"J\n\x16AddARPNeighborsRequ\
    est\x120\n\tneighbors\x18\x01\x20\x01(\x0b2\x12.grpc.ARPNeighborsR\tneig\
    hbors\"-\n\x12GetIPTablesRequest\x12\x17\n\x07is_ipv6\x18\x01\x20\x01(\
    \x08R\x06isIpv6\")\n\x13GetIPTablesResponse\x12\x12\n\x04data\x18\x01\
    \x20\x01(\x0cR\x04data\"A\n\x12SetIPTablesRequest\x12\x17\n\x07is_ipv6\
    \x18\x01\x20\x01(\x08R\x06isIpv6\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\
    \x04data\")\n\x13SetIPTablesResponse\x12\x12\n\x04data\x18\x01\x20\x01(\
    \x0cR\x04data\"]\n\x13OnlineCPUMemRequest\x12\x12\n\x04wait\x18\x01\x20\
    \x01(\x08R\x04wait\x12\x17\n\x07nb_cpus\x18\x02\x20\x01(\rR\x06nbCpus\
    \x12\x19\n\x08cpu_only\x18\x03\x20\x01(\x08R\x07cpuOnly\",\n\x16ReseedRa\
    ndomDevRequest\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\"\xc8\x01\
    \n\x0cAgentDetails\x12\x18\n\x07version\x18\x01\x20\x01(\tR\x07version\
    \x12\x1f\n\x0binit_daemon\x18\x02\x20\x01(\x08R\ninitDaemon\x12'\n\x0fde\
    vice_handlers\x18\x03\x20\x03(\tR\x0edeviceHandlers\x12)\n\x10storage_ha\
    ndlers\x18\x04\x20\x03(\tR\x0fstorageHandlers\x12)\n\x10supports_seccomp\
    \x18\x05\x20\x01(\x08R\x0fsupportsSeccomp\"g\n\x13GuestDetailsRequest\
    \x12$\n\x0emem_block_size\x18\x01\x20\x01(\x08R\x0cmemBlockSize\x12*\n\
    \x11mem_hotplug_probe\x18\x02\x20\x01(\x08R\x0fmemHotplugProbe\"\xbb\x01\
    \n\x14GuestDetailsResponse\x12/\n\x14mem_block_size_bytes\x18\x01\x20\
    \x01(\x04R\x11memBlockSizeBytes\x127\n\ragent_details\x18\x02\x20\x01(\
    \x0b2\x12.grpc.AgentDetailsR\x0cagentDetails\x129\n\x19support_mem_hotpl\
    ug_probe\x18\x03\x20\x01(\x08R\x16supportMemHotplugProbe\"L\n\x18MemHotp\
    lugByProbeRequest\x120\n\x13memHotplugProbeAddr\x18\x01\x20\x03(\x04R\
    \x13memHotplugProbeAddr\"?\n\x17SetGuestDateTimeRequest\x12\x10\n\x03Sec\
    \x18\x01\x20\x01(\x03R\x03Sec\x12\x12\n\x04Usec\x18\x02\x20\x01(\x03R\
    \x04Usec\"p\n\x07FSGroup\x12\x19\n\x08group_id\x18\x02\x20\x01(\rR\x07gr\
    oupId\x12J\n\x13group_change_policy\x18\x03\x20\x01(\x0e2\x1a.types.FSGr\
    oupChangePolicyR\x11groupChangePolicy\"\xdd\x01\n\x07Storage\x12\x16\n\
    \x06driver\x18\x01\x20\x01(\tR\x06driver\x12%\n\x0edriver_options\x18\
    \x02\x20\x03(\tR\rdriverOptions\x12\x16\n\x06source\x18\x03\x20\x01(\tR\
    \x06source\x12\x16\n\x06fstype\x18\x04\x20\x01(\tR\x06fstype\x12\x18\n\
    \x07options\x18\x05\x20\x03(\tR\x07options\x12\x1f\n\x0bmount_point\x18\
    \x06\x20\x01(\tR\nmountPoint\x12(\n\x08fs_group\x18\x07\x20\x01(\x0b2\r.\
    grpc.FSGroupR\x07fsGroup\"\x86\x01\n\x06Device\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x12\n\x04type\x18\x02\x20\x01(\tR\x04type\x12\x17\
    \n\x07vm_path\x18\x03\x20\x01(\tR\x06vmPath\x12%\n\x0econtainer_path\x18\
    \x04\x20\x01(\tR\rcontainerPath\x12\x18\n\x07options\x18\x05\x20\x03(\tR\
    \x07options\"X\n\nStringUser\x12\x10\n\x03uid\x18\x01\x20\x01(\tR\x03uid\
    \x12\x10\n\x03gid\x18\x02\x20\x01(\tR\x03gid\x12&\n\x0eadditionalGids\
    \x18\x03\x20\x03(\tR\x0eadditionalGids\"\xca\x01\n\x0fCopyFileRequest\
    \x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12\x1b\n\tfile_size\x18\
    \x02\x20\x01(\x03R\x08fileSize\x12\x1b\n\tfile_mode\x18\x03\x20\x01(\rR\
    \x08fileMode\x12\x19\n\x08dir_mode\x18\x04\x20\x01(\rR\x07dirMode\x12\
    \x10\n\x03uid\x18\x05\x20\x01(\x05R\x03uid\x12\x10\n\x03gid\x18\x06\x20\
    \x01(\x05R\x03gid\x12\x16\n\x06offset\x18\x07\x20\x01(\x03R\x06offset\
    \x12\x12\n\x04data\x18\x08\x20\x01(\x0cR\x04data\"\x14\n\x12GetOOMEventR\
    equest\"-\n\x08OOMEvent\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bco\
    ntainerId\"*\n\x0eAddSwapRequest\x12\x18\n\x07PCIPath\x18\x01\x20\x03(\r\
    R\x07PCIPath\"\x13\n\x11GetMetricsRequest\"#\n\x07Metrics\x12\x18\n\x07m\
    etrics\x18\x01\x20\x01(\tR\x07metrics\"@\n\x12VolumeStatsRequest\x12*\n\
    \x11volume_guest_path\x18\x01\x20\x01(\tR\x0fvolumeGuestPath\"U\n\x13Res\
    izeVolumeRequest\x12*\n\x11volume_guest_path\x18\x01\x20\x01(\tR\x0fvolu\
    meGuestPath\x12\x12\n\x04size\x18\x02\x20\x01(\x04R\x04size2\x84\x14\n\
    \x0cAgentService\x12G\n\x0fCreateContainer\x12\x1c.grpc.CreateContainerR\
    equest\x1a\x16.google.protobuf.Empty\x12E\n\x0eStartContainer\x12\x1b.gr\
    pc.StartContainerRequest\x1a\x16.google.protobuf.Empty\x12G\n\x0fRemoveC\
    ontainer\x12\x1c.grpc.RemoveContainerRequest\x1a\x16.google.protobuf.Emp\
    ty\x12?\n\x0bExecProcess\x12\x18.grpc.ExecProcessRequest\x1a\x16.google.\
    protobuf.Empty\x12C\n\rSignalProcess\x12\x1a.grpc.SignalProcessRequest\
    \x1a\x16.google.protobuf.Empty\x12B\n\x0bWaitProcess\x12\x18.grpc.WaitPr\
    ocessRequest\x1a\x19.grpc.WaitProcessResponse\x12G\n\x0fUpdateContainer\
    \x12\x1c.grpc.UpdateContainerRequest\x1a\x16.google.protobuf.Empty\x12S\
    \n\x15UpdateEphemeralMounts\x12\".grpc.UpdateEphemeralMountsRequest\x1a\
    \x16.google.protobuf.Empty\x12K\n\x0eStatsContainer\x12\x1b.grpc.StatsCo\
    ntainerRequest\x1a\x1c.grpc.StatsContainerResponse\x12E\n\x0ePauseContai\
    ner\x12\x1b.grpc.PauseContainerRequest\x1a\x16.google.protobuf.Empty\x12\
    G\n\x0fResumeContainer\x12\x1c.grpc.ResumeContainerRequest\x1a\x16.googl\
    e.protobuf.Empty\x12e\n\x1eRemoveStaleVirtiofsShareMounts\x12+.grpc.Remo\
    veStaleVirtiofsShareMountsRequest\x1a\x16.google.protobuf.Empty\x12A\n\n\
    WriteStdin\x12\x18.grpc.WriteStreamRequest\x1a\x19.grpc.WriteStreamRespo\
    nse\x12?\n\nReadStdout\x12\x17.grpc.ReadStreamRequest\x1a\x18.grpc.ReadS\
    treamResponse\x12?\n\nReadStderr\x12\x17.grpc.ReadStreamRequest\x1a\x18.\
    grpc.ReadStreamResponse\x12=\n\nCloseStdin\x12\x17.grpc.CloseStdinReques\
    t\x1a\x16.google.protobuf.Empty\x12A\n\x0cTtyWinResize\x12\x19.grpc.TtyW\
    inResizeRequest\x1a\x16.google.protobuf.Empty\x12A\n\x0fUpdateInterface\
    \x12\x1c.grpc.UpdateInterfaceRequest\x1a\x10.types.Interface\x127\n\x0cU\
    pdateRoutes\x12\x19.grpc.UpdateRoutesRequest\x1a\x0c.grpc.Routes\x12?\n\
    \x0eListInterfaces\x12\x1b.grpc.ListInterfacesRequest\x1a\x10.grpc.Inter\
    faces\x123\n\nListRoutes\x12\x17.grpc.ListRoutesRequest\x1a\x0c.grpc.Rou\
    tes\x12G\n\x0fAddARPNeighbors\x12\x1c.grpc.AddARPNeighborsRequest\x1a\
    \x16.google.protobuf.Empty\x12B\n\x0bGetIPTables\x12\x18.grpc.GetIPTable\
    sRequest\x1a\x19.grpc.GetIPTablesResponse\x12B\n\x0bSetIPTables\x12\x18.\
    grpc.SetIPTablesRequest\x1a\x19.grpc.SetIPTablesResponse\x124\n\nGetMetr\
    ics\x12\x17.grpc.GetMetricsRequest\x1a\r.grpc.Metrics\x12C\n\rCreateSand\
    box\x12\x1a.grpc.CreateSandboxRequest\x1a\x16.google.protobuf.Empty\x12E\
    \n\x0eDestroySandbox\x12\x1b.grpc.DestroySandboxRequest\x1a\x16.google.p\
    rotobuf.Empty\x12A\n\x0cOnlineCPUMem\x12\x19.grpc.OnlineCPUMemRequest\
    \x1a\x16.google.protobuf.Empty\x12G\n\x0fReseedRandomDev\x12\x1c.grpc.Re\
    seedRandomDevRequest\x1a\x16.google.protobuf.Empty\x12H\n\x0fGetGuestDet\
    ails\x12\x19.grpc.GuestDetailsRequest\x1a\x1a.grpc.GuestDetailsResponse\
    \x12K\n\x11MemHotplugByProbe\x12\x1e.grpc.MemHotplugByProbeRequest\x1a\
    \x16.google.protobuf.Empty\x12I\n\x10SetGuestDateTime\x12\x1d.grpc.SetGu\
    estDateTimeRequest\x1a\x16.google.protobuf.Empty\x129\n\x08CopyFile\x12\
    \x15.grpc.CopyFileRequest\x1a\x16.google.protobuf.Empty\x127\n\x0bGetOOM\
    Event\x12\x18.grpc.GetOOMEventRequest\x1a\x0e.grpc.OOMEvent\x127\n\x07Ad\
    dSwap\x12\x14.grpc.AddSwapRequest\x1a\x16.google.protobuf.Empty\x12E\n\
    \x0eGetVolumeStats\x12\x18.grpc.VolumeStatsRequest\x1a\x19.grpc.VolumeSt\
    atsResponse\x12A\n\x0cResizeVolume\x12\x19.grpc.ResizeVolumeRequest\x1a\
    \x16.google.protobuf.EmptyB`Z^github.com/kata-containers/kata-containers\
    /src/runtime/virtcontainers/pkg/agent/protocols/grpcb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(4);
            deps.push(super::oci::file_descriptor().clone());
            deps.push(super::csi::file_descriptor().clone());
            deps.push(super::types::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::empty::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(65);
            messages.push(CreateContainerRequest::generated_message_descriptor_data());
            messages.push(StartContainerRequest::generated_message_descriptor_data());
            messages.push(RemoveContainerRequest::generated_message_descriptor_data());
            messages.push(ExecProcessRequest::generated_message_descriptor_data());
            messages.push(SignalProcessRequest::generated_message_descriptor_data());
            messages.push(WaitProcessRequest::generated_message_descriptor_data());
            messages.push(WaitProcessResponse::generated_message_descriptor_data());
            messages.push(UpdateContainerRequest::generated_message_descriptor_data());
            messages.push(StatsContainerRequest::generated_message_descriptor_data());
            messages.push(PauseContainerRequest::generated_message_descriptor_data());
            messages.push(ResumeContainerRequest::generated_message_descriptor_data());
            messages.push(CpuUsage::generated_message_descriptor_data());
            messages.push(ThrottlingData::generated_message_descriptor_data());
            messages.push(CpuStats::generated_message_descriptor_data());
            messages.push(PidsStats::generated_message_descriptor_data());
            messages.push(MemoryData::generated_message_descriptor_data());
            messages.push(MemoryStats::generated_message_descriptor_data());
            messages.push(BlkioStatsEntry::generated_message_descriptor_data());
            messages.push(BlkioStats::generated_message_descriptor_data());
            messages.push(HugetlbStats::generated_message_descriptor_data());
            messages.push(CgroupStats::generated_message_descriptor_data());
            messages.push(NetworkStats::generated_message_descriptor_data());
            messages.push(StatsContainerResponse::generated_message_descriptor_data());
            messages.push(WriteStreamRequest::generated_message_descriptor_data());
            messages.push(WriteStreamResponse::generated_message_descriptor_data());
            messages.push(ReadStreamRequest::generated_message_descriptor_data());
            messages.push(ReadStreamResponse::generated_message_descriptor_data());
            messages.push(CloseStdinRequest::generated_message_descriptor_data());
            messages.push(TtyWinResizeRequest::generated_message_descriptor_data());
            messages.push(KernelModule::generated_message_descriptor_data());
            messages.push(CreateSandboxRequest::generated_message_descriptor_data());
            messages.push(DestroySandboxRequest::generated_message_descriptor_data());
            messages.push(RemoveStaleVirtiofsShareMountsRequest::generated_message_descriptor_data());
            messages.push(Interfaces::generated_message_descriptor_data());
            messages.push(Routes::generated_message_descriptor_data());
            messages.push(UpdateInterfaceRequest::generated_message_descriptor_data());
            messages.push(UpdateRoutesRequest::generated_message_descriptor_data());
            messages.push(UpdateEphemeralMountsRequest::generated_message_descriptor_data());
            messages.push(ListInterfacesRequest::generated_message_descriptor_data());
            messages.push(ListRoutesRequest::generated_message_descriptor_data());
            messages.push(ARPNeighbors::generated_message_descriptor_data());
            messages.push(AddARPNeighborsRequest::generated_message_descriptor_data());
            messages.push(GetIPTablesRequest::generated_message_descriptor_data());
            messages.push(GetIPTablesResponse::generated_message_descriptor_data());
            messages.push(SetIPTablesRequest::generated_message_descriptor_data());
            messages.push(SetIPTablesResponse::generated_message_descriptor_data());
            messages.push(OnlineCPUMemRequest::generated_message_descriptor_data());
            messages.push(ReseedRandomDevRequest::generated_message_descriptor_data());
            messages.push(AgentDetails::generated_message_descriptor_data());
            messages.push(GuestDetailsRequest::generated_message_descriptor_data());
            messages.push(GuestDetailsResponse::generated_message_descriptor_data());
            messages.push(MemHotplugByProbeRequest::generated_message_descriptor_data());
            messages.push(SetGuestDateTimeRequest::generated_message_descriptor_data());
            messages.push(FSGroup::generated_message_descriptor_data());
            messages.push(Storage::generated_message_descriptor_data());
            messages.push(Device::generated_message_descriptor_data());
            messages.push(StringUser::generated_message_descriptor_data());
            messages.push(CopyFileRequest::generated_message_descriptor_data());
            messages.push(GetOOMEventRequest::generated_message_descriptor_data());
            messages.push(OOMEvent::generated_message_descriptor_data());
            messages.push(AddSwapRequest::generated_message_descriptor_data());
            messages.push(GetMetricsRequest::generated_message_descriptor_data());
            messages.push(Metrics::generated_message_descriptor_data());
            messages.push(VolumeStatsRequest::generated_message_descriptor_data());
            messages.push(ResizeVolumeRequest::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}