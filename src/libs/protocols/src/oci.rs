// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `oci.proto`

//! Generated by "C:\\phf\\workspace\\security-compute\\code6\\kata-containers\\src\\libs\\protocols\\build.rs" ("build_script_build")

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.Spec)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct Spec {
    // message fields
    // @@protoc_insertion_point(field:grpc.Spec.Version)
    pub Version: ::std::string::String,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.Spec.Process)
    pub Process: ::protobuf::MessageField<Process>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.Spec.Root)
    pub Root: ::protobuf::MessageField<Root>,
    // @@protoc_insertion_point(field:grpc.Spec.Hostname)
    pub Hostname: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Spec.Mounts)
    pub Mounts: ::std::vec::Vec<Mount>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.Spec.Hooks)
    pub Hooks: ::protobuf::MessageField<Hooks>,
    // @@protoc_insertion_point(field:grpc.Spec.Annotations)
    pub Annotations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.Spec.Linux)
    pub Linux: ::protobuf::MessageField<Linux>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.Spec.Solaris)
    pub Solaris: ::protobuf::MessageField<Solaris>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.Spec.Windows)
    pub Windows: ::protobuf::MessageField<Windows>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.Spec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Spec {
    fn default() -> &'a Spec {
        <Spec as ::protobuf::Message>::default_instance()
    }
}

impl Spec {
    pub fn new() -> Spec {
        ::std::default::Default::default()
    }

    // string Version = 1;

    pub fn Version(&self) -> &str {
        &self.Version
    }

    pub fn clear_Version(&mut self) {
        self.Version.clear();
    }

    // Param is passed by value, moved
    pub fn set_Version(&mut self, v: ::std::string::String) {
        self.Version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Version(&mut self) -> &mut ::std::string::String {
        &mut self.Version
    }

    // Take field
    pub fn take_Version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Version, ::std::string::String::new())
    }

    // .grpc.Process Process = 2;

    pub fn Process(&self) -> &Process {
        self.Process.as_ref().unwrap_or_else(|| <Process as ::protobuf::Message>::default_instance())
    }

    pub fn clear_Process(&mut self) {
        self.Process.clear();
    }

    pub fn has_Process(&self) -> bool {
        self.Process.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Process(&mut self, v: Process) {
        self.Process = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Process(&mut self) -> &mut Process {
        self.Process.mut_or_insert_default()
    }

    // Take field
    pub fn take_Process(&mut self) -> Process {
        self.Process.take().unwrap_or_else(|| Process::new())
    }

    // .grpc.Root Root = 3;

    pub fn Root(&self) -> &Root {
        self.Root.as_ref().unwrap_or_else(|| <Root as ::protobuf::Message>::default_instance())
    }

    pub fn clear_Root(&mut self) {
        self.Root.clear();
    }

    pub fn has_Root(&self) -> bool {
        self.Root.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Root(&mut self, v: Root) {
        self.Root = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Root(&mut self) -> &mut Root {
        self.Root.mut_or_insert_default()
    }

    // Take field
    pub fn take_Root(&mut self) -> Root {
        self.Root.take().unwrap_or_else(|| Root::new())
    }

    // string Hostname = 4;

    pub fn Hostname(&self) -> &str {
        &self.Hostname
    }

    pub fn clear_Hostname(&mut self) {
        self.Hostname.clear();
    }

    // Param is passed by value, moved
    pub fn set_Hostname(&mut self, v: ::std::string::String) {
        self.Hostname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Hostname(&mut self) -> &mut ::std::string::String {
        &mut self.Hostname
    }

    // Take field
    pub fn take_Hostname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Hostname, ::std::string::String::new())
    }

    // repeated .grpc.Mount Mounts = 5;

    pub fn Mounts(&self) -> &[Mount] {
        &self.Mounts
    }

    pub fn clear_Mounts(&mut self) {
        self.Mounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_Mounts(&mut self, v: ::std::vec::Vec<Mount>) {
        self.Mounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Mounts(&mut self) -> &mut ::std::vec::Vec<Mount> {
        &mut self.Mounts
    }

    // Take field
    pub fn take_Mounts(&mut self) -> ::std::vec::Vec<Mount> {
        ::std::mem::replace(&mut self.Mounts, ::std::vec::Vec::new())
    }

    // .grpc.Hooks Hooks = 6;

    pub fn Hooks(&self) -> &Hooks {
        self.Hooks.as_ref().unwrap_or_else(|| <Hooks as ::protobuf::Message>::default_instance())
    }

    pub fn clear_Hooks(&mut self) {
        self.Hooks.clear();
    }

    pub fn has_Hooks(&self) -> bool {
        self.Hooks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Hooks(&mut self, v: Hooks) {
        self.Hooks = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Hooks(&mut self) -> &mut Hooks {
        self.Hooks.mut_or_insert_default()
    }

    // Take field
    pub fn take_Hooks(&mut self) -> Hooks {
        self.Hooks.take().unwrap_or_else(|| Hooks::new())
    }

    // repeated .grpc.Spec.AnnotationsEntry Annotations = 7;

    pub fn Annotations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.Annotations
    }

    pub fn clear_Annotations(&mut self) {
        self.Annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_Annotations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.Annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Annotations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.Annotations
    }

    // Take field
    pub fn take_Annotations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.Annotations, ::std::collections::HashMap::new())
    }

    // .grpc.Linux Linux = 8;

    pub fn Linux(&self) -> &Linux {
        self.Linux.as_ref().unwrap_or_else(|| <Linux as ::protobuf::Message>::default_instance())
    }

    pub fn clear_Linux(&mut self) {
        self.Linux.clear();
    }

    pub fn has_Linux(&self) -> bool {
        self.Linux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Linux(&mut self, v: Linux) {
        self.Linux = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Linux(&mut self) -> &mut Linux {
        self.Linux.mut_or_insert_default()
    }

    // Take field
    pub fn take_Linux(&mut self) -> Linux {
        self.Linux.take().unwrap_or_else(|| Linux::new())
    }

    // .grpc.Solaris Solaris = 9;

    pub fn Solaris(&self) -> &Solaris {
        self.Solaris.as_ref().unwrap_or_else(|| <Solaris as ::protobuf::Message>::default_instance())
    }

    pub fn clear_Solaris(&mut self) {
        self.Solaris.clear();
    }

    pub fn has_Solaris(&self) -> bool {
        self.Solaris.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Solaris(&mut self, v: Solaris) {
        self.Solaris = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Solaris(&mut self) -> &mut Solaris {
        self.Solaris.mut_or_insert_default()
    }

    // Take field
    pub fn take_Solaris(&mut self) -> Solaris {
        self.Solaris.take().unwrap_or_else(|| Solaris::new())
    }

    // .grpc.Windows Windows = 10;

    pub fn Windows(&self) -> &Windows {
        self.Windows.as_ref().unwrap_or_else(|| <Windows as ::protobuf::Message>::default_instance())
    }

    pub fn clear_Windows(&mut self) {
        self.Windows.clear();
    }

    pub fn has_Windows(&self) -> bool {
        self.Windows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Windows(&mut self, v: Windows) {
        self.Windows = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Windows(&mut self) -> &mut Windows {
        self.Windows.mut_or_insert_default()
    }

    // Take field
    pub fn take_Windows(&mut self) -> Windows {
        self.Windows.take().unwrap_or_else(|| Windows::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Version",
            |m: &Spec| { &m.Version },
            |m: &mut Spec| { &mut m.Version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Process>(
            "Process",
            |m: &Spec| { &m.Process },
            |m: &mut Spec| { &mut m.Process },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Root>(
            "Root",
            |m: &Spec| { &m.Root },
            |m: &mut Spec| { &mut m.Root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Hostname",
            |m: &Spec| { &m.Hostname },
            |m: &mut Spec| { &mut m.Hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Mounts",
            |m: &Spec| { &m.Mounts },
            |m: &mut Spec| { &mut m.Mounts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Hooks>(
            "Hooks",
            |m: &Spec| { &m.Hooks },
            |m: &mut Spec| { &mut m.Hooks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "Annotations",
            |m: &Spec| { &m.Annotations },
            |m: &mut Spec| { &mut m.Annotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Linux>(
            "Linux",
            |m: &Spec| { &m.Linux },
            |m: &mut Spec| { &mut m.Linux },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Solaris>(
            "Solaris",
            |m: &Spec| { &m.Solaris },
            |m: &mut Spec| { &mut m.Solaris },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Windows>(
            "Windows",
            |m: &Spec| { &m.Windows },
            |m: &mut Spec| { &mut m.Windows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Spec>(
            "Spec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Spec {
    const NAME: &'static str = "Spec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Version = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Process)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Root)?;
                },
                34 => {
                    self.Hostname = is.read_string()?;
                },
                42 => {
                    self.Mounts.push(is.read_message()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Hooks)?;
                },
                58 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.Annotations.insert(key, value);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Linux)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Solaris)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Windows)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Version);
        }
        if let Some(v) = self.Process.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.Root.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.Hostname.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.Hostname);
        }
        for value in &self.Mounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.Hooks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.Annotations {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.Linux.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.Solaris.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.Windows.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Version.is_empty() {
            os.write_string(1, &self.Version)?;
        }
        if let Some(v) = self.Process.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.Root.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.Hostname.is_empty() {
            os.write_string(4, &self.Hostname)?;
        }
        for v in &self.Mounts {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.Hooks.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for (k, v) in &self.Annotations {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(58)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.Linux.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.Solaris.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.Windows.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Spec {
        Spec::new()
    }

    fn clear(&mut self) {
        self.Version.clear();
        self.Process.clear();
        self.Root.clear();
        self.Hostname.clear();
        self.Mounts.clear();
        self.Hooks.clear();
        self.Annotations.clear();
        self.Linux.clear();
        self.Solaris.clear();
        self.Windows.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Spec {
        static instance: ::protobuf::rt::Lazy<Spec> = ::protobuf::rt::Lazy::new();
        instance.get(Spec::new)
    }
}

impl ::protobuf::MessageFull for Spec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Spec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Spec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Spec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.Process)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct Process {
    // message fields
    // @@protoc_insertion_point(field:grpc.Process.Terminal)
    pub Terminal: bool,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.Process.ConsoleSize)
    pub ConsoleSize: ::protobuf::MessageField<Box>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.Process.User)
    pub User: ::protobuf::MessageField<User>,
    // @@protoc_insertion_point(field:grpc.Process.Args)
    pub Args: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.Process.Env)
    pub Env: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.Process.Cwd)
    pub Cwd: ::std::string::String,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.Process.Capabilities)
    pub Capabilities: ::protobuf::MessageField<LinuxCapabilities>,
    // @@protoc_insertion_point(field:grpc.Process.Rlimits)
    pub Rlimits: ::std::vec::Vec<POSIXRlimit>,
    // @@protoc_insertion_point(field:grpc.Process.NoNewPrivileges)
    pub NoNewPrivileges: bool,
    // @@protoc_insertion_point(field:grpc.Process.ApparmorProfile)
    pub ApparmorProfile: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Process.OOMScoreAdj)
    pub OOMScoreAdj: i64,
    // @@protoc_insertion_point(field:grpc.Process.SelinuxLabel)
    pub SelinuxLabel: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.Process.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Process {
    fn default() -> &'a Process {
        <Process as ::protobuf::Message>::default_instance()
    }
}

impl Process {
    pub fn new() -> Process {
        ::std::default::Default::default()
    }

    // bool Terminal = 1;

    pub fn Terminal(&self) -> bool {
        self.Terminal
    }

    pub fn clear_Terminal(&mut self) {
        self.Terminal = false;
    }

    // Param is passed by value, moved
    pub fn set_Terminal(&mut self, v: bool) {
        self.Terminal = v;
    }

    // .grpc.Box ConsoleSize = 2;

    pub fn ConsoleSize(&self) -> &Box {
        self.ConsoleSize.as_ref().unwrap_or_else(|| <Box as ::protobuf::Message>::default_instance())
    }

    pub fn clear_ConsoleSize(&mut self) {
        self.ConsoleSize.clear();
    }

    pub fn has_ConsoleSize(&self) -> bool {
        self.ConsoleSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ConsoleSize(&mut self, v: Box) {
        self.ConsoleSize = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ConsoleSize(&mut self) -> &mut Box {
        self.ConsoleSize.mut_or_insert_default()
    }

    // Take field
    pub fn take_ConsoleSize(&mut self) -> Box {
        self.ConsoleSize.take().unwrap_or_else(|| Box::new())
    }

    // .grpc.User User = 3;

    pub fn User(&self) -> &User {
        self.User.as_ref().unwrap_or_else(|| <User as ::protobuf::Message>::default_instance())
    }

    pub fn clear_User(&mut self) {
        self.User.clear();
    }

    pub fn has_User(&self) -> bool {
        self.User.is_some()
    }

    // Param is passed by value, moved
    pub fn set_User(&mut self, v: User) {
        self.User = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_User(&mut self) -> &mut User {
        self.User.mut_or_insert_default()
    }

    // Take field
    pub fn take_User(&mut self) -> User {
        self.User.take().unwrap_or_else(|| User::new())
    }

    // repeated string Args = 4;

    pub fn Args(&self) -> &[::std::string::String] {
        &self.Args
    }

    pub fn clear_Args(&mut self) {
        self.Args.clear();
    }

    // Param is passed by value, moved
    pub fn set_Args(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.Args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Args(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.Args
    }

    // Take field
    pub fn take_Args(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.Args, ::std::vec::Vec::new())
    }

    // repeated string Env = 5;

    pub fn Env(&self) -> &[::std::string::String] {
        &self.Env
    }

    pub fn clear_Env(&mut self) {
        self.Env.clear();
    }

    // Param is passed by value, moved
    pub fn set_Env(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.Env = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Env(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.Env
    }

    // Take field
    pub fn take_Env(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.Env, ::std::vec::Vec::new())
    }

    // string Cwd = 6;

    pub fn Cwd(&self) -> &str {
        &self.Cwd
    }

    pub fn clear_Cwd(&mut self) {
        self.Cwd.clear();
    }

    // Param is passed by value, moved
    pub fn set_Cwd(&mut self, v: ::std::string::String) {
        self.Cwd = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Cwd(&mut self) -> &mut ::std::string::String {
        &mut self.Cwd
    }

    // Take field
    pub fn take_Cwd(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Cwd, ::std::string::String::new())
    }

    // .grpc.LinuxCapabilities Capabilities = 7;

    pub fn Capabilities(&self) -> &LinuxCapabilities {
        self.Capabilities.as_ref().unwrap_or_else(|| <LinuxCapabilities as ::protobuf::Message>::default_instance())
    }

    pub fn clear_Capabilities(&mut self) {
        self.Capabilities.clear();
    }

    pub fn has_Capabilities(&self) -> bool {
        self.Capabilities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Capabilities(&mut self, v: LinuxCapabilities) {
        self.Capabilities = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Capabilities(&mut self) -> &mut LinuxCapabilities {
        self.Capabilities.mut_or_insert_default()
    }

    // Take field
    pub fn take_Capabilities(&mut self) -> LinuxCapabilities {
        self.Capabilities.take().unwrap_or_else(|| LinuxCapabilities::new())
    }

    // repeated .grpc.POSIXRlimit Rlimits = 8;

    pub fn Rlimits(&self) -> &[POSIXRlimit] {
        &self.Rlimits
    }

    pub fn clear_Rlimits(&mut self) {
        self.Rlimits.clear();
    }

    // Param is passed by value, moved
    pub fn set_Rlimits(&mut self, v: ::std::vec::Vec<POSIXRlimit>) {
        self.Rlimits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Rlimits(&mut self) -> &mut ::std::vec::Vec<POSIXRlimit> {
        &mut self.Rlimits
    }

    // Take field
    pub fn take_Rlimits(&mut self) -> ::std::vec::Vec<POSIXRlimit> {
        ::std::mem::replace(&mut self.Rlimits, ::std::vec::Vec::new())
    }

    // bool NoNewPrivileges = 9;

    pub fn NoNewPrivileges(&self) -> bool {
        self.NoNewPrivileges
    }

    pub fn clear_NoNewPrivileges(&mut self) {
        self.NoNewPrivileges = false;
    }

    // Param is passed by value, moved
    pub fn set_NoNewPrivileges(&mut self, v: bool) {
        self.NoNewPrivileges = v;
    }

    // string ApparmorProfile = 10;

    pub fn ApparmorProfile(&self) -> &str {
        &self.ApparmorProfile
    }

    pub fn clear_ApparmorProfile(&mut self) {
        self.ApparmorProfile.clear();
    }

    // Param is passed by value, moved
    pub fn set_ApparmorProfile(&mut self, v: ::std::string::String) {
        self.ApparmorProfile = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ApparmorProfile(&mut self) -> &mut ::std::string::String {
        &mut self.ApparmorProfile
    }

    // Take field
    pub fn take_ApparmorProfile(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ApparmorProfile, ::std::string::String::new())
    }

    // int64 OOMScoreAdj = 11;

    pub fn OOMScoreAdj(&self) -> i64 {
        self.OOMScoreAdj
    }

    pub fn clear_OOMScoreAdj(&mut self) {
        self.OOMScoreAdj = 0;
    }

    // Param is passed by value, moved
    pub fn set_OOMScoreAdj(&mut self, v: i64) {
        self.OOMScoreAdj = v;
    }

    // string SelinuxLabel = 12;

    pub fn SelinuxLabel(&self) -> &str {
        &self.SelinuxLabel
    }

    pub fn clear_SelinuxLabel(&mut self) {
        self.SelinuxLabel.clear();
    }

    // Param is passed by value, moved
    pub fn set_SelinuxLabel(&mut self, v: ::std::string::String) {
        self.SelinuxLabel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SelinuxLabel(&mut self) -> &mut ::std::string::String {
        &mut self.SelinuxLabel
    }

    // Take field
    pub fn take_SelinuxLabel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.SelinuxLabel, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Terminal",
            |m: &Process| { &m.Terminal },
            |m: &mut Process| { &mut m.Terminal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Box>(
            "ConsoleSize",
            |m: &Process| { &m.ConsoleSize },
            |m: &mut Process| { &mut m.ConsoleSize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "User",
            |m: &Process| { &m.User },
            |m: &mut Process| { &mut m.User },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Args",
            |m: &Process| { &m.Args },
            |m: &mut Process| { &mut m.Args },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Env",
            |m: &Process| { &m.Env },
            |m: &mut Process| { &mut m.Env },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Cwd",
            |m: &Process| { &m.Cwd },
            |m: &mut Process| { &mut m.Cwd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinuxCapabilities>(
            "Capabilities",
            |m: &Process| { &m.Capabilities },
            |m: &mut Process| { &mut m.Capabilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Rlimits",
            |m: &Process| { &m.Rlimits },
            |m: &mut Process| { &mut m.Rlimits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NoNewPrivileges",
            |m: &Process| { &m.NoNewPrivileges },
            |m: &mut Process| { &mut m.NoNewPrivileges },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ApparmorProfile",
            |m: &Process| { &m.ApparmorProfile },
            |m: &mut Process| { &mut m.ApparmorProfile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OOMScoreAdj",
            |m: &Process| { &m.OOMScoreAdj },
            |m: &mut Process| { &mut m.OOMScoreAdj },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SelinuxLabel",
            |m: &Process| { &m.SelinuxLabel },
            |m: &mut Process| { &mut m.SelinuxLabel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Process>(
            "Process",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Process {
    const NAME: &'static str = "Process";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Terminal = is.read_bool()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ConsoleSize)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.User)?;
                },
                34 => {
                    self.Args.push(is.read_string()?);
                },
                42 => {
                    self.Env.push(is.read_string()?);
                },
                50 => {
                    self.Cwd = is.read_string()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Capabilities)?;
                },
                66 => {
                    self.Rlimits.push(is.read_message()?);
                },
                72 => {
                    self.NoNewPrivileges = is.read_bool()?;
                },
                82 => {
                    self.ApparmorProfile = is.read_string()?;
                },
                88 => {
                    self.OOMScoreAdj = is.read_int64()?;
                },
                98 => {
                    self.SelinuxLabel = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.Terminal != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ConsoleSize.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.User.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.Args {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.Env {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if !self.Cwd.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.Cwd);
        }
        if let Some(v) = self.Capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.Rlimits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.NoNewPrivileges != false {
            my_size += 1 + 1;
        }
        if !self.ApparmorProfile.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.ApparmorProfile);
        }
        if self.OOMScoreAdj != 0 {
            my_size += ::protobuf::rt::int64_size(11, self.OOMScoreAdj);
        }
        if !self.SelinuxLabel.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.SelinuxLabel);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.Terminal != false {
            os.write_bool(1, self.Terminal)?;
        }
        if let Some(v) = self.ConsoleSize.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.User.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.Args {
            os.write_string(4, &v)?;
        };
        for v in &self.Env {
            os.write_string(5, &v)?;
        };
        if !self.Cwd.is_empty() {
            os.write_string(6, &self.Cwd)?;
        }
        if let Some(v) = self.Capabilities.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.Rlimits {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if self.NoNewPrivileges != false {
            os.write_bool(9, self.NoNewPrivileges)?;
        }
        if !self.ApparmorProfile.is_empty() {
            os.write_string(10, &self.ApparmorProfile)?;
        }
        if self.OOMScoreAdj != 0 {
            os.write_int64(11, self.OOMScoreAdj)?;
        }
        if !self.SelinuxLabel.is_empty() {
            os.write_string(12, &self.SelinuxLabel)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Process {
        Process::new()
    }

    fn clear(&mut self) {
        self.Terminal = false;
        self.ConsoleSize.clear();
        self.User.clear();
        self.Args.clear();
        self.Env.clear();
        self.Cwd.clear();
        self.Capabilities.clear();
        self.Rlimits.clear();
        self.NoNewPrivileges = false;
        self.ApparmorProfile.clear();
        self.OOMScoreAdj = 0;
        self.SelinuxLabel.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Process {
        static instance: Process = Process {
            Terminal: false,
            ConsoleSize: ::protobuf::MessageField::none(),
            User: ::protobuf::MessageField::none(),
            Args: ::std::vec::Vec::new(),
            Env: ::std::vec::Vec::new(),
            Cwd: ::std::string::String::new(),
            Capabilities: ::protobuf::MessageField::none(),
            Rlimits: ::std::vec::Vec::new(),
            NoNewPrivileges: false,
            ApparmorProfile: ::std::string::String::new(),
            OOMScoreAdj: 0,
            SelinuxLabel: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Process {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Process").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Process {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Process {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.Box)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct Box {
    // message fields
    // @@protoc_insertion_point(field:grpc.Box.Height)
    pub Height: u32,
    // @@protoc_insertion_point(field:grpc.Box.Width)
    pub Width: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.Box.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Box {
    fn default() -> &'a Box {
        <Box as ::protobuf::Message>::default_instance()
    }
}

impl Box {
    pub fn new() -> Box {
        ::std::default::Default::default()
    }

    // uint32 Height = 1;

    pub fn Height(&self) -> u32 {
        self.Height
    }

    pub fn clear_Height(&mut self) {
        self.Height = 0;
    }

    // Param is passed by value, moved
    pub fn set_Height(&mut self, v: u32) {
        self.Height = v;
    }

    // uint32 Width = 2;

    pub fn Width(&self) -> u32 {
        self.Width
    }

    pub fn clear_Width(&mut self) {
        self.Width = 0;
    }

    // Param is passed by value, moved
    pub fn set_Width(&mut self, v: u32) {
        self.Width = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Height",
            |m: &Box| { &m.Height },
            |m: &mut Box| { &mut m.Height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Width",
            |m: &Box| { &m.Width },
            |m: &mut Box| { &mut m.Width },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Box>(
            "Box",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Box {
    const NAME: &'static str = "Box";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Height = is.read_uint32()?;
                },
                16 => {
                    self.Width = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.Height != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.Height);
        }
        if self.Width != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.Width);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.Height != 0 {
            os.write_uint32(1, self.Height)?;
        }
        if self.Width != 0 {
            os.write_uint32(2, self.Width)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Box {
        Box::new()
    }

    fn clear(&mut self) {
        self.Height = 0;
        self.Width = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Box {
        static instance: Box = Box {
            Height: 0,
            Width: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Box {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Box").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Box {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Box {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.User)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct User {
    // message fields
    // @@protoc_insertion_point(field:grpc.User.UID)
    pub UID: u32,
    // @@protoc_insertion_point(field:grpc.User.GID)
    pub GID: u32,
    // @@protoc_insertion_point(field:grpc.User.AdditionalGids)
    pub AdditionalGids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:grpc.User.Username)
    pub Username: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.User.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a User {
    fn default() -> &'a User {
        <User as ::protobuf::Message>::default_instance()
    }
}

impl User {
    pub fn new() -> User {
        ::std::default::Default::default()
    }

    // uint32 UID = 1;

    pub fn UID(&self) -> u32 {
        self.UID
    }

    pub fn clear_UID(&mut self) {
        self.UID = 0;
    }

    // Param is passed by value, moved
    pub fn set_UID(&mut self, v: u32) {
        self.UID = v;
    }

    // uint32 GID = 2;

    pub fn GID(&self) -> u32 {
        self.GID
    }

    pub fn clear_GID(&mut self) {
        self.GID = 0;
    }

    // Param is passed by value, moved
    pub fn set_GID(&mut self, v: u32) {
        self.GID = v;
    }

    // repeated uint32 AdditionalGids = 3;

    pub fn AdditionalGids(&self) -> &[u32] {
        &self.AdditionalGids
    }

    pub fn clear_AdditionalGids(&mut self) {
        self.AdditionalGids.clear();
    }

    // Param is passed by value, moved
    pub fn set_AdditionalGids(&mut self, v: ::std::vec::Vec<u32>) {
        self.AdditionalGids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_AdditionalGids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.AdditionalGids
    }

    // Take field
    pub fn take_AdditionalGids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.AdditionalGids, ::std::vec::Vec::new())
    }

    // string Username = 4;

    pub fn Username(&self) -> &str {
        &self.Username
    }

    pub fn clear_Username(&mut self) {
        self.Username.clear();
    }

    // Param is passed by value, moved
    pub fn set_Username(&mut self, v: ::std::string::String) {
        self.Username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Username(&mut self) -> &mut ::std::string::String {
        &mut self.Username
    }

    // Take field
    pub fn take_Username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Username, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "UID",
            |m: &User| { &m.UID },
            |m: &mut User| { &mut m.UID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "GID",
            |m: &User| { &m.GID },
            |m: &mut User| { &mut m.GID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "AdditionalGids",
            |m: &User| { &m.AdditionalGids },
            |m: &mut User| { &mut m.AdditionalGids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Username",
            |m: &User| { &m.Username },
            |m: &mut User| { &mut m.Username },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<User>(
            "User",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for User {
    const NAME: &'static str = "User";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.UID = is.read_uint32()?;
                },
                16 => {
                    self.GID = is.read_uint32()?;
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.AdditionalGids)?;
                },
                24 => {
                    self.AdditionalGids.push(is.read_uint32()?);
                },
                34 => {
                    self.Username = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.UID != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.UID);
        }
        if self.GID != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.GID);
        }
        for value in &self.AdditionalGids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        if !self.Username.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.Username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.UID != 0 {
            os.write_uint32(1, self.UID)?;
        }
        if self.GID != 0 {
            os.write_uint32(2, self.GID)?;
        }
        for v in &self.AdditionalGids {
            os.write_uint32(3, *v)?;
        };
        if !self.Username.is_empty() {
            os.write_string(4, &self.Username)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> User {
        User::new()
    }

    fn clear(&mut self) {
        self.UID = 0;
        self.GID = 0;
        self.AdditionalGids.clear();
        self.Username.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static User {
        static instance: User = User {
            UID: 0,
            GID: 0,
            AdditionalGids: ::std::vec::Vec::new(),
            Username: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for User {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("User").unwrap()).clone()
    }
}

impl ::std::fmt::Display for User {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for User {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxCapabilities)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxCapabilities {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxCapabilities.Bounding)
    pub Bounding: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.LinuxCapabilities.Effective)
    pub Effective: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.LinuxCapabilities.Inheritable)
    pub Inheritable: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.LinuxCapabilities.Permitted)
    pub Permitted: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.LinuxCapabilities.Ambient)
    pub Ambient: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxCapabilities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxCapabilities {
    fn default() -> &'a LinuxCapabilities {
        <LinuxCapabilities as ::protobuf::Message>::default_instance()
    }
}

impl LinuxCapabilities {
    pub fn new() -> LinuxCapabilities {
        ::std::default::Default::default()
    }

    // repeated string Bounding = 1;

    pub fn Bounding(&self) -> &[::std::string::String] {
        &self.Bounding
    }

    pub fn clear_Bounding(&mut self) {
        self.Bounding.clear();
    }

    // Param is passed by value, moved
    pub fn set_Bounding(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.Bounding = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Bounding(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.Bounding
    }

    // Take field
    pub fn take_Bounding(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.Bounding, ::std::vec::Vec::new())
    }

    // repeated string Effective = 2;

    pub fn Effective(&self) -> &[::std::string::String] {
        &self.Effective
    }

    pub fn clear_Effective(&mut self) {
        self.Effective.clear();
    }

    // Param is passed by value, moved
    pub fn set_Effective(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.Effective = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Effective(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.Effective
    }

    // Take field
    pub fn take_Effective(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.Effective, ::std::vec::Vec::new())
    }

    // repeated string Inheritable = 3;

    pub fn Inheritable(&self) -> &[::std::string::String] {
        &self.Inheritable
    }

    pub fn clear_Inheritable(&mut self) {
        self.Inheritable.clear();
    }

    // Param is passed by value, moved
    pub fn set_Inheritable(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.Inheritable = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Inheritable(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.Inheritable
    }

    // Take field
    pub fn take_Inheritable(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.Inheritable, ::std::vec::Vec::new())
    }

    // repeated string Permitted = 4;

    pub fn Permitted(&self) -> &[::std::string::String] {
        &self.Permitted
    }

    pub fn clear_Permitted(&mut self) {
        self.Permitted.clear();
    }

    // Param is passed by value, moved
    pub fn set_Permitted(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.Permitted = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Permitted(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.Permitted
    }

    // Take field
    pub fn take_Permitted(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.Permitted, ::std::vec::Vec::new())
    }

    // repeated string Ambient = 5;

    pub fn Ambient(&self) -> &[::std::string::String] {
        &self.Ambient
    }

    pub fn clear_Ambient(&mut self) {
        self.Ambient.clear();
    }

    // Param is passed by value, moved
    pub fn set_Ambient(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.Ambient = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Ambient(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.Ambient
    }

    // Take field
    pub fn take_Ambient(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.Ambient, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Bounding",
            |m: &LinuxCapabilities| { &m.Bounding },
            |m: &mut LinuxCapabilities| { &mut m.Bounding },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Effective",
            |m: &LinuxCapabilities| { &m.Effective },
            |m: &mut LinuxCapabilities| { &mut m.Effective },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Inheritable",
            |m: &LinuxCapabilities| { &m.Inheritable },
            |m: &mut LinuxCapabilities| { &mut m.Inheritable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Permitted",
            |m: &LinuxCapabilities| { &m.Permitted },
            |m: &mut LinuxCapabilities| { &mut m.Permitted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Ambient",
            |m: &LinuxCapabilities| { &m.Ambient },
            |m: &mut LinuxCapabilities| { &mut m.Ambient },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxCapabilities>(
            "LinuxCapabilities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxCapabilities {
    const NAME: &'static str = "LinuxCapabilities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Bounding.push(is.read_string()?);
                },
                18 => {
                    self.Effective.push(is.read_string()?);
                },
                26 => {
                    self.Inheritable.push(is.read_string()?);
                },
                34 => {
                    self.Permitted.push(is.read_string()?);
                },
                42 => {
                    self.Ambient.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.Bounding {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.Effective {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.Inheritable {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.Permitted {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.Ambient {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.Bounding {
            os.write_string(1, &v)?;
        };
        for v in &self.Effective {
            os.write_string(2, &v)?;
        };
        for v in &self.Inheritable {
            os.write_string(3, &v)?;
        };
        for v in &self.Permitted {
            os.write_string(4, &v)?;
        };
        for v in &self.Ambient {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxCapabilities {
        LinuxCapabilities::new()
    }

    fn clear(&mut self) {
        self.Bounding.clear();
        self.Effective.clear();
        self.Inheritable.clear();
        self.Permitted.clear();
        self.Ambient.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxCapabilities {
        static instance: LinuxCapabilities = LinuxCapabilities {
            Bounding: ::std::vec::Vec::new(),
            Effective: ::std::vec::Vec::new(),
            Inheritable: ::std::vec::Vec::new(),
            Permitted: ::std::vec::Vec::new(),
            Ambient: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxCapabilities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxCapabilities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxCapabilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxCapabilities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.POSIXRlimit)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct POSIXRlimit {
    // message fields
    // @@protoc_insertion_point(field:grpc.POSIXRlimit.Type)
    pub Type: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.POSIXRlimit.Hard)
    pub Hard: u64,
    // @@protoc_insertion_point(field:grpc.POSIXRlimit.Soft)
    pub Soft: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.POSIXRlimit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a POSIXRlimit {
    fn default() -> &'a POSIXRlimit {
        <POSIXRlimit as ::protobuf::Message>::default_instance()
    }
}

impl POSIXRlimit {
    pub fn new() -> POSIXRlimit {
        ::std::default::Default::default()
    }

    // string Type = 1;

    pub fn Type(&self) -> &str {
        &self.Type
    }

    pub fn clear_Type(&mut self) {
        self.Type.clear();
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: ::std::string::String) {
        self.Type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Type(&mut self) -> &mut ::std::string::String {
        &mut self.Type
    }

    // Take field
    pub fn take_Type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Type, ::std::string::String::new())
    }

    // uint64 Hard = 2;

    pub fn Hard(&self) -> u64 {
        self.Hard
    }

    pub fn clear_Hard(&mut self) {
        self.Hard = 0;
    }

    // Param is passed by value, moved
    pub fn set_Hard(&mut self, v: u64) {
        self.Hard = v;
    }

    // uint64 Soft = 3;

    pub fn Soft(&self) -> u64 {
        self.Soft
    }

    pub fn clear_Soft(&mut self) {
        self.Soft = 0;
    }

    // Param is passed by value, moved
    pub fn set_Soft(&mut self, v: u64) {
        self.Soft = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Type",
            |m: &POSIXRlimit| { &m.Type },
            |m: &mut POSIXRlimit| { &mut m.Type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Hard",
            |m: &POSIXRlimit| { &m.Hard },
            |m: &mut POSIXRlimit| { &mut m.Hard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Soft",
            |m: &POSIXRlimit| { &m.Soft },
            |m: &mut POSIXRlimit| { &mut m.Soft },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<POSIXRlimit>(
            "POSIXRlimit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for POSIXRlimit {
    const NAME: &'static str = "POSIXRlimit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Type = is.read_string()?;
                },
                16 => {
                    self.Hard = is.read_uint64()?;
                },
                24 => {
                    self.Soft = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Type);
        }
        if self.Hard != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.Hard);
        }
        if self.Soft != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.Soft);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Type.is_empty() {
            os.write_string(1, &self.Type)?;
        }
        if self.Hard != 0 {
            os.write_uint64(2, self.Hard)?;
        }
        if self.Soft != 0 {
            os.write_uint64(3, self.Soft)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> POSIXRlimit {
        POSIXRlimit::new()
    }

    fn clear(&mut self) {
        self.Type.clear();
        self.Hard = 0;
        self.Soft = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static POSIXRlimit {
        static instance: POSIXRlimit = POSIXRlimit {
            Type: ::std::string::String::new(),
            Hard: 0,
            Soft: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for POSIXRlimit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("POSIXRlimit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for POSIXRlimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for POSIXRlimit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.Mount)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct Mount {
    // message fields
    // @@protoc_insertion_point(field:grpc.Mount.destination)
    pub destination: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Mount.source)
    pub source: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Mount.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Mount.options)
    pub options: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.Mount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Mount {
    fn default() -> &'a Mount {
        <Mount as ::protobuf::Message>::default_instance()
    }
}

impl Mount {
    pub fn new() -> Mount {
        ::std::default::Default::default()
    }

    // string destination = 1;

    pub fn destination(&self) -> &str {
        &self.destination
    }

    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: ::std::string::String) {
        self.destination = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut ::std::string::String {
        &mut self.destination
    }

    // Take field
    pub fn take_destination(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination, ::std::string::String::new())
    }

    // string source = 2;

    pub fn source(&self) -> &str {
        &self.source
    }

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        &mut self.source
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source, ::std::string::String::new())
    }

    // string type = 3;

    pub fn type_(&self) -> &str {
        &self.type_
    }

    pub fn clear_type_(&mut self) {
        self.type_.clear();
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        &mut self.type_
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.type_, ::std::string::String::new())
    }

    // repeated string options = 4;

    pub fn options(&self) -> &[::std::string::String] {
        &self.options
    }

    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.options, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "destination",
            |m: &Mount| { &m.destination },
            |m: &mut Mount| { &mut m.destination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source",
            |m: &Mount| { &m.source },
            |m: &mut Mount| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Mount| { &m.type_ },
            |m: &mut Mount| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "options",
            |m: &Mount| { &m.options },
            |m: &mut Mount| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Mount>(
            "Mount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Mount {
    const NAME: &'static str = "Mount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.destination = is.read_string()?;
                },
                18 => {
                    self.source = is.read_string()?;
                },
                26 => {
                    self.type_ = is.read_string()?;
                },
                34 => {
                    self.options.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.destination.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.destination);
        }
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.source);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.type_);
        }
        for value in &self.options {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.destination.is_empty() {
            os.write_string(1, &self.destination)?;
        }
        if !self.source.is_empty() {
            os.write_string(2, &self.source)?;
        }
        if !self.type_.is_empty() {
            os.write_string(3, &self.type_)?;
        }
        for v in &self.options {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Mount {
        Mount::new()
    }

    fn clear(&mut self) {
        self.destination.clear();
        self.source.clear();
        self.type_.clear();
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Mount {
        static instance: Mount = Mount {
            destination: ::std::string::String::new(),
            source: ::std::string::String::new(),
            type_: ::std::string::String::new(),
            options: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Mount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Mount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Mount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.Root)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct Root {
    // message fields
    // @@protoc_insertion_point(field:grpc.Root.Path)
    pub Path: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Root.Readonly)
    pub Readonly: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.Root.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Root {
    fn default() -> &'a Root {
        <Root as ::protobuf::Message>::default_instance()
    }
}

impl Root {
    pub fn new() -> Root {
        ::std::default::Default::default()
    }

    // string Path = 1;

    pub fn Path(&self) -> &str {
        &self.Path
    }

    pub fn clear_Path(&mut self) {
        self.Path.clear();
    }

    // Param is passed by value, moved
    pub fn set_Path(&mut self, v: ::std::string::String) {
        self.Path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Path(&mut self) -> &mut ::std::string::String {
        &mut self.Path
    }

    // Take field
    pub fn take_Path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Path, ::std::string::String::new())
    }

    // bool Readonly = 2;

    pub fn Readonly(&self) -> bool {
        self.Readonly
    }

    pub fn clear_Readonly(&mut self) {
        self.Readonly = false;
    }

    // Param is passed by value, moved
    pub fn set_Readonly(&mut self, v: bool) {
        self.Readonly = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Path",
            |m: &Root| { &m.Path },
            |m: &mut Root| { &mut m.Path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Readonly",
            |m: &Root| { &m.Readonly },
            |m: &mut Root| { &mut m.Readonly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Root>(
            "Root",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Root {
    const NAME: &'static str = "Root";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Path = is.read_string()?;
                },
                16 => {
                    self.Readonly = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Path);
        }
        if self.Readonly != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Path.is_empty() {
            os.write_string(1, &self.Path)?;
        }
        if self.Readonly != false {
            os.write_bool(2, self.Readonly)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Root {
        Root::new()
    }

    fn clear(&mut self) {
        self.Path.clear();
        self.Readonly = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Root {
        static instance: Root = Root {
            Path: ::std::string::String::new(),
            Readonly: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Root {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Root").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Root {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Root {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.Hooks)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct Hooks {
    // message fields
    // @@protoc_insertion_point(field:grpc.Hooks.Prestart)
    pub Prestart: ::std::vec::Vec<Hook>,
    // @@protoc_insertion_point(field:grpc.Hooks.Poststart)
    pub Poststart: ::std::vec::Vec<Hook>,
    // @@protoc_insertion_point(field:grpc.Hooks.Poststop)
    pub Poststop: ::std::vec::Vec<Hook>,
    // @@protoc_insertion_point(field:grpc.Hooks.CreateRuntime)
    pub CreateRuntime: ::std::vec::Vec<Hook>,
    // @@protoc_insertion_point(field:grpc.Hooks.CreateContainer)
    pub CreateContainer: ::std::vec::Vec<Hook>,
    // @@protoc_insertion_point(field:grpc.Hooks.StartContainer)
    pub StartContainer: ::std::vec::Vec<Hook>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.Hooks.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Hooks {
    fn default() -> &'a Hooks {
        <Hooks as ::protobuf::Message>::default_instance()
    }
}

impl Hooks {
    pub fn new() -> Hooks {
        ::std::default::Default::default()
    }

    // repeated .grpc.Hook Prestart = 1;

    pub fn Prestart(&self) -> &[Hook] {
        &self.Prestart
    }

    pub fn clear_Prestart(&mut self) {
        self.Prestart.clear();
    }

    // Param is passed by value, moved
    pub fn set_Prestart(&mut self, v: ::std::vec::Vec<Hook>) {
        self.Prestart = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Prestart(&mut self) -> &mut ::std::vec::Vec<Hook> {
        &mut self.Prestart
    }

    // Take field
    pub fn take_Prestart(&mut self) -> ::std::vec::Vec<Hook> {
        ::std::mem::replace(&mut self.Prestart, ::std::vec::Vec::new())
    }

    // repeated .grpc.Hook Poststart = 2;

    pub fn Poststart(&self) -> &[Hook] {
        &self.Poststart
    }

    pub fn clear_Poststart(&mut self) {
        self.Poststart.clear();
    }

    // Param is passed by value, moved
    pub fn set_Poststart(&mut self, v: ::std::vec::Vec<Hook>) {
        self.Poststart = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Poststart(&mut self) -> &mut ::std::vec::Vec<Hook> {
        &mut self.Poststart
    }

    // Take field
    pub fn take_Poststart(&mut self) -> ::std::vec::Vec<Hook> {
        ::std::mem::replace(&mut self.Poststart, ::std::vec::Vec::new())
    }

    // repeated .grpc.Hook Poststop = 3;

    pub fn Poststop(&self) -> &[Hook] {
        &self.Poststop
    }

    pub fn clear_Poststop(&mut self) {
        self.Poststop.clear();
    }

    // Param is passed by value, moved
    pub fn set_Poststop(&mut self, v: ::std::vec::Vec<Hook>) {
        self.Poststop = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Poststop(&mut self) -> &mut ::std::vec::Vec<Hook> {
        &mut self.Poststop
    }

    // Take field
    pub fn take_Poststop(&mut self) -> ::std::vec::Vec<Hook> {
        ::std::mem::replace(&mut self.Poststop, ::std::vec::Vec::new())
    }

    // repeated .grpc.Hook CreateRuntime = 4;

    pub fn CreateRuntime(&self) -> &[Hook] {
        &self.CreateRuntime
    }

    pub fn clear_CreateRuntime(&mut self) {
        self.CreateRuntime.clear();
    }

    // Param is passed by value, moved
    pub fn set_CreateRuntime(&mut self, v: ::std::vec::Vec<Hook>) {
        self.CreateRuntime = v;
    }

    // Mutable pointer to the field.
    pub fn mut_CreateRuntime(&mut self) -> &mut ::std::vec::Vec<Hook> {
        &mut self.CreateRuntime
    }

    // Take field
    pub fn take_CreateRuntime(&mut self) -> ::std::vec::Vec<Hook> {
        ::std::mem::replace(&mut self.CreateRuntime, ::std::vec::Vec::new())
    }

    // repeated .grpc.Hook CreateContainer = 5;

    pub fn CreateContainer(&self) -> &[Hook] {
        &self.CreateContainer
    }

    pub fn clear_CreateContainer(&mut self) {
        self.CreateContainer.clear();
    }

    // Param is passed by value, moved
    pub fn set_CreateContainer(&mut self, v: ::std::vec::Vec<Hook>) {
        self.CreateContainer = v;
    }

    // Mutable pointer to the field.
    pub fn mut_CreateContainer(&mut self) -> &mut ::std::vec::Vec<Hook> {
        &mut self.CreateContainer
    }

    // Take field
    pub fn take_CreateContainer(&mut self) -> ::std::vec::Vec<Hook> {
        ::std::mem::replace(&mut self.CreateContainer, ::std::vec::Vec::new())
    }

    // repeated .grpc.Hook StartContainer = 6;

    pub fn StartContainer(&self) -> &[Hook] {
        &self.StartContainer
    }

    pub fn clear_StartContainer(&mut self) {
        self.StartContainer.clear();
    }

    // Param is passed by value, moved
    pub fn set_StartContainer(&mut self, v: ::std::vec::Vec<Hook>) {
        self.StartContainer = v;
    }

    // Mutable pointer to the field.
    pub fn mut_StartContainer(&mut self) -> &mut ::std::vec::Vec<Hook> {
        &mut self.StartContainer
    }

    // Take field
    pub fn take_StartContainer(&mut self) -> ::std::vec::Vec<Hook> {
        ::std::mem::replace(&mut self.StartContainer, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Prestart",
            |m: &Hooks| { &m.Prestart },
            |m: &mut Hooks| { &mut m.Prestart },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Poststart",
            |m: &Hooks| { &m.Poststart },
            |m: &mut Hooks| { &mut m.Poststart },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Poststop",
            |m: &Hooks| { &m.Poststop },
            |m: &mut Hooks| { &mut m.Poststop },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "CreateRuntime",
            |m: &Hooks| { &m.CreateRuntime },
            |m: &mut Hooks| { &mut m.CreateRuntime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "CreateContainer",
            |m: &Hooks| { &m.CreateContainer },
            |m: &mut Hooks| { &mut m.CreateContainer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "StartContainer",
            |m: &Hooks| { &m.StartContainer },
            |m: &mut Hooks| { &mut m.StartContainer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Hooks>(
            "Hooks",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Hooks {
    const NAME: &'static str = "Hooks";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Prestart.push(is.read_message()?);
                },
                18 => {
                    self.Poststart.push(is.read_message()?);
                },
                26 => {
                    self.Poststop.push(is.read_message()?);
                },
                34 => {
                    self.CreateRuntime.push(is.read_message()?);
                },
                42 => {
                    self.CreateContainer.push(is.read_message()?);
                },
                50 => {
                    self.StartContainer.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.Prestart {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.Poststart {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.Poststop {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.CreateRuntime {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.CreateContainer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.StartContainer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.Prestart {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.Poststart {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.Poststop {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.CreateRuntime {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.CreateContainer {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.StartContainer {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Hooks {
        Hooks::new()
    }

    fn clear(&mut self) {
        self.Prestart.clear();
        self.Poststart.clear();
        self.Poststop.clear();
        self.CreateRuntime.clear();
        self.CreateContainer.clear();
        self.StartContainer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Hooks {
        static instance: Hooks = Hooks {
            Prestart: ::std::vec::Vec::new(),
            Poststart: ::std::vec::Vec::new(),
            Poststop: ::std::vec::Vec::new(),
            CreateRuntime: ::std::vec::Vec::new(),
            CreateContainer: ::std::vec::Vec::new(),
            StartContainer: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Hooks {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Hooks").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Hooks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hooks {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.Hook)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct Hook {
    // message fields
    // @@protoc_insertion_point(field:grpc.Hook.Path)
    pub Path: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Hook.Args)
    pub Args: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.Hook.Env)
    pub Env: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.Hook.Timeout)
    pub Timeout: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.Hook.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Hook {
    fn default() -> &'a Hook {
        <Hook as ::protobuf::Message>::default_instance()
    }
}

impl Hook {
    pub fn new() -> Hook {
        ::std::default::Default::default()
    }

    // string Path = 1;

    pub fn Path(&self) -> &str {
        &self.Path
    }

    pub fn clear_Path(&mut self) {
        self.Path.clear();
    }

    // Param is passed by value, moved
    pub fn set_Path(&mut self, v: ::std::string::String) {
        self.Path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Path(&mut self) -> &mut ::std::string::String {
        &mut self.Path
    }

    // Take field
    pub fn take_Path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Path, ::std::string::String::new())
    }

    // repeated string Args = 2;

    pub fn Args(&self) -> &[::std::string::String] {
        &self.Args
    }

    pub fn clear_Args(&mut self) {
        self.Args.clear();
    }

    // Param is passed by value, moved
    pub fn set_Args(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.Args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Args(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.Args
    }

    // Take field
    pub fn take_Args(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.Args, ::std::vec::Vec::new())
    }

    // repeated string Env = 3;

    pub fn Env(&self) -> &[::std::string::String] {
        &self.Env
    }

    pub fn clear_Env(&mut self) {
        self.Env.clear();
    }

    // Param is passed by value, moved
    pub fn set_Env(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.Env = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Env(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.Env
    }

    // Take field
    pub fn take_Env(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.Env, ::std::vec::Vec::new())
    }

    // int64 Timeout = 4;

    pub fn Timeout(&self) -> i64 {
        self.Timeout
    }

    pub fn clear_Timeout(&mut self) {
        self.Timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_Timeout(&mut self, v: i64) {
        self.Timeout = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Path",
            |m: &Hook| { &m.Path },
            |m: &mut Hook| { &mut m.Path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Args",
            |m: &Hook| { &m.Args },
            |m: &mut Hook| { &mut m.Args },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Env",
            |m: &Hook| { &m.Env },
            |m: &mut Hook| { &mut m.Env },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Timeout",
            |m: &Hook| { &m.Timeout },
            |m: &mut Hook| { &mut m.Timeout },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Hook>(
            "Hook",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Hook {
    const NAME: &'static str = "Hook";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Path = is.read_string()?;
                },
                18 => {
                    self.Args.push(is.read_string()?);
                },
                26 => {
                    self.Env.push(is.read_string()?);
                },
                32 => {
                    self.Timeout = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Path);
        }
        for value in &self.Args {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.Env {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.Timeout != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.Timeout);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Path.is_empty() {
            os.write_string(1, &self.Path)?;
        }
        for v in &self.Args {
            os.write_string(2, &v)?;
        };
        for v in &self.Env {
            os.write_string(3, &v)?;
        };
        if self.Timeout != 0 {
            os.write_int64(4, self.Timeout)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Hook {
        Hook::new()
    }

    fn clear(&mut self) {
        self.Path.clear();
        self.Args.clear();
        self.Env.clear();
        self.Timeout = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Hook {
        static instance: Hook = Hook {
            Path: ::std::string::String::new(),
            Args: ::std::vec::Vec::new(),
            Env: ::std::vec::Vec::new(),
            Timeout: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Hook {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Hook").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Hook {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hook {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.Linux)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct Linux {
    // message fields
    // @@protoc_insertion_point(field:grpc.Linux.UIDMappings)
    pub UIDMappings: ::std::vec::Vec<LinuxIDMapping>,
    // @@protoc_insertion_point(field:grpc.Linux.GIDMappings)
    pub GIDMappings: ::std::vec::Vec<LinuxIDMapping>,
    // @@protoc_insertion_point(field:grpc.Linux.Sysctl)
    pub Sysctl: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.Linux.Resources)
    pub Resources: ::protobuf::MessageField<LinuxResources>,
    // @@protoc_insertion_point(field:grpc.Linux.CgroupsPath)
    pub CgroupsPath: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Linux.Namespaces)
    pub Namespaces: ::std::vec::Vec<LinuxNamespace>,
    // @@protoc_insertion_point(field:grpc.Linux.Devices)
    pub Devices: ::std::vec::Vec<LinuxDevice>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.Linux.Seccomp)
    pub Seccomp: ::protobuf::MessageField<LinuxSeccomp>,
    // @@protoc_insertion_point(field:grpc.Linux.RootfsPropagation)
    pub RootfsPropagation: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.Linux.MaskedPaths)
    pub MaskedPaths: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.Linux.ReadonlyPaths)
    pub ReadonlyPaths: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.Linux.MountLabel)
    pub MountLabel: ::std::string::String,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.Linux.IntelRdt)
    pub IntelRdt: ::protobuf::MessageField<LinuxIntelRdt>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.Linux.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Linux {
    fn default() -> &'a Linux {
        <Linux as ::protobuf::Message>::default_instance()
    }
}

impl Linux {
    pub fn new() -> Linux {
        ::std::default::Default::default()
    }

    // repeated .grpc.LinuxIDMapping UIDMappings = 1;

    pub fn UIDMappings(&self) -> &[LinuxIDMapping] {
        &self.UIDMappings
    }

    pub fn clear_UIDMappings(&mut self) {
        self.UIDMappings.clear();
    }

    // Param is passed by value, moved
    pub fn set_UIDMappings(&mut self, v: ::std::vec::Vec<LinuxIDMapping>) {
        self.UIDMappings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_UIDMappings(&mut self) -> &mut ::std::vec::Vec<LinuxIDMapping> {
        &mut self.UIDMappings
    }

    // Take field
    pub fn take_UIDMappings(&mut self) -> ::std::vec::Vec<LinuxIDMapping> {
        ::std::mem::replace(&mut self.UIDMappings, ::std::vec::Vec::new())
    }

    // repeated .grpc.LinuxIDMapping GIDMappings = 2;

    pub fn GIDMappings(&self) -> &[LinuxIDMapping] {
        &self.GIDMappings
    }

    pub fn clear_GIDMappings(&mut self) {
        self.GIDMappings.clear();
    }

    // Param is passed by value, moved
    pub fn set_GIDMappings(&mut self, v: ::std::vec::Vec<LinuxIDMapping>) {
        self.GIDMappings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_GIDMappings(&mut self) -> &mut ::std::vec::Vec<LinuxIDMapping> {
        &mut self.GIDMappings
    }

    // Take field
    pub fn take_GIDMappings(&mut self) -> ::std::vec::Vec<LinuxIDMapping> {
        ::std::mem::replace(&mut self.GIDMappings, ::std::vec::Vec::new())
    }

    // repeated .grpc.Linux.SysctlEntry Sysctl = 3;

    pub fn Sysctl(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.Sysctl
    }

    pub fn clear_Sysctl(&mut self) {
        self.Sysctl.clear();
    }

    // Param is passed by value, moved
    pub fn set_Sysctl(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.Sysctl = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Sysctl(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.Sysctl
    }

    // Take field
    pub fn take_Sysctl(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.Sysctl, ::std::collections::HashMap::new())
    }

    // .grpc.LinuxResources Resources = 4;

    pub fn Resources(&self) -> &LinuxResources {
        self.Resources.as_ref().unwrap_or_else(|| <LinuxResources as ::protobuf::Message>::default_instance())
    }

    pub fn clear_Resources(&mut self) {
        self.Resources.clear();
    }

    pub fn has_Resources(&self) -> bool {
        self.Resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Resources(&mut self, v: LinuxResources) {
        self.Resources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Resources(&mut self) -> &mut LinuxResources {
        self.Resources.mut_or_insert_default()
    }

    // Take field
    pub fn take_Resources(&mut self) -> LinuxResources {
        self.Resources.take().unwrap_or_else(|| LinuxResources::new())
    }

    // string CgroupsPath = 5;

    pub fn CgroupsPath(&self) -> &str {
        &self.CgroupsPath
    }

    pub fn clear_CgroupsPath(&mut self) {
        self.CgroupsPath.clear();
    }

    // Param is passed by value, moved
    pub fn set_CgroupsPath(&mut self, v: ::std::string::String) {
        self.CgroupsPath = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CgroupsPath(&mut self) -> &mut ::std::string::String {
        &mut self.CgroupsPath
    }

    // Take field
    pub fn take_CgroupsPath(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.CgroupsPath, ::std::string::String::new())
    }

    // repeated .grpc.LinuxNamespace Namespaces = 6;

    pub fn Namespaces(&self) -> &[LinuxNamespace] {
        &self.Namespaces
    }

    pub fn clear_Namespaces(&mut self) {
        self.Namespaces.clear();
    }

    // Param is passed by value, moved
    pub fn set_Namespaces(&mut self, v: ::std::vec::Vec<LinuxNamespace>) {
        self.Namespaces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Namespaces(&mut self) -> &mut ::std::vec::Vec<LinuxNamespace> {
        &mut self.Namespaces
    }

    // Take field
    pub fn take_Namespaces(&mut self) -> ::std::vec::Vec<LinuxNamespace> {
        ::std::mem::replace(&mut self.Namespaces, ::std::vec::Vec::new())
    }

    // repeated .grpc.LinuxDevice Devices = 7;

    pub fn Devices(&self) -> &[LinuxDevice] {
        &self.Devices
    }

    pub fn clear_Devices(&mut self) {
        self.Devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_Devices(&mut self, v: ::std::vec::Vec<LinuxDevice>) {
        self.Devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Devices(&mut self) -> &mut ::std::vec::Vec<LinuxDevice> {
        &mut self.Devices
    }

    // Take field
    pub fn take_Devices(&mut self) -> ::std::vec::Vec<LinuxDevice> {
        ::std::mem::replace(&mut self.Devices, ::std::vec::Vec::new())
    }

    // .grpc.LinuxSeccomp Seccomp = 8;

    pub fn Seccomp(&self) -> &LinuxSeccomp {
        self.Seccomp.as_ref().unwrap_or_else(|| <LinuxSeccomp as ::protobuf::Message>::default_instance())
    }

    pub fn clear_Seccomp(&mut self) {
        self.Seccomp.clear();
    }

    pub fn has_Seccomp(&self) -> bool {
        self.Seccomp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Seccomp(&mut self, v: LinuxSeccomp) {
        self.Seccomp = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Seccomp(&mut self) -> &mut LinuxSeccomp {
        self.Seccomp.mut_or_insert_default()
    }

    // Take field
    pub fn take_Seccomp(&mut self) -> LinuxSeccomp {
        self.Seccomp.take().unwrap_or_else(|| LinuxSeccomp::new())
    }

    // string RootfsPropagation = 9;

    pub fn RootfsPropagation(&self) -> &str {
        &self.RootfsPropagation
    }

    pub fn clear_RootfsPropagation(&mut self) {
        self.RootfsPropagation.clear();
    }

    // Param is passed by value, moved
    pub fn set_RootfsPropagation(&mut self, v: ::std::string::String) {
        self.RootfsPropagation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_RootfsPropagation(&mut self) -> &mut ::std::string::String {
        &mut self.RootfsPropagation
    }

    // Take field
    pub fn take_RootfsPropagation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.RootfsPropagation, ::std::string::String::new())
    }

    // repeated string MaskedPaths = 10;

    pub fn MaskedPaths(&self) -> &[::std::string::String] {
        &self.MaskedPaths
    }

    pub fn clear_MaskedPaths(&mut self) {
        self.MaskedPaths.clear();
    }

    // Param is passed by value, moved
    pub fn set_MaskedPaths(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.MaskedPaths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_MaskedPaths(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.MaskedPaths
    }

    // Take field
    pub fn take_MaskedPaths(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.MaskedPaths, ::std::vec::Vec::new())
    }

    // repeated string ReadonlyPaths = 11;

    pub fn ReadonlyPaths(&self) -> &[::std::string::String] {
        &self.ReadonlyPaths
    }

    pub fn clear_ReadonlyPaths(&mut self) {
        self.ReadonlyPaths.clear();
    }

    // Param is passed by value, moved
    pub fn set_ReadonlyPaths(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.ReadonlyPaths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ReadonlyPaths(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.ReadonlyPaths
    }

    // Take field
    pub fn take_ReadonlyPaths(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.ReadonlyPaths, ::std::vec::Vec::new())
    }

    // string MountLabel = 12;

    pub fn MountLabel(&self) -> &str {
        &self.MountLabel
    }

    pub fn clear_MountLabel(&mut self) {
        self.MountLabel.clear();
    }

    // Param is passed by value, moved
    pub fn set_MountLabel(&mut self, v: ::std::string::String) {
        self.MountLabel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_MountLabel(&mut self) -> &mut ::std::string::String {
        &mut self.MountLabel
    }

    // Take field
    pub fn take_MountLabel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.MountLabel, ::std::string::String::new())
    }

    // .grpc.LinuxIntelRdt IntelRdt = 13;

    pub fn IntelRdt(&self) -> &LinuxIntelRdt {
        self.IntelRdt.as_ref().unwrap_or_else(|| <LinuxIntelRdt as ::protobuf::Message>::default_instance())
    }

    pub fn clear_IntelRdt(&mut self) {
        self.IntelRdt.clear();
    }

    pub fn has_IntelRdt(&self) -> bool {
        self.IntelRdt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_IntelRdt(&mut self, v: LinuxIntelRdt) {
        self.IntelRdt = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_IntelRdt(&mut self) -> &mut LinuxIntelRdt {
        self.IntelRdt.mut_or_insert_default()
    }

    // Take field
    pub fn take_IntelRdt(&mut self) -> LinuxIntelRdt {
        self.IntelRdt.take().unwrap_or_else(|| LinuxIntelRdt::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "UIDMappings",
            |m: &Linux| { &m.UIDMappings },
            |m: &mut Linux| { &mut m.UIDMappings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "GIDMappings",
            |m: &Linux| { &m.GIDMappings },
            |m: &mut Linux| { &mut m.GIDMappings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "Sysctl",
            |m: &Linux| { &m.Sysctl },
            |m: &mut Linux| { &mut m.Sysctl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinuxResources>(
            "Resources",
            |m: &Linux| { &m.Resources },
            |m: &mut Linux| { &mut m.Resources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CgroupsPath",
            |m: &Linux| { &m.CgroupsPath },
            |m: &mut Linux| { &mut m.CgroupsPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Namespaces",
            |m: &Linux| { &m.Namespaces },
            |m: &mut Linux| { &mut m.Namespaces },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Devices",
            |m: &Linux| { &m.Devices },
            |m: &mut Linux| { &mut m.Devices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinuxSeccomp>(
            "Seccomp",
            |m: &Linux| { &m.Seccomp },
            |m: &mut Linux| { &mut m.Seccomp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "RootfsPropagation",
            |m: &Linux| { &m.RootfsPropagation },
            |m: &mut Linux| { &mut m.RootfsPropagation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "MaskedPaths",
            |m: &Linux| { &m.MaskedPaths },
            |m: &mut Linux| { &mut m.MaskedPaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ReadonlyPaths",
            |m: &Linux| { &m.ReadonlyPaths },
            |m: &mut Linux| { &mut m.ReadonlyPaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MountLabel",
            |m: &Linux| { &m.MountLabel },
            |m: &mut Linux| { &mut m.MountLabel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinuxIntelRdt>(
            "IntelRdt",
            |m: &Linux| { &m.IntelRdt },
            |m: &mut Linux| { &mut m.IntelRdt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Linux>(
            "Linux",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Linux {
    const NAME: &'static str = "Linux";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.UIDMappings.push(is.read_message()?);
                },
                18 => {
                    self.GIDMappings.push(is.read_message()?);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.Sysctl.insert(key, value);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Resources)?;
                },
                42 => {
                    self.CgroupsPath = is.read_string()?;
                },
                50 => {
                    self.Namespaces.push(is.read_message()?);
                },
                58 => {
                    self.Devices.push(is.read_message()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Seccomp)?;
                },
                74 => {
                    self.RootfsPropagation = is.read_string()?;
                },
                82 => {
                    self.MaskedPaths.push(is.read_string()?);
                },
                90 => {
                    self.ReadonlyPaths.push(is.read_string()?);
                },
                98 => {
                    self.MountLabel = is.read_string()?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.IntelRdt)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.UIDMappings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.GIDMappings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for (k, v) in &self.Sysctl {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.Resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.CgroupsPath.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.CgroupsPath);
        }
        for value in &self.Namespaces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.Devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.Seccomp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.RootfsPropagation.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.RootfsPropagation);
        }
        for value in &self.MaskedPaths {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.ReadonlyPaths {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if !self.MountLabel.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.MountLabel);
        }
        if let Some(v) = self.IntelRdt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.UIDMappings {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.GIDMappings {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.Sysctl {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.Resources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if !self.CgroupsPath.is_empty() {
            os.write_string(5, &self.CgroupsPath)?;
        }
        for v in &self.Namespaces {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.Devices {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.Seccomp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if !self.RootfsPropagation.is_empty() {
            os.write_string(9, &self.RootfsPropagation)?;
        }
        for v in &self.MaskedPaths {
            os.write_string(10, &v)?;
        };
        for v in &self.ReadonlyPaths {
            os.write_string(11, &v)?;
        };
        if !self.MountLabel.is_empty() {
            os.write_string(12, &self.MountLabel)?;
        }
        if let Some(v) = self.IntelRdt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Linux {
        Linux::new()
    }

    fn clear(&mut self) {
        self.UIDMappings.clear();
        self.GIDMappings.clear();
        self.Sysctl.clear();
        self.Resources.clear();
        self.CgroupsPath.clear();
        self.Namespaces.clear();
        self.Devices.clear();
        self.Seccomp.clear();
        self.RootfsPropagation.clear();
        self.MaskedPaths.clear();
        self.ReadonlyPaths.clear();
        self.MountLabel.clear();
        self.IntelRdt.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Linux {
        static instance: ::protobuf::rt::Lazy<Linux> = ::protobuf::rt::Lazy::new();
        instance.get(Linux::new)
    }
}

impl ::protobuf::MessageFull for Linux {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Linux").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Linux {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Linux {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.Windows)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct Windows {
    // message fields
    // @@protoc_insertion_point(field:grpc.Windows.dummy)
    pub dummy: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.Windows.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Windows {
    fn default() -> &'a Windows {
        <Windows as ::protobuf::Message>::default_instance()
    }
}

impl Windows {
    pub fn new() -> Windows {
        ::std::default::Default::default()
    }

    // string dummy = 1;

    pub fn dummy(&self) -> &str {
        &self.dummy
    }

    pub fn clear_dummy(&mut self) {
        self.dummy.clear();
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: ::std::string::String) {
        self.dummy = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dummy(&mut self) -> &mut ::std::string::String {
        &mut self.dummy
    }

    // Take field
    pub fn take_dummy(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dummy, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dummy",
            |m: &Windows| { &m.dummy },
            |m: &mut Windows| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Windows>(
            "Windows",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Windows {
    const NAME: &'static str = "Windows";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dummy = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.dummy.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dummy);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.dummy.is_empty() {
            os.write_string(1, &self.dummy)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Windows {
        Windows::new()
    }

    fn clear(&mut self) {
        self.dummy.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Windows {
        static instance: Windows = Windows {
            dummy: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Windows {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Windows").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Windows {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Windows {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.Solaris)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct Solaris {
    // message fields
    // @@protoc_insertion_point(field:grpc.Solaris.dummy)
    pub dummy: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.Solaris.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Solaris {
    fn default() -> &'a Solaris {
        <Solaris as ::protobuf::Message>::default_instance()
    }
}

impl Solaris {
    pub fn new() -> Solaris {
        ::std::default::Default::default()
    }

    // string dummy = 1;

    pub fn dummy(&self) -> &str {
        &self.dummy
    }

    pub fn clear_dummy(&mut self) {
        self.dummy.clear();
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: ::std::string::String) {
        self.dummy = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dummy(&mut self) -> &mut ::std::string::String {
        &mut self.dummy
    }

    // Take field
    pub fn take_dummy(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dummy, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dummy",
            |m: &Solaris| { &m.dummy },
            |m: &mut Solaris| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Solaris>(
            "Solaris",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Solaris {
    const NAME: &'static str = "Solaris";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dummy = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.dummy.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dummy);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.dummy.is_empty() {
            os.write_string(1, &self.dummy)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Solaris {
        Solaris::new()
    }

    fn clear(&mut self) {
        self.dummy.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Solaris {
        static instance: Solaris = Solaris {
            dummy: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Solaris {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Solaris").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Solaris {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Solaris {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxIDMapping)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxIDMapping {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxIDMapping.HostID)
    pub HostID: u32,
    // @@protoc_insertion_point(field:grpc.LinuxIDMapping.ContainerID)
    pub ContainerID: u32,
    // @@protoc_insertion_point(field:grpc.LinuxIDMapping.Size)
    pub Size: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxIDMapping.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxIDMapping {
    fn default() -> &'a LinuxIDMapping {
        <LinuxIDMapping as ::protobuf::Message>::default_instance()
    }
}

impl LinuxIDMapping {
    pub fn new() -> LinuxIDMapping {
        ::std::default::Default::default()
    }

    // uint32 HostID = 1;

    pub fn HostID(&self) -> u32 {
        self.HostID
    }

    pub fn clear_HostID(&mut self) {
        self.HostID = 0;
    }

    // Param is passed by value, moved
    pub fn set_HostID(&mut self, v: u32) {
        self.HostID = v;
    }

    // uint32 ContainerID = 2;

    pub fn ContainerID(&self) -> u32 {
        self.ContainerID
    }

    pub fn clear_ContainerID(&mut self) {
        self.ContainerID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ContainerID(&mut self, v: u32) {
        self.ContainerID = v;
    }

    // uint32 Size = 3;

    pub fn Size(&self) -> u32 {
        self.Size
    }

    pub fn clear_Size(&mut self) {
        self.Size = 0;
    }

    // Param is passed by value, moved
    pub fn set_Size(&mut self, v: u32) {
        self.Size = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HostID",
            |m: &LinuxIDMapping| { &m.HostID },
            |m: &mut LinuxIDMapping| { &mut m.HostID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ContainerID",
            |m: &LinuxIDMapping| { &m.ContainerID },
            |m: &mut LinuxIDMapping| { &mut m.ContainerID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Size",
            |m: &LinuxIDMapping| { &m.Size },
            |m: &mut LinuxIDMapping| { &mut m.Size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxIDMapping>(
            "LinuxIDMapping",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxIDMapping {
    const NAME: &'static str = "LinuxIDMapping";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.HostID = is.read_uint32()?;
                },
                16 => {
                    self.ContainerID = is.read_uint32()?;
                },
                24 => {
                    self.Size = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.HostID != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.HostID);
        }
        if self.ContainerID != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.ContainerID);
        }
        if self.Size != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.Size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.HostID != 0 {
            os.write_uint32(1, self.HostID)?;
        }
        if self.ContainerID != 0 {
            os.write_uint32(2, self.ContainerID)?;
        }
        if self.Size != 0 {
            os.write_uint32(3, self.Size)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxIDMapping {
        LinuxIDMapping::new()
    }

    fn clear(&mut self) {
        self.HostID = 0;
        self.ContainerID = 0;
        self.Size = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxIDMapping {
        static instance: LinuxIDMapping = LinuxIDMapping {
            HostID: 0,
            ContainerID: 0,
            Size: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxIDMapping {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxIDMapping").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxIDMapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxIDMapping {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxNamespace)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxNamespace {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxNamespace.Type)
    pub Type: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.LinuxNamespace.Path)
    pub Path: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxNamespace.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxNamespace {
    fn default() -> &'a LinuxNamespace {
        <LinuxNamespace as ::protobuf::Message>::default_instance()
    }
}

impl LinuxNamespace {
    pub fn new() -> LinuxNamespace {
        ::std::default::Default::default()
    }

    // string Type = 1;

    pub fn Type(&self) -> &str {
        &self.Type
    }

    pub fn clear_Type(&mut self) {
        self.Type.clear();
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: ::std::string::String) {
        self.Type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Type(&mut self) -> &mut ::std::string::String {
        &mut self.Type
    }

    // Take field
    pub fn take_Type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Type, ::std::string::String::new())
    }

    // string Path = 2;

    pub fn Path(&self) -> &str {
        &self.Path
    }

    pub fn clear_Path(&mut self) {
        self.Path.clear();
    }

    // Param is passed by value, moved
    pub fn set_Path(&mut self, v: ::std::string::String) {
        self.Path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Path(&mut self) -> &mut ::std::string::String {
        &mut self.Path
    }

    // Take field
    pub fn take_Path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Path, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Type",
            |m: &LinuxNamespace| { &m.Type },
            |m: &mut LinuxNamespace| { &mut m.Type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Path",
            |m: &LinuxNamespace| { &m.Path },
            |m: &mut LinuxNamespace| { &mut m.Path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxNamespace>(
            "LinuxNamespace",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxNamespace {
    const NAME: &'static str = "LinuxNamespace";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Type = is.read_string()?;
                },
                18 => {
                    self.Path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Type);
        }
        if !self.Path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Type.is_empty() {
            os.write_string(1, &self.Type)?;
        }
        if !self.Path.is_empty() {
            os.write_string(2, &self.Path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxNamespace {
        LinuxNamespace::new()
    }

    fn clear(&mut self) {
        self.Type.clear();
        self.Path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxNamespace {
        static instance: LinuxNamespace = LinuxNamespace {
            Type: ::std::string::String::new(),
            Path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxNamespace {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxNamespace").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxNamespace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxNamespace {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxDevice)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxDevice {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxDevice.Path)
    pub Path: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.LinuxDevice.Type)
    pub Type: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.LinuxDevice.Major)
    pub Major: i64,
    // @@protoc_insertion_point(field:grpc.LinuxDevice.Minor)
    pub Minor: i64,
    // @@protoc_insertion_point(field:grpc.LinuxDevice.FileMode)
    pub FileMode: u32,
    // @@protoc_insertion_point(field:grpc.LinuxDevice.UID)
    pub UID: u32,
    // @@protoc_insertion_point(field:grpc.LinuxDevice.GID)
    pub GID: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxDevice {
    fn default() -> &'a LinuxDevice {
        <LinuxDevice as ::protobuf::Message>::default_instance()
    }
}

impl LinuxDevice {
    pub fn new() -> LinuxDevice {
        ::std::default::Default::default()
    }

    // string Path = 1;

    pub fn Path(&self) -> &str {
        &self.Path
    }

    pub fn clear_Path(&mut self) {
        self.Path.clear();
    }

    // Param is passed by value, moved
    pub fn set_Path(&mut self, v: ::std::string::String) {
        self.Path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Path(&mut self) -> &mut ::std::string::String {
        &mut self.Path
    }

    // Take field
    pub fn take_Path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Path, ::std::string::String::new())
    }

    // string Type = 2;

    pub fn Type(&self) -> &str {
        &self.Type
    }

    pub fn clear_Type(&mut self) {
        self.Type.clear();
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: ::std::string::String) {
        self.Type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Type(&mut self) -> &mut ::std::string::String {
        &mut self.Type
    }

    // Take field
    pub fn take_Type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Type, ::std::string::String::new())
    }

    // int64 Major = 3;

    pub fn Major(&self) -> i64 {
        self.Major
    }

    pub fn clear_Major(&mut self) {
        self.Major = 0;
    }

    // Param is passed by value, moved
    pub fn set_Major(&mut self, v: i64) {
        self.Major = v;
    }

    // int64 Minor = 4;

    pub fn Minor(&self) -> i64 {
        self.Minor
    }

    pub fn clear_Minor(&mut self) {
        self.Minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_Minor(&mut self, v: i64) {
        self.Minor = v;
    }

    // uint32 FileMode = 5;

    pub fn FileMode(&self) -> u32 {
        self.FileMode
    }

    pub fn clear_FileMode(&mut self) {
        self.FileMode = 0;
    }

    // Param is passed by value, moved
    pub fn set_FileMode(&mut self, v: u32) {
        self.FileMode = v;
    }

    // uint32 UID = 6;

    pub fn UID(&self) -> u32 {
        self.UID
    }

    pub fn clear_UID(&mut self) {
        self.UID = 0;
    }

    // Param is passed by value, moved
    pub fn set_UID(&mut self, v: u32) {
        self.UID = v;
    }

    // uint32 GID = 7;

    pub fn GID(&self) -> u32 {
        self.GID
    }

    pub fn clear_GID(&mut self) {
        self.GID = 0;
    }

    // Param is passed by value, moved
    pub fn set_GID(&mut self, v: u32) {
        self.GID = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Path",
            |m: &LinuxDevice| { &m.Path },
            |m: &mut LinuxDevice| { &mut m.Path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Type",
            |m: &LinuxDevice| { &m.Type },
            |m: &mut LinuxDevice| { &mut m.Type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Major",
            |m: &LinuxDevice| { &m.Major },
            |m: &mut LinuxDevice| { &mut m.Major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Minor",
            |m: &LinuxDevice| { &m.Minor },
            |m: &mut LinuxDevice| { &mut m.Minor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "FileMode",
            |m: &LinuxDevice| { &m.FileMode },
            |m: &mut LinuxDevice| { &mut m.FileMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "UID",
            |m: &LinuxDevice| { &m.UID },
            |m: &mut LinuxDevice| { &mut m.UID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "GID",
            |m: &LinuxDevice| { &m.GID },
            |m: &mut LinuxDevice| { &mut m.GID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxDevice>(
            "LinuxDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxDevice {
    const NAME: &'static str = "LinuxDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Path = is.read_string()?;
                },
                18 => {
                    self.Type = is.read_string()?;
                },
                24 => {
                    self.Major = is.read_int64()?;
                },
                32 => {
                    self.Minor = is.read_int64()?;
                },
                40 => {
                    self.FileMode = is.read_uint32()?;
                },
                48 => {
                    self.UID = is.read_uint32()?;
                },
                56 => {
                    self.GID = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Path);
        }
        if !self.Type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Type);
        }
        if self.Major != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.Major);
        }
        if self.Minor != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.Minor);
        }
        if self.FileMode != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.FileMode);
        }
        if self.UID != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.UID);
        }
        if self.GID != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.GID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Path.is_empty() {
            os.write_string(1, &self.Path)?;
        }
        if !self.Type.is_empty() {
            os.write_string(2, &self.Type)?;
        }
        if self.Major != 0 {
            os.write_int64(3, self.Major)?;
        }
        if self.Minor != 0 {
            os.write_int64(4, self.Minor)?;
        }
        if self.FileMode != 0 {
            os.write_uint32(5, self.FileMode)?;
        }
        if self.UID != 0 {
            os.write_uint32(6, self.UID)?;
        }
        if self.GID != 0 {
            os.write_uint32(7, self.GID)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxDevice {
        LinuxDevice::new()
    }

    fn clear(&mut self) {
        self.Path.clear();
        self.Type.clear();
        self.Major = 0;
        self.Minor = 0;
        self.FileMode = 0;
        self.UID = 0;
        self.GID = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxDevice {
        static instance: LinuxDevice = LinuxDevice {
            Path: ::std::string::String::new(),
            Type: ::std::string::String::new(),
            Major: 0,
            Minor: 0,
            FileMode: 0,
            UID: 0,
            GID: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxResources)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxResources {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxResources.Devices)
    pub Devices: ::std::vec::Vec<LinuxDeviceCgroup>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.LinuxResources.Memory)
    pub Memory: ::protobuf::MessageField<LinuxMemory>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.LinuxResources.CPU)
    pub CPU: ::protobuf::MessageField<LinuxCPU>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.LinuxResources.Pids)
    pub Pids: ::protobuf::MessageField<LinuxPids>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.LinuxResources.BlockIO)
    pub BlockIO: ::protobuf::MessageField<LinuxBlockIO>,
    // @@protoc_insertion_point(field:grpc.LinuxResources.HugepageLimits)
    pub HugepageLimits: ::std::vec::Vec<LinuxHugepageLimit>,
    #[cfg_attr(feature = "with-serde", serde(serialize_with = "crate::serialize_message_field", deserialize_with = "crate::deserialize_message_field"))]
    // @@protoc_insertion_point(field:grpc.LinuxResources.Network)
    pub Network: ::protobuf::MessageField<LinuxNetwork>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxResources.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxResources {
    fn default() -> &'a LinuxResources {
        <LinuxResources as ::protobuf::Message>::default_instance()
    }
}

impl LinuxResources {
    pub fn new() -> LinuxResources {
        ::std::default::Default::default()
    }

    // repeated .grpc.LinuxDeviceCgroup Devices = 1;

    pub fn Devices(&self) -> &[LinuxDeviceCgroup] {
        &self.Devices
    }

    pub fn clear_Devices(&mut self) {
        self.Devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_Devices(&mut self, v: ::std::vec::Vec<LinuxDeviceCgroup>) {
        self.Devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Devices(&mut self) -> &mut ::std::vec::Vec<LinuxDeviceCgroup> {
        &mut self.Devices
    }

    // Take field
    pub fn take_Devices(&mut self) -> ::std::vec::Vec<LinuxDeviceCgroup> {
        ::std::mem::replace(&mut self.Devices, ::std::vec::Vec::new())
    }

    // .grpc.LinuxMemory Memory = 2;

    pub fn Memory(&self) -> &LinuxMemory {
        self.Memory.as_ref().unwrap_or_else(|| <LinuxMemory as ::protobuf::Message>::default_instance())
    }

    pub fn clear_Memory(&mut self) {
        self.Memory.clear();
    }

    pub fn has_Memory(&self) -> bool {
        self.Memory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Memory(&mut self, v: LinuxMemory) {
        self.Memory = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Memory(&mut self) -> &mut LinuxMemory {
        self.Memory.mut_or_insert_default()
    }

    // Take field
    pub fn take_Memory(&mut self) -> LinuxMemory {
        self.Memory.take().unwrap_or_else(|| LinuxMemory::new())
    }

    // .grpc.LinuxCPU CPU = 3;

    pub fn CPU(&self) -> &LinuxCPU {
        self.CPU.as_ref().unwrap_or_else(|| <LinuxCPU as ::protobuf::Message>::default_instance())
    }

    pub fn clear_CPU(&mut self) {
        self.CPU.clear();
    }

    pub fn has_CPU(&self) -> bool {
        self.CPU.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CPU(&mut self, v: LinuxCPU) {
        self.CPU = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CPU(&mut self) -> &mut LinuxCPU {
        self.CPU.mut_or_insert_default()
    }

    // Take field
    pub fn take_CPU(&mut self) -> LinuxCPU {
        self.CPU.take().unwrap_or_else(|| LinuxCPU::new())
    }

    // .grpc.LinuxPids Pids = 4;

    pub fn Pids(&self) -> &LinuxPids {
        self.Pids.as_ref().unwrap_or_else(|| <LinuxPids as ::protobuf::Message>::default_instance())
    }

    pub fn clear_Pids(&mut self) {
        self.Pids.clear();
    }

    pub fn has_Pids(&self) -> bool {
        self.Pids.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Pids(&mut self, v: LinuxPids) {
        self.Pids = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Pids(&mut self) -> &mut LinuxPids {
        self.Pids.mut_or_insert_default()
    }

    // Take field
    pub fn take_Pids(&mut self) -> LinuxPids {
        self.Pids.take().unwrap_or_else(|| LinuxPids::new())
    }

    // .grpc.LinuxBlockIO BlockIO = 5;

    pub fn BlockIO(&self) -> &LinuxBlockIO {
        self.BlockIO.as_ref().unwrap_or_else(|| <LinuxBlockIO as ::protobuf::Message>::default_instance())
    }

    pub fn clear_BlockIO(&mut self) {
        self.BlockIO.clear();
    }

    pub fn has_BlockIO(&self) -> bool {
        self.BlockIO.is_some()
    }

    // Param is passed by value, moved
    pub fn set_BlockIO(&mut self, v: LinuxBlockIO) {
        self.BlockIO = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_BlockIO(&mut self) -> &mut LinuxBlockIO {
        self.BlockIO.mut_or_insert_default()
    }

    // Take field
    pub fn take_BlockIO(&mut self) -> LinuxBlockIO {
        self.BlockIO.take().unwrap_or_else(|| LinuxBlockIO::new())
    }

    // repeated .grpc.LinuxHugepageLimit HugepageLimits = 6;

    pub fn HugepageLimits(&self) -> &[LinuxHugepageLimit] {
        &self.HugepageLimits
    }

    pub fn clear_HugepageLimits(&mut self) {
        self.HugepageLimits.clear();
    }

    // Param is passed by value, moved
    pub fn set_HugepageLimits(&mut self, v: ::std::vec::Vec<LinuxHugepageLimit>) {
        self.HugepageLimits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_HugepageLimits(&mut self) -> &mut ::std::vec::Vec<LinuxHugepageLimit> {
        &mut self.HugepageLimits
    }

    // Take field
    pub fn take_HugepageLimits(&mut self) -> ::std::vec::Vec<LinuxHugepageLimit> {
        ::std::mem::replace(&mut self.HugepageLimits, ::std::vec::Vec::new())
    }

    // .grpc.LinuxNetwork Network = 7;

    pub fn Network(&self) -> &LinuxNetwork {
        self.Network.as_ref().unwrap_or_else(|| <LinuxNetwork as ::protobuf::Message>::default_instance())
    }

    pub fn clear_Network(&mut self) {
        self.Network.clear();
    }

    pub fn has_Network(&self) -> bool {
        self.Network.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Network(&mut self, v: LinuxNetwork) {
        self.Network = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Network(&mut self) -> &mut LinuxNetwork {
        self.Network.mut_or_insert_default()
    }

    // Take field
    pub fn take_Network(&mut self) -> LinuxNetwork {
        self.Network.take().unwrap_or_else(|| LinuxNetwork::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Devices",
            |m: &LinuxResources| { &m.Devices },
            |m: &mut LinuxResources| { &mut m.Devices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinuxMemory>(
            "Memory",
            |m: &LinuxResources| { &m.Memory },
            |m: &mut LinuxResources| { &mut m.Memory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinuxCPU>(
            "CPU",
            |m: &LinuxResources| { &m.CPU },
            |m: &mut LinuxResources| { &mut m.CPU },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinuxPids>(
            "Pids",
            |m: &LinuxResources| { &m.Pids },
            |m: &mut LinuxResources| { &mut m.Pids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinuxBlockIO>(
            "BlockIO",
            |m: &LinuxResources| { &m.BlockIO },
            |m: &mut LinuxResources| { &mut m.BlockIO },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "HugepageLimits",
            |m: &LinuxResources| { &m.HugepageLimits },
            |m: &mut LinuxResources| { &mut m.HugepageLimits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinuxNetwork>(
            "Network",
            |m: &LinuxResources| { &m.Network },
            |m: &mut LinuxResources| { &mut m.Network },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxResources>(
            "LinuxResources",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxResources {
    const NAME: &'static str = "LinuxResources";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Devices.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Memory)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.CPU)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Pids)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.BlockIO)?;
                },
                50 => {
                    self.HugepageLimits.push(is.read_message()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Network)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.Devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.Memory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.CPU.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.Pids.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.BlockIO.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.HugepageLimits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.Network.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.Devices {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.Memory.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.CPU.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.Pids.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.BlockIO.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.HugepageLimits {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.Network.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxResources {
        LinuxResources::new()
    }

    fn clear(&mut self) {
        self.Devices.clear();
        self.Memory.clear();
        self.CPU.clear();
        self.Pids.clear();
        self.BlockIO.clear();
        self.HugepageLimits.clear();
        self.Network.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxResources {
        static instance: LinuxResources = LinuxResources {
            Devices: ::std::vec::Vec::new(),
            Memory: ::protobuf::MessageField::none(),
            CPU: ::protobuf::MessageField::none(),
            Pids: ::protobuf::MessageField::none(),
            BlockIO: ::protobuf::MessageField::none(),
            HugepageLimits: ::std::vec::Vec::new(),
            Network: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxResources {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxResources").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxResources {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxMemory)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxMemory {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxMemory.Limit)
    pub Limit: i64,
    // @@protoc_insertion_point(field:grpc.LinuxMemory.Reservation)
    pub Reservation: i64,
    // @@protoc_insertion_point(field:grpc.LinuxMemory.Swap)
    pub Swap: i64,
    // @@protoc_insertion_point(field:grpc.LinuxMemory.Kernel)
    pub Kernel: i64,
    // @@protoc_insertion_point(field:grpc.LinuxMemory.KernelTCP)
    pub KernelTCP: i64,
    // @@protoc_insertion_point(field:grpc.LinuxMemory.Swappiness)
    pub Swappiness: u64,
    // @@protoc_insertion_point(field:grpc.LinuxMemory.DisableOOMKiller)
    pub DisableOOMKiller: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxMemory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxMemory {
    fn default() -> &'a LinuxMemory {
        <LinuxMemory as ::protobuf::Message>::default_instance()
    }
}

impl LinuxMemory {
    pub fn new() -> LinuxMemory {
        ::std::default::Default::default()
    }

    // int64 Limit = 1;

    pub fn Limit(&self) -> i64 {
        self.Limit
    }

    pub fn clear_Limit(&mut self) {
        self.Limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_Limit(&mut self, v: i64) {
        self.Limit = v;
    }

    // int64 Reservation = 2;

    pub fn Reservation(&self) -> i64 {
        self.Reservation
    }

    pub fn clear_Reservation(&mut self) {
        self.Reservation = 0;
    }

    // Param is passed by value, moved
    pub fn set_Reservation(&mut self, v: i64) {
        self.Reservation = v;
    }

    // int64 Swap = 3;

    pub fn Swap(&self) -> i64 {
        self.Swap
    }

    pub fn clear_Swap(&mut self) {
        self.Swap = 0;
    }

    // Param is passed by value, moved
    pub fn set_Swap(&mut self, v: i64) {
        self.Swap = v;
    }

    // int64 Kernel = 4;

    pub fn Kernel(&self) -> i64 {
        self.Kernel
    }

    pub fn clear_Kernel(&mut self) {
        self.Kernel = 0;
    }

    // Param is passed by value, moved
    pub fn set_Kernel(&mut self, v: i64) {
        self.Kernel = v;
    }

    // int64 KernelTCP = 5;

    pub fn KernelTCP(&self) -> i64 {
        self.KernelTCP
    }

    pub fn clear_KernelTCP(&mut self) {
        self.KernelTCP = 0;
    }

    // Param is passed by value, moved
    pub fn set_KernelTCP(&mut self, v: i64) {
        self.KernelTCP = v;
    }

    // uint64 Swappiness = 6;

    pub fn Swappiness(&self) -> u64 {
        self.Swappiness
    }

    pub fn clear_Swappiness(&mut self) {
        self.Swappiness = 0;
    }

    // Param is passed by value, moved
    pub fn set_Swappiness(&mut self, v: u64) {
        self.Swappiness = v;
    }

    // bool DisableOOMKiller = 7;

    pub fn DisableOOMKiller(&self) -> bool {
        self.DisableOOMKiller
    }

    pub fn clear_DisableOOMKiller(&mut self) {
        self.DisableOOMKiller = false;
    }

    // Param is passed by value, moved
    pub fn set_DisableOOMKiller(&mut self, v: bool) {
        self.DisableOOMKiller = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Limit",
            |m: &LinuxMemory| { &m.Limit },
            |m: &mut LinuxMemory| { &mut m.Limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Reservation",
            |m: &LinuxMemory| { &m.Reservation },
            |m: &mut LinuxMemory| { &mut m.Reservation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Swap",
            |m: &LinuxMemory| { &m.Swap },
            |m: &mut LinuxMemory| { &mut m.Swap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Kernel",
            |m: &LinuxMemory| { &m.Kernel },
            |m: &mut LinuxMemory| { &mut m.Kernel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "KernelTCP",
            |m: &LinuxMemory| { &m.KernelTCP },
            |m: &mut LinuxMemory| { &mut m.KernelTCP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Swappiness",
            |m: &LinuxMemory| { &m.Swappiness },
            |m: &mut LinuxMemory| { &mut m.Swappiness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DisableOOMKiller",
            |m: &LinuxMemory| { &m.DisableOOMKiller },
            |m: &mut LinuxMemory| { &mut m.DisableOOMKiller },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxMemory>(
            "LinuxMemory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxMemory {
    const NAME: &'static str = "LinuxMemory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Limit = is.read_int64()?;
                },
                16 => {
                    self.Reservation = is.read_int64()?;
                },
                24 => {
                    self.Swap = is.read_int64()?;
                },
                32 => {
                    self.Kernel = is.read_int64()?;
                },
                40 => {
                    self.KernelTCP = is.read_int64()?;
                },
                48 => {
                    self.Swappiness = is.read_uint64()?;
                },
                56 => {
                    self.DisableOOMKiller = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.Limit != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.Limit);
        }
        if self.Reservation != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.Reservation);
        }
        if self.Swap != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.Swap);
        }
        if self.Kernel != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.Kernel);
        }
        if self.KernelTCP != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.KernelTCP);
        }
        if self.Swappiness != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.Swappiness);
        }
        if self.DisableOOMKiller != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.Limit != 0 {
            os.write_int64(1, self.Limit)?;
        }
        if self.Reservation != 0 {
            os.write_int64(2, self.Reservation)?;
        }
        if self.Swap != 0 {
            os.write_int64(3, self.Swap)?;
        }
        if self.Kernel != 0 {
            os.write_int64(4, self.Kernel)?;
        }
        if self.KernelTCP != 0 {
            os.write_int64(5, self.KernelTCP)?;
        }
        if self.Swappiness != 0 {
            os.write_uint64(6, self.Swappiness)?;
        }
        if self.DisableOOMKiller != false {
            os.write_bool(7, self.DisableOOMKiller)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxMemory {
        LinuxMemory::new()
    }

    fn clear(&mut self) {
        self.Limit = 0;
        self.Reservation = 0;
        self.Swap = 0;
        self.Kernel = 0;
        self.KernelTCP = 0;
        self.Swappiness = 0;
        self.DisableOOMKiller = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxMemory {
        static instance: LinuxMemory = LinuxMemory {
            Limit: 0,
            Reservation: 0,
            Swap: 0,
            Kernel: 0,
            KernelTCP: 0,
            Swappiness: 0,
            DisableOOMKiller: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxMemory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxMemory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxMemory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxMemory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxCPU)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxCPU {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxCPU.Shares)
    pub Shares: u64,
    // @@protoc_insertion_point(field:grpc.LinuxCPU.Quota)
    pub Quota: i64,
    // @@protoc_insertion_point(field:grpc.LinuxCPU.Period)
    pub Period: u64,
    // @@protoc_insertion_point(field:grpc.LinuxCPU.RealtimeRuntime)
    pub RealtimeRuntime: i64,
    // @@protoc_insertion_point(field:grpc.LinuxCPU.RealtimePeriod)
    pub RealtimePeriod: u64,
    // @@protoc_insertion_point(field:grpc.LinuxCPU.Cpus)
    pub Cpus: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.LinuxCPU.Mems)
    pub Mems: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxCPU.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxCPU {
    fn default() -> &'a LinuxCPU {
        <LinuxCPU as ::protobuf::Message>::default_instance()
    }
}

impl LinuxCPU {
    pub fn new() -> LinuxCPU {
        ::std::default::Default::default()
    }

    // uint64 Shares = 1;

    pub fn Shares(&self) -> u64 {
        self.Shares
    }

    pub fn clear_Shares(&mut self) {
        self.Shares = 0;
    }

    // Param is passed by value, moved
    pub fn set_Shares(&mut self, v: u64) {
        self.Shares = v;
    }

    // int64 Quota = 2;

    pub fn Quota(&self) -> i64 {
        self.Quota
    }

    pub fn clear_Quota(&mut self) {
        self.Quota = 0;
    }

    // Param is passed by value, moved
    pub fn set_Quota(&mut self, v: i64) {
        self.Quota = v;
    }

    // uint64 Period = 3;

    pub fn Period(&self) -> u64 {
        self.Period
    }

    pub fn clear_Period(&mut self) {
        self.Period = 0;
    }

    // Param is passed by value, moved
    pub fn set_Period(&mut self, v: u64) {
        self.Period = v;
    }

    // int64 RealtimeRuntime = 4;

    pub fn RealtimeRuntime(&self) -> i64 {
        self.RealtimeRuntime
    }

    pub fn clear_RealtimeRuntime(&mut self) {
        self.RealtimeRuntime = 0;
    }

    // Param is passed by value, moved
    pub fn set_RealtimeRuntime(&mut self, v: i64) {
        self.RealtimeRuntime = v;
    }

    // uint64 RealtimePeriod = 5;

    pub fn RealtimePeriod(&self) -> u64 {
        self.RealtimePeriod
    }

    pub fn clear_RealtimePeriod(&mut self) {
        self.RealtimePeriod = 0;
    }

    // Param is passed by value, moved
    pub fn set_RealtimePeriod(&mut self, v: u64) {
        self.RealtimePeriod = v;
    }

    // string Cpus = 6;

    pub fn Cpus(&self) -> &str {
        &self.Cpus
    }

    pub fn clear_Cpus(&mut self) {
        self.Cpus.clear();
    }

    // Param is passed by value, moved
    pub fn set_Cpus(&mut self, v: ::std::string::String) {
        self.Cpus = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Cpus(&mut self) -> &mut ::std::string::String {
        &mut self.Cpus
    }

    // Take field
    pub fn take_Cpus(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Cpus, ::std::string::String::new())
    }

    // string Mems = 7;

    pub fn Mems(&self) -> &str {
        &self.Mems
    }

    pub fn clear_Mems(&mut self) {
        self.Mems.clear();
    }

    // Param is passed by value, moved
    pub fn set_Mems(&mut self, v: ::std::string::String) {
        self.Mems = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Mems(&mut self) -> &mut ::std::string::String {
        &mut self.Mems
    }

    // Take field
    pub fn take_Mems(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Mems, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Shares",
            |m: &LinuxCPU| { &m.Shares },
            |m: &mut LinuxCPU| { &mut m.Shares },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Quota",
            |m: &LinuxCPU| { &m.Quota },
            |m: &mut LinuxCPU| { &mut m.Quota },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Period",
            |m: &LinuxCPU| { &m.Period },
            |m: &mut LinuxCPU| { &mut m.Period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "RealtimeRuntime",
            |m: &LinuxCPU| { &m.RealtimeRuntime },
            |m: &mut LinuxCPU| { &mut m.RealtimeRuntime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "RealtimePeriod",
            |m: &LinuxCPU| { &m.RealtimePeriod },
            |m: &mut LinuxCPU| { &mut m.RealtimePeriod },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Cpus",
            |m: &LinuxCPU| { &m.Cpus },
            |m: &mut LinuxCPU| { &mut m.Cpus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Mems",
            |m: &LinuxCPU| { &m.Mems },
            |m: &mut LinuxCPU| { &mut m.Mems },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxCPU>(
            "LinuxCPU",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxCPU {
    const NAME: &'static str = "LinuxCPU";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Shares = is.read_uint64()?;
                },
                16 => {
                    self.Quota = is.read_int64()?;
                },
                24 => {
                    self.Period = is.read_uint64()?;
                },
                32 => {
                    self.RealtimeRuntime = is.read_int64()?;
                },
                40 => {
                    self.RealtimePeriod = is.read_uint64()?;
                },
                50 => {
                    self.Cpus = is.read_string()?;
                },
                58 => {
                    self.Mems = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.Shares != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.Shares);
        }
        if self.Quota != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.Quota);
        }
        if self.Period != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.Period);
        }
        if self.RealtimeRuntime != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.RealtimeRuntime);
        }
        if self.RealtimePeriod != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.RealtimePeriod);
        }
        if !self.Cpus.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.Cpus);
        }
        if !self.Mems.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.Mems);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.Shares != 0 {
            os.write_uint64(1, self.Shares)?;
        }
        if self.Quota != 0 {
            os.write_int64(2, self.Quota)?;
        }
        if self.Period != 0 {
            os.write_uint64(3, self.Period)?;
        }
        if self.RealtimeRuntime != 0 {
            os.write_int64(4, self.RealtimeRuntime)?;
        }
        if self.RealtimePeriod != 0 {
            os.write_uint64(5, self.RealtimePeriod)?;
        }
        if !self.Cpus.is_empty() {
            os.write_string(6, &self.Cpus)?;
        }
        if !self.Mems.is_empty() {
            os.write_string(7, &self.Mems)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxCPU {
        LinuxCPU::new()
    }

    fn clear(&mut self) {
        self.Shares = 0;
        self.Quota = 0;
        self.Period = 0;
        self.RealtimeRuntime = 0;
        self.RealtimePeriod = 0;
        self.Cpus.clear();
        self.Mems.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxCPU {
        static instance: LinuxCPU = LinuxCPU {
            Shares: 0,
            Quota: 0,
            Period: 0,
            RealtimeRuntime: 0,
            RealtimePeriod: 0,
            Cpus: ::std::string::String::new(),
            Mems: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxCPU {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxCPU").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxCPU {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxCPU {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxWeightDevice)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxWeightDevice {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxWeightDevice.Major)
    pub Major: i64,
    // @@protoc_insertion_point(field:grpc.LinuxWeightDevice.Minor)
    pub Minor: i64,
    // @@protoc_insertion_point(field:grpc.LinuxWeightDevice.Weight)
    pub Weight: u32,
    // @@protoc_insertion_point(field:grpc.LinuxWeightDevice.LeafWeight)
    pub LeafWeight: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxWeightDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxWeightDevice {
    fn default() -> &'a LinuxWeightDevice {
        <LinuxWeightDevice as ::protobuf::Message>::default_instance()
    }
}

impl LinuxWeightDevice {
    pub fn new() -> LinuxWeightDevice {
        ::std::default::Default::default()
    }

    // int64 Major = 1;

    pub fn Major(&self) -> i64 {
        self.Major
    }

    pub fn clear_Major(&mut self) {
        self.Major = 0;
    }

    // Param is passed by value, moved
    pub fn set_Major(&mut self, v: i64) {
        self.Major = v;
    }

    // int64 Minor = 2;

    pub fn Minor(&self) -> i64 {
        self.Minor
    }

    pub fn clear_Minor(&mut self) {
        self.Minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_Minor(&mut self, v: i64) {
        self.Minor = v;
    }

    // uint32 Weight = 3;

    pub fn Weight(&self) -> u32 {
        self.Weight
    }

    pub fn clear_Weight(&mut self) {
        self.Weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_Weight(&mut self, v: u32) {
        self.Weight = v;
    }

    // uint32 LeafWeight = 4;

    pub fn LeafWeight(&self) -> u32 {
        self.LeafWeight
    }

    pub fn clear_LeafWeight(&mut self) {
        self.LeafWeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_LeafWeight(&mut self, v: u32) {
        self.LeafWeight = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Major",
            |m: &LinuxWeightDevice| { &m.Major },
            |m: &mut LinuxWeightDevice| { &mut m.Major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Minor",
            |m: &LinuxWeightDevice| { &m.Minor },
            |m: &mut LinuxWeightDevice| { &mut m.Minor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Weight",
            |m: &LinuxWeightDevice| { &m.Weight },
            |m: &mut LinuxWeightDevice| { &mut m.Weight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LeafWeight",
            |m: &LinuxWeightDevice| { &m.LeafWeight },
            |m: &mut LinuxWeightDevice| { &mut m.LeafWeight },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxWeightDevice>(
            "LinuxWeightDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxWeightDevice {
    const NAME: &'static str = "LinuxWeightDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Major = is.read_int64()?;
                },
                16 => {
                    self.Minor = is.read_int64()?;
                },
                24 => {
                    self.Weight = is.read_uint32()?;
                },
                32 => {
                    self.LeafWeight = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.Major != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.Major);
        }
        if self.Minor != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.Minor);
        }
        if self.Weight != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.Weight);
        }
        if self.LeafWeight != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.LeafWeight);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.Major != 0 {
            os.write_int64(1, self.Major)?;
        }
        if self.Minor != 0 {
            os.write_int64(2, self.Minor)?;
        }
        if self.Weight != 0 {
            os.write_uint32(3, self.Weight)?;
        }
        if self.LeafWeight != 0 {
            os.write_uint32(4, self.LeafWeight)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxWeightDevice {
        LinuxWeightDevice::new()
    }

    fn clear(&mut self) {
        self.Major = 0;
        self.Minor = 0;
        self.Weight = 0;
        self.LeafWeight = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxWeightDevice {
        static instance: LinuxWeightDevice = LinuxWeightDevice {
            Major: 0,
            Minor: 0,
            Weight: 0,
            LeafWeight: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxWeightDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxWeightDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxWeightDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxWeightDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxThrottleDevice)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxThrottleDevice {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxThrottleDevice.Major)
    pub Major: i64,
    // @@protoc_insertion_point(field:grpc.LinuxThrottleDevice.Minor)
    pub Minor: i64,
    // @@protoc_insertion_point(field:grpc.LinuxThrottleDevice.Rate)
    pub Rate: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxThrottleDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxThrottleDevice {
    fn default() -> &'a LinuxThrottleDevice {
        <LinuxThrottleDevice as ::protobuf::Message>::default_instance()
    }
}

impl LinuxThrottleDevice {
    pub fn new() -> LinuxThrottleDevice {
        ::std::default::Default::default()
    }

    // int64 Major = 1;

    pub fn Major(&self) -> i64 {
        self.Major
    }

    pub fn clear_Major(&mut self) {
        self.Major = 0;
    }

    // Param is passed by value, moved
    pub fn set_Major(&mut self, v: i64) {
        self.Major = v;
    }

    // int64 Minor = 2;

    pub fn Minor(&self) -> i64 {
        self.Minor
    }

    pub fn clear_Minor(&mut self) {
        self.Minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_Minor(&mut self, v: i64) {
        self.Minor = v;
    }

    // uint64 Rate = 3;

    pub fn Rate(&self) -> u64 {
        self.Rate
    }

    pub fn clear_Rate(&mut self) {
        self.Rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_Rate(&mut self, v: u64) {
        self.Rate = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Major",
            |m: &LinuxThrottleDevice| { &m.Major },
            |m: &mut LinuxThrottleDevice| { &mut m.Major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Minor",
            |m: &LinuxThrottleDevice| { &m.Minor },
            |m: &mut LinuxThrottleDevice| { &mut m.Minor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Rate",
            |m: &LinuxThrottleDevice| { &m.Rate },
            |m: &mut LinuxThrottleDevice| { &mut m.Rate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxThrottleDevice>(
            "LinuxThrottleDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxThrottleDevice {
    const NAME: &'static str = "LinuxThrottleDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Major = is.read_int64()?;
                },
                16 => {
                    self.Minor = is.read_int64()?;
                },
                24 => {
                    self.Rate = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.Major != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.Major);
        }
        if self.Minor != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.Minor);
        }
        if self.Rate != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.Rate);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.Major != 0 {
            os.write_int64(1, self.Major)?;
        }
        if self.Minor != 0 {
            os.write_int64(2, self.Minor)?;
        }
        if self.Rate != 0 {
            os.write_uint64(3, self.Rate)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxThrottleDevice {
        LinuxThrottleDevice::new()
    }

    fn clear(&mut self) {
        self.Major = 0;
        self.Minor = 0;
        self.Rate = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxThrottleDevice {
        static instance: LinuxThrottleDevice = LinuxThrottleDevice {
            Major: 0,
            Minor: 0,
            Rate: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxThrottleDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxThrottleDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxThrottleDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxThrottleDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxBlockIO)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxBlockIO {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxBlockIO.Weight)
    pub Weight: u32,
    // @@protoc_insertion_point(field:grpc.LinuxBlockIO.LeafWeight)
    pub LeafWeight: u32,
    // @@protoc_insertion_point(field:grpc.LinuxBlockIO.WeightDevice)
    pub WeightDevice: ::std::vec::Vec<LinuxWeightDevice>,
    // @@protoc_insertion_point(field:grpc.LinuxBlockIO.ThrottleReadBpsDevice)
    pub ThrottleReadBpsDevice: ::std::vec::Vec<LinuxThrottleDevice>,
    // @@protoc_insertion_point(field:grpc.LinuxBlockIO.ThrottleWriteBpsDevice)
    pub ThrottleWriteBpsDevice: ::std::vec::Vec<LinuxThrottleDevice>,
    // @@protoc_insertion_point(field:grpc.LinuxBlockIO.ThrottleReadIOPSDevice)
    pub ThrottleReadIOPSDevice: ::std::vec::Vec<LinuxThrottleDevice>,
    // @@protoc_insertion_point(field:grpc.LinuxBlockIO.ThrottleWriteIOPSDevice)
    pub ThrottleWriteIOPSDevice: ::std::vec::Vec<LinuxThrottleDevice>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxBlockIO.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxBlockIO {
    fn default() -> &'a LinuxBlockIO {
        <LinuxBlockIO as ::protobuf::Message>::default_instance()
    }
}

impl LinuxBlockIO {
    pub fn new() -> LinuxBlockIO {
        ::std::default::Default::default()
    }

    // uint32 Weight = 1;

    pub fn Weight(&self) -> u32 {
        self.Weight
    }

    pub fn clear_Weight(&mut self) {
        self.Weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_Weight(&mut self, v: u32) {
        self.Weight = v;
    }

    // uint32 LeafWeight = 2;

    pub fn LeafWeight(&self) -> u32 {
        self.LeafWeight
    }

    pub fn clear_LeafWeight(&mut self) {
        self.LeafWeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_LeafWeight(&mut self, v: u32) {
        self.LeafWeight = v;
    }

    // repeated .grpc.LinuxWeightDevice WeightDevice = 3;

    pub fn WeightDevice(&self) -> &[LinuxWeightDevice] {
        &self.WeightDevice
    }

    pub fn clear_WeightDevice(&mut self) {
        self.WeightDevice.clear();
    }

    // Param is passed by value, moved
    pub fn set_WeightDevice(&mut self, v: ::std::vec::Vec<LinuxWeightDevice>) {
        self.WeightDevice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_WeightDevice(&mut self) -> &mut ::std::vec::Vec<LinuxWeightDevice> {
        &mut self.WeightDevice
    }

    // Take field
    pub fn take_WeightDevice(&mut self) -> ::std::vec::Vec<LinuxWeightDevice> {
        ::std::mem::replace(&mut self.WeightDevice, ::std::vec::Vec::new())
    }

    // repeated .grpc.LinuxThrottleDevice ThrottleReadBpsDevice = 4;

    pub fn ThrottleReadBpsDevice(&self) -> &[LinuxThrottleDevice] {
        &self.ThrottleReadBpsDevice
    }

    pub fn clear_ThrottleReadBpsDevice(&mut self) {
        self.ThrottleReadBpsDevice.clear();
    }

    // Param is passed by value, moved
    pub fn set_ThrottleReadBpsDevice(&mut self, v: ::std::vec::Vec<LinuxThrottleDevice>) {
        self.ThrottleReadBpsDevice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ThrottleReadBpsDevice(&mut self) -> &mut ::std::vec::Vec<LinuxThrottleDevice> {
        &mut self.ThrottleReadBpsDevice
    }

    // Take field
    pub fn take_ThrottleReadBpsDevice(&mut self) -> ::std::vec::Vec<LinuxThrottleDevice> {
        ::std::mem::replace(&mut self.ThrottleReadBpsDevice, ::std::vec::Vec::new())
    }

    // repeated .grpc.LinuxThrottleDevice ThrottleWriteBpsDevice = 5;

    pub fn ThrottleWriteBpsDevice(&self) -> &[LinuxThrottleDevice] {
        &self.ThrottleWriteBpsDevice
    }

    pub fn clear_ThrottleWriteBpsDevice(&mut self) {
        self.ThrottleWriteBpsDevice.clear();
    }

    // Param is passed by value, moved
    pub fn set_ThrottleWriteBpsDevice(&mut self, v: ::std::vec::Vec<LinuxThrottleDevice>) {
        self.ThrottleWriteBpsDevice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ThrottleWriteBpsDevice(&mut self) -> &mut ::std::vec::Vec<LinuxThrottleDevice> {
        &mut self.ThrottleWriteBpsDevice
    }

    // Take field
    pub fn take_ThrottleWriteBpsDevice(&mut self) -> ::std::vec::Vec<LinuxThrottleDevice> {
        ::std::mem::replace(&mut self.ThrottleWriteBpsDevice, ::std::vec::Vec::new())
    }

    // repeated .grpc.LinuxThrottleDevice ThrottleReadIOPSDevice = 6;

    pub fn ThrottleReadIOPSDevice(&self) -> &[LinuxThrottleDevice] {
        &self.ThrottleReadIOPSDevice
    }

    pub fn clear_ThrottleReadIOPSDevice(&mut self) {
        self.ThrottleReadIOPSDevice.clear();
    }

    // Param is passed by value, moved
    pub fn set_ThrottleReadIOPSDevice(&mut self, v: ::std::vec::Vec<LinuxThrottleDevice>) {
        self.ThrottleReadIOPSDevice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ThrottleReadIOPSDevice(&mut self) -> &mut ::std::vec::Vec<LinuxThrottleDevice> {
        &mut self.ThrottleReadIOPSDevice
    }

    // Take field
    pub fn take_ThrottleReadIOPSDevice(&mut self) -> ::std::vec::Vec<LinuxThrottleDevice> {
        ::std::mem::replace(&mut self.ThrottleReadIOPSDevice, ::std::vec::Vec::new())
    }

    // repeated .grpc.LinuxThrottleDevice ThrottleWriteIOPSDevice = 7;

    pub fn ThrottleWriteIOPSDevice(&self) -> &[LinuxThrottleDevice] {
        &self.ThrottleWriteIOPSDevice
    }

    pub fn clear_ThrottleWriteIOPSDevice(&mut self) {
        self.ThrottleWriteIOPSDevice.clear();
    }

    // Param is passed by value, moved
    pub fn set_ThrottleWriteIOPSDevice(&mut self, v: ::std::vec::Vec<LinuxThrottleDevice>) {
        self.ThrottleWriteIOPSDevice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ThrottleWriteIOPSDevice(&mut self) -> &mut ::std::vec::Vec<LinuxThrottleDevice> {
        &mut self.ThrottleWriteIOPSDevice
    }

    // Take field
    pub fn take_ThrottleWriteIOPSDevice(&mut self) -> ::std::vec::Vec<LinuxThrottleDevice> {
        ::std::mem::replace(&mut self.ThrottleWriteIOPSDevice, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Weight",
            |m: &LinuxBlockIO| { &m.Weight },
            |m: &mut LinuxBlockIO| { &mut m.Weight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LeafWeight",
            |m: &LinuxBlockIO| { &m.LeafWeight },
            |m: &mut LinuxBlockIO| { &mut m.LeafWeight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "WeightDevice",
            |m: &LinuxBlockIO| { &m.WeightDevice },
            |m: &mut LinuxBlockIO| { &mut m.WeightDevice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ThrottleReadBpsDevice",
            |m: &LinuxBlockIO| { &m.ThrottleReadBpsDevice },
            |m: &mut LinuxBlockIO| { &mut m.ThrottleReadBpsDevice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ThrottleWriteBpsDevice",
            |m: &LinuxBlockIO| { &m.ThrottleWriteBpsDevice },
            |m: &mut LinuxBlockIO| { &mut m.ThrottleWriteBpsDevice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ThrottleReadIOPSDevice",
            |m: &LinuxBlockIO| { &m.ThrottleReadIOPSDevice },
            |m: &mut LinuxBlockIO| { &mut m.ThrottleReadIOPSDevice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ThrottleWriteIOPSDevice",
            |m: &LinuxBlockIO| { &m.ThrottleWriteIOPSDevice },
            |m: &mut LinuxBlockIO| { &mut m.ThrottleWriteIOPSDevice },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxBlockIO>(
            "LinuxBlockIO",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxBlockIO {
    const NAME: &'static str = "LinuxBlockIO";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Weight = is.read_uint32()?;
                },
                16 => {
                    self.LeafWeight = is.read_uint32()?;
                },
                26 => {
                    self.WeightDevice.push(is.read_message()?);
                },
                34 => {
                    self.ThrottleReadBpsDevice.push(is.read_message()?);
                },
                42 => {
                    self.ThrottleWriteBpsDevice.push(is.read_message()?);
                },
                50 => {
                    self.ThrottleReadIOPSDevice.push(is.read_message()?);
                },
                58 => {
                    self.ThrottleWriteIOPSDevice.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.Weight != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.Weight);
        }
        if self.LeafWeight != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.LeafWeight);
        }
        for value in &self.WeightDevice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ThrottleReadBpsDevice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ThrottleWriteBpsDevice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ThrottleReadIOPSDevice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ThrottleWriteIOPSDevice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.Weight != 0 {
            os.write_uint32(1, self.Weight)?;
        }
        if self.LeafWeight != 0 {
            os.write_uint32(2, self.LeafWeight)?;
        }
        for v in &self.WeightDevice {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.ThrottleReadBpsDevice {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.ThrottleWriteBpsDevice {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.ThrottleReadIOPSDevice {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.ThrottleWriteIOPSDevice {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxBlockIO {
        LinuxBlockIO::new()
    }

    fn clear(&mut self) {
        self.Weight = 0;
        self.LeafWeight = 0;
        self.WeightDevice.clear();
        self.ThrottleReadBpsDevice.clear();
        self.ThrottleWriteBpsDevice.clear();
        self.ThrottleReadIOPSDevice.clear();
        self.ThrottleWriteIOPSDevice.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxBlockIO {
        static instance: LinuxBlockIO = LinuxBlockIO {
            Weight: 0,
            LeafWeight: 0,
            WeightDevice: ::std::vec::Vec::new(),
            ThrottleReadBpsDevice: ::std::vec::Vec::new(),
            ThrottleWriteBpsDevice: ::std::vec::Vec::new(),
            ThrottleReadIOPSDevice: ::std::vec::Vec::new(),
            ThrottleWriteIOPSDevice: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxBlockIO {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxBlockIO").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxBlockIO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxBlockIO {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxPids)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxPids {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxPids.Limit)
    pub Limit: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxPids.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxPids {
    fn default() -> &'a LinuxPids {
        <LinuxPids as ::protobuf::Message>::default_instance()
    }
}

impl LinuxPids {
    pub fn new() -> LinuxPids {
        ::std::default::Default::default()
    }

    // int64 Limit = 1;

    pub fn Limit(&self) -> i64 {
        self.Limit
    }

    pub fn clear_Limit(&mut self) {
        self.Limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_Limit(&mut self, v: i64) {
        self.Limit = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Limit",
            |m: &LinuxPids| { &m.Limit },
            |m: &mut LinuxPids| { &mut m.Limit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxPids>(
            "LinuxPids",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxPids {
    const NAME: &'static str = "LinuxPids";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Limit = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.Limit != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.Limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.Limit != 0 {
            os.write_int64(1, self.Limit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxPids {
        LinuxPids::new()
    }

    fn clear(&mut self) {
        self.Limit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxPids {
        static instance: LinuxPids = LinuxPids {
            Limit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxPids {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxPids").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxPids {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxPids {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxDeviceCgroup)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxDeviceCgroup {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxDeviceCgroup.Allow)
    pub Allow: bool,
    // @@protoc_insertion_point(field:grpc.LinuxDeviceCgroup.Type)
    pub Type: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.LinuxDeviceCgroup.Major)
    pub Major: i64,
    // @@protoc_insertion_point(field:grpc.LinuxDeviceCgroup.Minor)
    pub Minor: i64,
    // @@protoc_insertion_point(field:grpc.LinuxDeviceCgroup.Access)
    pub Access: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxDeviceCgroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxDeviceCgroup {
    fn default() -> &'a LinuxDeviceCgroup {
        <LinuxDeviceCgroup as ::protobuf::Message>::default_instance()
    }
}

impl LinuxDeviceCgroup {
    pub fn new() -> LinuxDeviceCgroup {
        ::std::default::Default::default()
    }

    // bool Allow = 1;

    pub fn Allow(&self) -> bool {
        self.Allow
    }

    pub fn clear_Allow(&mut self) {
        self.Allow = false;
    }

    // Param is passed by value, moved
    pub fn set_Allow(&mut self, v: bool) {
        self.Allow = v;
    }

    // string Type = 2;

    pub fn Type(&self) -> &str {
        &self.Type
    }

    pub fn clear_Type(&mut self) {
        self.Type.clear();
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: ::std::string::String) {
        self.Type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Type(&mut self) -> &mut ::std::string::String {
        &mut self.Type
    }

    // Take field
    pub fn take_Type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Type, ::std::string::String::new())
    }

    // int64 Major = 3;

    pub fn Major(&self) -> i64 {
        self.Major
    }

    pub fn clear_Major(&mut self) {
        self.Major = 0;
    }

    // Param is passed by value, moved
    pub fn set_Major(&mut self, v: i64) {
        self.Major = v;
    }

    // int64 Minor = 4;

    pub fn Minor(&self) -> i64 {
        self.Minor
    }

    pub fn clear_Minor(&mut self) {
        self.Minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_Minor(&mut self, v: i64) {
        self.Minor = v;
    }

    // string Access = 5;

    pub fn Access(&self) -> &str {
        &self.Access
    }

    pub fn clear_Access(&mut self) {
        self.Access.clear();
    }

    // Param is passed by value, moved
    pub fn set_Access(&mut self, v: ::std::string::String) {
        self.Access = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Access(&mut self) -> &mut ::std::string::String {
        &mut self.Access
    }

    // Take field
    pub fn take_Access(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Access, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Allow",
            |m: &LinuxDeviceCgroup| { &m.Allow },
            |m: &mut LinuxDeviceCgroup| { &mut m.Allow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Type",
            |m: &LinuxDeviceCgroup| { &m.Type },
            |m: &mut LinuxDeviceCgroup| { &mut m.Type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Major",
            |m: &LinuxDeviceCgroup| { &m.Major },
            |m: &mut LinuxDeviceCgroup| { &mut m.Major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Minor",
            |m: &LinuxDeviceCgroup| { &m.Minor },
            |m: &mut LinuxDeviceCgroup| { &mut m.Minor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Access",
            |m: &LinuxDeviceCgroup| { &m.Access },
            |m: &mut LinuxDeviceCgroup| { &mut m.Access },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxDeviceCgroup>(
            "LinuxDeviceCgroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxDeviceCgroup {
    const NAME: &'static str = "LinuxDeviceCgroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Allow = is.read_bool()?;
                },
                18 => {
                    self.Type = is.read_string()?;
                },
                24 => {
                    self.Major = is.read_int64()?;
                },
                32 => {
                    self.Minor = is.read_int64()?;
                },
                42 => {
                    self.Access = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.Allow != false {
            my_size += 1 + 1;
        }
        if !self.Type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Type);
        }
        if self.Major != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.Major);
        }
        if self.Minor != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.Minor);
        }
        if !self.Access.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.Access);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.Allow != false {
            os.write_bool(1, self.Allow)?;
        }
        if !self.Type.is_empty() {
            os.write_string(2, &self.Type)?;
        }
        if self.Major != 0 {
            os.write_int64(3, self.Major)?;
        }
        if self.Minor != 0 {
            os.write_int64(4, self.Minor)?;
        }
        if !self.Access.is_empty() {
            os.write_string(5, &self.Access)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxDeviceCgroup {
        LinuxDeviceCgroup::new()
    }

    fn clear(&mut self) {
        self.Allow = false;
        self.Type.clear();
        self.Major = 0;
        self.Minor = 0;
        self.Access.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxDeviceCgroup {
        static instance: LinuxDeviceCgroup = LinuxDeviceCgroup {
            Allow: false,
            Type: ::std::string::String::new(),
            Major: 0,
            Minor: 0,
            Access: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxDeviceCgroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxDeviceCgroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxDeviceCgroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxDeviceCgroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxNetwork)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxNetwork {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxNetwork.ClassID)
    pub ClassID: u32,
    // @@protoc_insertion_point(field:grpc.LinuxNetwork.Priorities)
    pub Priorities: ::std::vec::Vec<LinuxInterfacePriority>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxNetwork.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxNetwork {
    fn default() -> &'a LinuxNetwork {
        <LinuxNetwork as ::protobuf::Message>::default_instance()
    }
}

impl LinuxNetwork {
    pub fn new() -> LinuxNetwork {
        ::std::default::Default::default()
    }

    // uint32 ClassID = 1;

    pub fn ClassID(&self) -> u32 {
        self.ClassID
    }

    pub fn clear_ClassID(&mut self) {
        self.ClassID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ClassID(&mut self, v: u32) {
        self.ClassID = v;
    }

    // repeated .grpc.LinuxInterfacePriority Priorities = 2;

    pub fn Priorities(&self) -> &[LinuxInterfacePriority] {
        &self.Priorities
    }

    pub fn clear_Priorities(&mut self) {
        self.Priorities.clear();
    }

    // Param is passed by value, moved
    pub fn set_Priorities(&mut self, v: ::std::vec::Vec<LinuxInterfacePriority>) {
        self.Priorities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Priorities(&mut self) -> &mut ::std::vec::Vec<LinuxInterfacePriority> {
        &mut self.Priorities
    }

    // Take field
    pub fn take_Priorities(&mut self) -> ::std::vec::Vec<LinuxInterfacePriority> {
        ::std::mem::replace(&mut self.Priorities, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ClassID",
            |m: &LinuxNetwork| { &m.ClassID },
            |m: &mut LinuxNetwork| { &mut m.ClassID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Priorities",
            |m: &LinuxNetwork| { &m.Priorities },
            |m: &mut LinuxNetwork| { &mut m.Priorities },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxNetwork>(
            "LinuxNetwork",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxNetwork {
    const NAME: &'static str = "LinuxNetwork";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ClassID = is.read_uint32()?;
                },
                18 => {
                    self.Priorities.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ClassID != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.ClassID);
        }
        for value in &self.Priorities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ClassID != 0 {
            os.write_uint32(1, self.ClassID)?;
        }
        for v in &self.Priorities {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxNetwork {
        LinuxNetwork::new()
    }

    fn clear(&mut self) {
        self.ClassID = 0;
        self.Priorities.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxNetwork {
        static instance: LinuxNetwork = LinuxNetwork {
            ClassID: 0,
            Priorities: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxNetwork {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxNetwork").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxNetwork {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxNetwork {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxHugepageLimit)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxHugepageLimit {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxHugepageLimit.Pagesize)
    pub Pagesize: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.LinuxHugepageLimit.Limit)
    pub Limit: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxHugepageLimit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxHugepageLimit {
    fn default() -> &'a LinuxHugepageLimit {
        <LinuxHugepageLimit as ::protobuf::Message>::default_instance()
    }
}

impl LinuxHugepageLimit {
    pub fn new() -> LinuxHugepageLimit {
        ::std::default::Default::default()
    }

    // string Pagesize = 1;

    pub fn Pagesize(&self) -> &str {
        &self.Pagesize
    }

    pub fn clear_Pagesize(&mut self) {
        self.Pagesize.clear();
    }

    // Param is passed by value, moved
    pub fn set_Pagesize(&mut self, v: ::std::string::String) {
        self.Pagesize = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Pagesize(&mut self) -> &mut ::std::string::String {
        &mut self.Pagesize
    }

    // Take field
    pub fn take_Pagesize(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Pagesize, ::std::string::String::new())
    }

    // uint64 Limit = 2;

    pub fn Limit(&self) -> u64 {
        self.Limit
    }

    pub fn clear_Limit(&mut self) {
        self.Limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_Limit(&mut self, v: u64) {
        self.Limit = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Pagesize",
            |m: &LinuxHugepageLimit| { &m.Pagesize },
            |m: &mut LinuxHugepageLimit| { &mut m.Pagesize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Limit",
            |m: &LinuxHugepageLimit| { &m.Limit },
            |m: &mut LinuxHugepageLimit| { &mut m.Limit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxHugepageLimit>(
            "LinuxHugepageLimit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxHugepageLimit {
    const NAME: &'static str = "LinuxHugepageLimit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Pagesize = is.read_string()?;
                },
                16 => {
                    self.Limit = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Pagesize.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Pagesize);
        }
        if self.Limit != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.Limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Pagesize.is_empty() {
            os.write_string(1, &self.Pagesize)?;
        }
        if self.Limit != 0 {
            os.write_uint64(2, self.Limit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxHugepageLimit {
        LinuxHugepageLimit::new()
    }

    fn clear(&mut self) {
        self.Pagesize.clear();
        self.Limit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxHugepageLimit {
        static instance: LinuxHugepageLimit = LinuxHugepageLimit {
            Pagesize: ::std::string::String::new(),
            Limit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxHugepageLimit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxHugepageLimit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxHugepageLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxHugepageLimit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxInterfacePriority)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxInterfacePriority {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxInterfacePriority.Name)
    pub Name: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.LinuxInterfacePriority.Priority)
    pub Priority: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxInterfacePriority.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxInterfacePriority {
    fn default() -> &'a LinuxInterfacePriority {
        <LinuxInterfacePriority as ::protobuf::Message>::default_instance()
    }
}

impl LinuxInterfacePriority {
    pub fn new() -> LinuxInterfacePriority {
        ::std::default::Default::default()
    }

    // string Name = 1;

    pub fn Name(&self) -> &str {
        &self.Name
    }

    pub fn clear_Name(&mut self) {
        self.Name.clear();
    }

    // Param is passed by value, moved
    pub fn set_Name(&mut self, v: ::std::string::String) {
        self.Name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Name(&mut self) -> &mut ::std::string::String {
        &mut self.Name
    }

    // Take field
    pub fn take_Name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Name, ::std::string::String::new())
    }

    // uint32 Priority = 2;

    pub fn Priority(&self) -> u32 {
        self.Priority
    }

    pub fn clear_Priority(&mut self) {
        self.Priority = 0;
    }

    // Param is passed by value, moved
    pub fn set_Priority(&mut self, v: u32) {
        self.Priority = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Name",
            |m: &LinuxInterfacePriority| { &m.Name },
            |m: &mut LinuxInterfacePriority| { &mut m.Name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Priority",
            |m: &LinuxInterfacePriority| { &m.Priority },
            |m: &mut LinuxInterfacePriority| { &mut m.Priority },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxInterfacePriority>(
            "LinuxInterfacePriority",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxInterfacePriority {
    const NAME: &'static str = "LinuxInterfacePriority";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Name = is.read_string()?;
                },
                16 => {
                    self.Priority = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Name);
        }
        if self.Priority != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.Priority);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Name.is_empty() {
            os.write_string(1, &self.Name)?;
        }
        if self.Priority != 0 {
            os.write_uint32(2, self.Priority)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxInterfacePriority {
        LinuxInterfacePriority::new()
    }

    fn clear(&mut self) {
        self.Name.clear();
        self.Priority = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxInterfacePriority {
        static instance: LinuxInterfacePriority = LinuxInterfacePriority {
            Name: ::std::string::String::new(),
            Priority: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxInterfacePriority {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxInterfacePriority").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxInterfacePriority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxInterfacePriority {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxSeccomp)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxSeccomp {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxSeccomp.DefaultAction)
    pub DefaultAction: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.LinuxSeccomp.Architectures)
    pub Architectures: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.LinuxSeccomp.Flags)
    pub Flags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.LinuxSeccomp.Syscalls)
    pub Syscalls: ::std::vec::Vec<LinuxSyscall>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxSeccomp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxSeccomp {
    fn default() -> &'a LinuxSeccomp {
        <LinuxSeccomp as ::protobuf::Message>::default_instance()
    }
}

impl LinuxSeccomp {
    pub fn new() -> LinuxSeccomp {
        ::std::default::Default::default()
    }

    // string DefaultAction = 1;

    pub fn DefaultAction(&self) -> &str {
        &self.DefaultAction
    }

    pub fn clear_DefaultAction(&mut self) {
        self.DefaultAction.clear();
    }

    // Param is passed by value, moved
    pub fn set_DefaultAction(&mut self, v: ::std::string::String) {
        self.DefaultAction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DefaultAction(&mut self) -> &mut ::std::string::String {
        &mut self.DefaultAction
    }

    // Take field
    pub fn take_DefaultAction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.DefaultAction, ::std::string::String::new())
    }

    // repeated string Architectures = 2;

    pub fn Architectures(&self) -> &[::std::string::String] {
        &self.Architectures
    }

    pub fn clear_Architectures(&mut self) {
        self.Architectures.clear();
    }

    // Param is passed by value, moved
    pub fn set_Architectures(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.Architectures = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Architectures(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.Architectures
    }

    // Take field
    pub fn take_Architectures(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.Architectures, ::std::vec::Vec::new())
    }

    // repeated string Flags = 3;

    pub fn Flags(&self) -> &[::std::string::String] {
        &self.Flags
    }

    pub fn clear_Flags(&mut self) {
        self.Flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_Flags(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.Flags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Flags(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.Flags
    }

    // Take field
    pub fn take_Flags(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.Flags, ::std::vec::Vec::new())
    }

    // repeated .grpc.LinuxSyscall Syscalls = 4;

    pub fn Syscalls(&self) -> &[LinuxSyscall] {
        &self.Syscalls
    }

    pub fn clear_Syscalls(&mut self) {
        self.Syscalls.clear();
    }

    // Param is passed by value, moved
    pub fn set_Syscalls(&mut self, v: ::std::vec::Vec<LinuxSyscall>) {
        self.Syscalls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Syscalls(&mut self) -> &mut ::std::vec::Vec<LinuxSyscall> {
        &mut self.Syscalls
    }

    // Take field
    pub fn take_Syscalls(&mut self) -> ::std::vec::Vec<LinuxSyscall> {
        ::std::mem::replace(&mut self.Syscalls, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DefaultAction",
            |m: &LinuxSeccomp| { &m.DefaultAction },
            |m: &mut LinuxSeccomp| { &mut m.DefaultAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Architectures",
            |m: &LinuxSeccomp| { &m.Architectures },
            |m: &mut LinuxSeccomp| { &mut m.Architectures },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Flags",
            |m: &LinuxSeccomp| { &m.Flags },
            |m: &mut LinuxSeccomp| { &mut m.Flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Syscalls",
            |m: &LinuxSeccomp| { &m.Syscalls },
            |m: &mut LinuxSeccomp| { &mut m.Syscalls },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxSeccomp>(
            "LinuxSeccomp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxSeccomp {
    const NAME: &'static str = "LinuxSeccomp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.DefaultAction = is.read_string()?;
                },
                18 => {
                    self.Architectures.push(is.read_string()?);
                },
                26 => {
                    self.Flags.push(is.read_string()?);
                },
                34 => {
                    self.Syscalls.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.DefaultAction.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.DefaultAction);
        }
        for value in &self.Architectures {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.Flags {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.Syscalls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.DefaultAction.is_empty() {
            os.write_string(1, &self.DefaultAction)?;
        }
        for v in &self.Architectures {
            os.write_string(2, &v)?;
        };
        for v in &self.Flags {
            os.write_string(3, &v)?;
        };
        for v in &self.Syscalls {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxSeccomp {
        LinuxSeccomp::new()
    }

    fn clear(&mut self) {
        self.DefaultAction.clear();
        self.Architectures.clear();
        self.Flags.clear();
        self.Syscalls.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxSeccomp {
        static instance: LinuxSeccomp = LinuxSeccomp {
            DefaultAction: ::std::string::String::new(),
            Architectures: ::std::vec::Vec::new(),
            Flags: ::std::vec::Vec::new(),
            Syscalls: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxSeccomp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxSeccomp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxSeccomp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxSeccomp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxSeccompArg)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxSeccompArg {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxSeccompArg.Index)
    pub Index: u64,
    // @@protoc_insertion_point(field:grpc.LinuxSeccompArg.Value)
    pub Value: u64,
    // @@protoc_insertion_point(field:grpc.LinuxSeccompArg.ValueTwo)
    pub ValueTwo: u64,
    // @@protoc_insertion_point(field:grpc.LinuxSeccompArg.Op)
    pub Op: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxSeccompArg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxSeccompArg {
    fn default() -> &'a LinuxSeccompArg {
        <LinuxSeccompArg as ::protobuf::Message>::default_instance()
    }
}

impl LinuxSeccompArg {
    pub fn new() -> LinuxSeccompArg {
        ::std::default::Default::default()
    }

    // uint64 Index = 1;

    pub fn Index(&self) -> u64 {
        self.Index
    }

    pub fn clear_Index(&mut self) {
        self.Index = 0;
    }

    // Param is passed by value, moved
    pub fn set_Index(&mut self, v: u64) {
        self.Index = v;
    }

    // uint64 Value = 2;

    pub fn Value(&self) -> u64 {
        self.Value
    }

    pub fn clear_Value(&mut self) {
        self.Value = 0;
    }

    // Param is passed by value, moved
    pub fn set_Value(&mut self, v: u64) {
        self.Value = v;
    }

    // uint64 ValueTwo = 3;

    pub fn ValueTwo(&self) -> u64 {
        self.ValueTwo
    }

    pub fn clear_ValueTwo(&mut self) {
        self.ValueTwo = 0;
    }

    // Param is passed by value, moved
    pub fn set_ValueTwo(&mut self, v: u64) {
        self.ValueTwo = v;
    }

    // string Op = 4;

    pub fn Op(&self) -> &str {
        &self.Op
    }

    pub fn clear_Op(&mut self) {
        self.Op.clear();
    }

    // Param is passed by value, moved
    pub fn set_Op(&mut self, v: ::std::string::String) {
        self.Op = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Op(&mut self) -> &mut ::std::string::String {
        &mut self.Op
    }

    // Take field
    pub fn take_Op(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Op, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Index",
            |m: &LinuxSeccompArg| { &m.Index },
            |m: &mut LinuxSeccompArg| { &mut m.Index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Value",
            |m: &LinuxSeccompArg| { &m.Value },
            |m: &mut LinuxSeccompArg| { &mut m.Value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ValueTwo",
            |m: &LinuxSeccompArg| { &m.ValueTwo },
            |m: &mut LinuxSeccompArg| { &mut m.ValueTwo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Op",
            |m: &LinuxSeccompArg| { &m.Op },
            |m: &mut LinuxSeccompArg| { &mut m.Op },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxSeccompArg>(
            "LinuxSeccompArg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxSeccompArg {
    const NAME: &'static str = "LinuxSeccompArg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Index = is.read_uint64()?;
                },
                16 => {
                    self.Value = is.read_uint64()?;
                },
                24 => {
                    self.ValueTwo = is.read_uint64()?;
                },
                34 => {
                    self.Op = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.Index != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.Index);
        }
        if self.Value != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.Value);
        }
        if self.ValueTwo != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.ValueTwo);
        }
        if !self.Op.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.Op);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.Index != 0 {
            os.write_uint64(1, self.Index)?;
        }
        if self.Value != 0 {
            os.write_uint64(2, self.Value)?;
        }
        if self.ValueTwo != 0 {
            os.write_uint64(3, self.ValueTwo)?;
        }
        if !self.Op.is_empty() {
            os.write_string(4, &self.Op)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxSeccompArg {
        LinuxSeccompArg::new()
    }

    fn clear(&mut self) {
        self.Index = 0;
        self.Value = 0;
        self.ValueTwo = 0;
        self.Op.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxSeccompArg {
        static instance: LinuxSeccompArg = LinuxSeccompArg {
            Index: 0,
            Value: 0,
            ValueTwo: 0,
            Op: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxSeccompArg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxSeccompArg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxSeccompArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxSeccompArg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxSyscall)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxSyscall {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxSyscall.Names)
    pub Names: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.LinuxSyscall.Action)
    pub Action: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.LinuxSyscall.Args)
    pub Args: ::std::vec::Vec<LinuxSeccompArg>,
    // message oneof groups
    pub ErrnoRet: ::std::option::Option<linux_syscall::ErrnoRet>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxSyscall.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxSyscall {
    fn default() -> &'a LinuxSyscall {
        <LinuxSyscall as ::protobuf::Message>::default_instance()
    }
}

impl LinuxSyscall {
    pub fn new() -> LinuxSyscall {
        ::std::default::Default::default()
    }

    // repeated string Names = 1;

    pub fn Names(&self) -> &[::std::string::String] {
        &self.Names
    }

    pub fn clear_Names(&mut self) {
        self.Names.clear();
    }

    // Param is passed by value, moved
    pub fn set_Names(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.Names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Names(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.Names
    }

    // Take field
    pub fn take_Names(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.Names, ::std::vec::Vec::new())
    }

    // string Action = 2;

    pub fn Action(&self) -> &str {
        &self.Action
    }

    pub fn clear_Action(&mut self) {
        self.Action.clear();
    }

    // Param is passed by value, moved
    pub fn set_Action(&mut self, v: ::std::string::String) {
        self.Action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Action(&mut self) -> &mut ::std::string::String {
        &mut self.Action
    }

    // Take field
    pub fn take_Action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Action, ::std::string::String::new())
    }

    // uint32 errnoret = 3;

    pub fn errnoret(&self) -> u32 {
        match self.ErrnoRet {
            ::std::option::Option::Some(linux_syscall::ErrnoRet::Errnoret(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_errnoret(&mut self) {
        self.ErrnoRet = ::std::option::Option::None;
    }

    pub fn has_errnoret(&self) -> bool {
        match self.ErrnoRet {
            ::std::option::Option::Some(linux_syscall::ErrnoRet::Errnoret(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_errnoret(&mut self, v: u32) {
        self.ErrnoRet = ::std::option::Option::Some(linux_syscall::ErrnoRet::Errnoret(v))
    }

    // repeated .grpc.LinuxSeccompArg Args = 4;

    pub fn Args(&self) -> &[LinuxSeccompArg] {
        &self.Args
    }

    pub fn clear_Args(&mut self) {
        self.Args.clear();
    }

    // Param is passed by value, moved
    pub fn set_Args(&mut self, v: ::std::vec::Vec<LinuxSeccompArg>) {
        self.Args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Args(&mut self) -> &mut ::std::vec::Vec<LinuxSeccompArg> {
        &mut self.Args
    }

    // Take field
    pub fn take_Args(&mut self) -> ::std::vec::Vec<LinuxSeccompArg> {
        ::std::mem::replace(&mut self.Args, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Names",
            |m: &LinuxSyscall| { &m.Names },
            |m: &mut LinuxSyscall| { &mut m.Names },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Action",
            |m: &LinuxSyscall| { &m.Action },
            |m: &mut LinuxSyscall| { &mut m.Action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "errnoret",
            LinuxSyscall::has_errnoret,
            LinuxSyscall::errnoret,
            LinuxSyscall::set_errnoret,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Args",
            |m: &LinuxSyscall| { &m.Args },
            |m: &mut LinuxSyscall| { &mut m.Args },
        ));
        oneofs.push(linux_syscall::ErrnoRet::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxSyscall>(
            "LinuxSyscall",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxSyscall {
    const NAME: &'static str = "LinuxSyscall";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Names.push(is.read_string()?);
                },
                18 => {
                    self.Action = is.read_string()?;
                },
                24 => {
                    self.ErrnoRet = ::std::option::Option::Some(linux_syscall::ErrnoRet::Errnoret(is.read_uint32()?));
                },
                34 => {
                    self.Args.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.Names {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.Action.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Action);
        }
        for value in &self.Args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.ErrnoRet {
            match v {
                &linux_syscall::ErrnoRet::Errnoret(v) => {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.Names {
            os.write_string(1, &v)?;
        };
        if !self.Action.is_empty() {
            os.write_string(2, &self.Action)?;
        }
        for v in &self.Args {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.ErrnoRet {
            match v {
                &linux_syscall::ErrnoRet::Errnoret(v) => {
                    os.write_uint32(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxSyscall {
        LinuxSyscall::new()
    }

    fn clear(&mut self) {
        self.Names.clear();
        self.Action.clear();
        self.ErrnoRet = ::std::option::Option::None;
        self.Args.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxSyscall {
        static instance: LinuxSyscall = LinuxSyscall {
            Names: ::std::vec::Vec::new(),
            Action: ::std::string::String::new(),
            Args: ::std::vec::Vec::new(),
            ErrnoRet: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxSyscall {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxSyscall").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxSyscall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxSyscall {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LinuxSyscall`
pub mod linux_syscall {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    #[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
    // @@protoc_insertion_point(oneof:grpc.LinuxSyscall.ErrnoRet)
    pub enum ErrnoRet {
        // @@protoc_insertion_point(oneof_field:grpc.LinuxSyscall.errnoret)
        Errnoret(u32),
    }

    impl ::protobuf::Oneof for ErrnoRet {
    }

    impl ::protobuf::OneofFull for ErrnoRet {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LinuxSyscall as ::protobuf::MessageFull>::descriptor().oneof_by_name("ErrnoRet").unwrap()).clone()
        }
    }

    impl ErrnoRet {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<ErrnoRet>("ErrnoRet")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
// @@protoc_insertion_point(message:grpc.LinuxIntelRdt)
#[cfg_attr(feature = "with-serde", serde(default))]
pub struct LinuxIntelRdt {
    // message fields
    // @@protoc_insertion_point(field:grpc.LinuxIntelRdt.L3CacheSchema)
    pub L3CacheSchema: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    // @@protoc_insertion_point(special_field:grpc.LinuxIntelRdt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinuxIntelRdt {
    fn default() -> &'a LinuxIntelRdt {
        <LinuxIntelRdt as ::protobuf::Message>::default_instance()
    }
}

impl LinuxIntelRdt {
    pub fn new() -> LinuxIntelRdt {
        ::std::default::Default::default()
    }

    // string L3CacheSchema = 1;

    pub fn L3CacheSchema(&self) -> &str {
        &self.L3CacheSchema
    }

    pub fn clear_L3CacheSchema(&mut self) {
        self.L3CacheSchema.clear();
    }

    // Param is passed by value, moved
    pub fn set_L3CacheSchema(&mut self, v: ::std::string::String) {
        self.L3CacheSchema = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_L3CacheSchema(&mut self) -> &mut ::std::string::String {
        &mut self.L3CacheSchema
    }

    // Take field
    pub fn take_L3CacheSchema(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.L3CacheSchema, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "L3CacheSchema",
            |m: &LinuxIntelRdt| { &m.L3CacheSchema },
            |m: &mut LinuxIntelRdt| { &mut m.L3CacheSchema },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinuxIntelRdt>(
            "LinuxIntelRdt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinuxIntelRdt {
    const NAME: &'static str = "LinuxIntelRdt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.L3CacheSchema = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.L3CacheSchema.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.L3CacheSchema);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.L3CacheSchema.is_empty() {
            os.write_string(1, &self.L3CacheSchema)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinuxIntelRdt {
        LinuxIntelRdt::new()
    }

    fn clear(&mut self) {
        self.L3CacheSchema.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinuxIntelRdt {
        static instance: LinuxIntelRdt = LinuxIntelRdt {
            L3CacheSchema: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinuxIntelRdt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinuxIntelRdt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinuxIntelRdt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxIntelRdt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\toci.proto\x12\x04grpc\x1a\"gogo/protobuf/gogoproto/gogo.proto\"\xc7\
    \x03\n\x04Spec\x12\x18\n\x07Version\x18\x01\x20\x01(\tR\x07Version\x12'\
    \n\x07Process\x18\x02\x20\x01(\x0b2\r.grpc.ProcessR\x07Process\x12\x1e\n\
    \x04Root\x18\x03\x20\x01(\x0b2\n.grpc.RootR\x04Root\x12\x1a\n\x08Hostnam\
    e\x18\x04\x20\x01(\tR\x08Hostname\x12)\n\x06Mounts\x18\x05\x20\x03(\x0b2\
    \x0b.grpc.MountR\x06MountsB\x04\xc8\xde\x1f\0\x12!\n\x05Hooks\x18\x06\
    \x20\x01(\x0b2\x0b.grpc.HooksR\x05Hooks\x12=\n\x0bAnnotations\x18\x07\
    \x20\x03(\x0b2\x1b.grpc.Spec.AnnotationsEntryR\x0bAnnotations\x12!\n\x05\
    Linux\x18\x08\x20\x01(\x0b2\x0b.grpc.LinuxR\x05Linux\x12'\n\x07Solaris\
    \x18\t\x20\x01(\x0b2\r.grpc.SolarisR\x07Solaris\x12'\n\x07Windows\x18\n\
    \x20\x01(\x0b2\r.grpc.WindowsR\x07Windows\x1a>\n\x10AnnotationsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\"\xba\x03\n\x07Process\x12\x1a\n\x08Terminal\
    \x18\x01\x20\x01(\x08R\x08Terminal\x12+\n\x0bConsoleSize\x18\x02\x20\x01\
    (\x0b2\t.grpc.BoxR\x0bConsoleSize\x12$\n\x04User\x18\x03\x20\x01(\x0b2\n\
    .grpc.UserR\x04UserB\x04\xc8\xde\x1f\0\x12\x12\n\x04Args\x18\x04\x20\x03\
    (\tR\x04Args\x12\x10\n\x03Env\x18\x05\x20\x03(\tR\x03Env\x12\x10\n\x03Cw\
    d\x18\x06\x20\x01(\tR\x03Cwd\x12;\n\x0cCapabilities\x18\x07\x20\x01(\x0b\
    2\x17.grpc.LinuxCapabilitiesR\x0cCapabilities\x121\n\x07Rlimits\x18\x08\
    \x20\x03(\x0b2\x11.grpc.POSIXRlimitR\x07RlimitsB\x04\xc8\xde\x1f\0\x12(\
    \n\x0fNoNewPrivileges\x18\t\x20\x01(\x08R\x0fNoNewPrivileges\x12(\n\x0fA\
    pparmorProfile\x18\n\x20\x01(\tR\x0fApparmorProfile\x12\x20\n\x0bOOMScor\
    eAdj\x18\x0b\x20\x01(\x03R\x0bOOMScoreAdj\x12\"\n\x0cSelinuxLabel\x18\
    \x0c\x20\x01(\tR\x0cSelinuxLabel\"3\n\x03Box\x12\x16\n\x06Height\x18\x01\
    \x20\x01(\rR\x06Height\x12\x14\n\x05Width\x18\x02\x20\x01(\rR\x05Width\"\
    n\n\x04User\x12\x10\n\x03UID\x18\x01\x20\x01(\rR\x03UID\x12\x10\n\x03GID\
    \x18\x02\x20\x01(\rR\x03GID\x12&\n\x0eAdditionalGids\x18\x03\x20\x03(\rR\
    \x0eAdditionalGids\x12\x1a\n\x08Username\x18\x04\x20\x01(\tR\x08Username\
    \"\xa7\x01\n\x11LinuxCapabilities\x12\x1a\n\x08Bounding\x18\x01\x20\x03(\
    \tR\x08Bounding\x12\x1c\n\tEffective\x18\x02\x20\x03(\tR\tEffective\x12\
    \x20\n\x0bInheritable\x18\x03\x20\x03(\tR\x0bInheritable\x12\x1c\n\tPerm\
    itted\x18\x04\x20\x03(\tR\tPermitted\x12\x18\n\x07Ambient\x18\x05\x20\
    \x03(\tR\x07Ambient\"I\n\x0bPOSIXRlimit\x12\x12\n\x04Type\x18\x01\x20\
    \x01(\tR\x04Type\x12\x12\n\x04Hard\x18\x02\x20\x01(\x04R\x04Hard\x12\x12\
    \n\x04Soft\x18\x03\x20\x01(\x04R\x04Soft\"o\n\x05Mount\x12\x20\n\x0bdest\
    ination\x18\x01\x20\x01(\tR\x0bdestination\x12\x16\n\x06source\x18\x02\
    \x20\x01(\tR\x06source\x12\x12\n\x04type\x18\x03\x20\x01(\tR\x04type\x12\
    \x18\n\x07options\x18\x04\x20\x03(\tR\x07options\"6\n\x04Root\x12\x12\n\
    \x04Path\x18\x01\x20\x01(\tR\x04Path\x12\x1a\n\x08Readonly\x18\x02\x20\
    \x01(\x08R\x08Readonly\"\xc1\x02\n\x05Hooks\x12,\n\x08Prestart\x18\x01\
    \x20\x03(\x0b2\n.grpc.HookR\x08PrestartB\x04\xc8\xde\x1f\0\x12.\n\tPosts\
    tart\x18\x02\x20\x03(\x0b2\n.grpc.HookR\tPoststartB\x04\xc8\xde\x1f\0\
    \x12,\n\x08Poststop\x18\x03\x20\x03(\x0b2\n.grpc.HookR\x08PoststopB\x04\
    \xc8\xde\x1f\0\x126\n\rCreateRuntime\x18\x04\x20\x03(\x0b2\n.grpc.HookR\
    \rCreateRuntimeB\x04\xc8\xde\x1f\0\x12:\n\x0fCreateContainer\x18\x05\x20\
    \x03(\x0b2\n.grpc.HookR\x0fCreateContainerB\x04\xc8\xde\x1f\0\x128\n\x0e\
    StartContainer\x18\x06\x20\x03(\x0b2\n.grpc.HookR\x0eStartContainerB\x04\
    \xc8\xde\x1f\0\"Z\n\x04Hook\x12\x12\n\x04Path\x18\x01\x20\x01(\tR\x04Pat\
    h\x12\x12\n\x04Args\x18\x02\x20\x03(\tR\x04Args\x12\x10\n\x03Env\x18\x03\
    \x20\x03(\tR\x03Env\x12\x18\n\x07Timeout\x18\x04\x20\x01(\x03R\x07Timeou\
    t\"\xa9\x05\n\x05Linux\x12<\n\x0bUIDMappings\x18\x01\x20\x03(\x0b2\x14.g\
    rpc.LinuxIDMappingR\x0bUIDMappingsB\x04\xc8\xde\x1f\0\x12<\n\x0bGIDMappi\
    ngs\x18\x02\x20\x03(\x0b2\x14.grpc.LinuxIDMappingR\x0bGIDMappingsB\x04\
    \xc8\xde\x1f\0\x12/\n\x06Sysctl\x18\x03\x20\x03(\x0b2\x17.grpc.Linux.Sys\
    ctlEntryR\x06Sysctl\x122\n\tResources\x18\x04\x20\x01(\x0b2\x14.grpc.Lin\
    uxResourcesR\tResources\x12\x20\n\x0bCgroupsPath\x18\x05\x20\x01(\tR\x0b\
    CgroupsPath\x12:\n\nNamespaces\x18\x06\x20\x03(\x0b2\x14.grpc.LinuxNames\
    paceR\nNamespacesB\x04\xc8\xde\x1f\0\x121\n\x07Devices\x18\x07\x20\x03(\
    \x0b2\x11.grpc.LinuxDeviceR\x07DevicesB\x04\xc8\xde\x1f\0\x12,\n\x07Secc\
    omp\x18\x08\x20\x01(\x0b2\x12.grpc.LinuxSeccompR\x07Seccomp\x12,\n\x11Ro\
    otfsPropagation\x18\t\x20\x01(\tR\x11RootfsPropagation\x12\x20\n\x0bMask\
    edPaths\x18\n\x20\x03(\tR\x0bMaskedPaths\x12$\n\rReadonlyPaths\x18\x0b\
    \x20\x03(\tR\rReadonlyPaths\x12\x1e\n\nMountLabel\x18\x0c\x20\x01(\tR\nM\
    ountLabel\x12/\n\x08IntelRdt\x18\r\x20\x01(\x0b2\x13.grpc.LinuxIntelRdtR\
    \x08IntelRdt\x1a9\n\x0bSysctlEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x1f\
    \n\x07Windows\x12\x14\n\x05dummy\x18\x01\x20\x01(\tR\x05dummy\"\x1f\n\
    \x07Solaris\x12\x14\n\x05dummy\x18\x01\x20\x01(\tR\x05dummy\"^\n\x0eLinu\
    xIDMapping\x12\x16\n\x06HostID\x18\x01\x20\x01(\rR\x06HostID\x12\x20\n\
    \x0bContainerID\x18\x02\x20\x01(\rR\x0bContainerID\x12\x12\n\x04Size\x18\
    \x03\x20\x01(\rR\x04Size\"8\n\x0eLinuxNamespace\x12\x12\n\x04Type\x18\
    \x01\x20\x01(\tR\x04Type\x12\x12\n\x04Path\x18\x02\x20\x01(\tR\x04Path\"\
    \xa1\x01\n\x0bLinuxDevice\x12\x12\n\x04Path\x18\x01\x20\x01(\tR\x04Path\
    \x12\x12\n\x04Type\x18\x02\x20\x01(\tR\x04Type\x12\x14\n\x05Major\x18\
    \x03\x20\x01(\x03R\x05Major\x12\x14\n\x05Minor\x18\x04\x20\x01(\x03R\x05\
    Minor\x12\x1a\n\x08FileMode\x18\x05\x20\x01(\rR\x08FileMode\x12\x10\n\
    \x03UID\x18\x06\x20\x01(\rR\x03UID\x12\x10\n\x03GID\x18\x07\x20\x01(\rR\
    \x03GID\"\xdf\x02\n\x0eLinuxResources\x127\n\x07Devices\x18\x01\x20\x03(\
    \x0b2\x17.grpc.LinuxDeviceCgroupR\x07DevicesB\x04\xc8\xde\x1f\0\x12)\n\
    \x06Memory\x18\x02\x20\x01(\x0b2\x11.grpc.LinuxMemoryR\x06Memory\x12\x20\
    \n\x03CPU\x18\x03\x20\x01(\x0b2\x0e.grpc.LinuxCPUR\x03CPU\x12#\n\x04Pids\
    \x18\x04\x20\x01(\x0b2\x0f.grpc.LinuxPidsR\x04Pids\x12,\n\x07BlockIO\x18\
    \x05\x20\x01(\x0b2\x12.grpc.LinuxBlockIOR\x07BlockIO\x12F\n\x0eHugepageL\
    imits\x18\x06\x20\x03(\x0b2\x18.grpc.LinuxHugepageLimitR\x0eHugepageLimi\
    tsB\x04\xc8\xde\x1f\0\x12,\n\x07Network\x18\x07\x20\x01(\x0b2\x12.grpc.L\
    inuxNetworkR\x07Network\"\xdb\x01\n\x0bLinuxMemory\x12\x14\n\x05Limit\
    \x18\x01\x20\x01(\x03R\x05Limit\x12\x20\n\x0bReservation\x18\x02\x20\x01\
    (\x03R\x0bReservation\x12\x12\n\x04Swap\x18\x03\x20\x01(\x03R\x04Swap\
    \x12\x16\n\x06Kernel\x18\x04\x20\x01(\x03R\x06Kernel\x12\x1c\n\tKernelTC\
    P\x18\x05\x20\x01(\x03R\tKernelTCP\x12\x1e\n\nSwappiness\x18\x06\x20\x01\
    (\x04R\nSwappiness\x12*\n\x10DisableOOMKiller\x18\x07\x20\x01(\x08R\x10D\
    isableOOMKiller\"\xca\x01\n\x08LinuxCPU\x12\x16\n\x06Shares\x18\x01\x20\
    \x01(\x04R\x06Shares\x12\x14\n\x05Quota\x18\x02\x20\x01(\x03R\x05Quota\
    \x12\x16\n\x06Period\x18\x03\x20\x01(\x04R\x06Period\x12(\n\x0fRealtimeR\
    untime\x18\x04\x20\x01(\x03R\x0fRealtimeRuntime\x12&\n\x0eRealtimePeriod\
    \x18\x05\x20\x01(\x04R\x0eRealtimePeriod\x12\x12\n\x04Cpus\x18\x06\x20\
    \x01(\tR\x04Cpus\x12\x12\n\x04Mems\x18\x07\x20\x01(\tR\x04Mems\"w\n\x11L\
    inuxWeightDevice\x12\x14\n\x05Major\x18\x01\x20\x01(\x03R\x05Major\x12\
    \x14\n\x05Minor\x18\x02\x20\x01(\x03R\x05Minor\x12\x16\n\x06Weight\x18\
    \x03\x20\x01(\rR\x06Weight\x12\x1e\n\nLeafWeight\x18\x04\x20\x01(\rR\nLe\
    afWeight\"U\n\x13LinuxThrottleDevice\x12\x14\n\x05Major\x18\x01\x20\x01(\
    \x03R\x05Major\x12\x14\n\x05Minor\x18\x02\x20\x01(\x03R\x05Minor\x12\x12\
    \n\x04Rate\x18\x03\x20\x01(\x04R\x04Rate\"\xed\x03\n\x0cLinuxBlockIO\x12\
    \x16\n\x06Weight\x18\x01\x20\x01(\rR\x06Weight\x12\x1e\n\nLeafWeight\x18\
    \x02\x20\x01(\rR\nLeafWeight\x12A\n\x0cWeightDevice\x18\x03\x20\x03(\x0b\
    2\x17.grpc.LinuxWeightDeviceR\x0cWeightDeviceB\x04\xc8\xde\x1f\0\x12U\n\
    \x15ThrottleReadBpsDevice\x18\x04\x20\x03(\x0b2\x19.grpc.LinuxThrottleDe\
    viceR\x15ThrottleReadBpsDeviceB\x04\xc8\xde\x1f\0\x12W\n\x16ThrottleWrit\
    eBpsDevice\x18\x05\x20\x03(\x0b2\x19.grpc.LinuxThrottleDeviceR\x16Thrott\
    leWriteBpsDeviceB\x04\xc8\xde\x1f\0\x12W\n\x16ThrottleReadIOPSDevice\x18\
    \x06\x20\x03(\x0b2\x19.grpc.LinuxThrottleDeviceR\x16ThrottleReadIOPSDevi\
    ceB\x04\xc8\xde\x1f\0\x12Y\n\x17ThrottleWriteIOPSDevice\x18\x07\x20\x03(\
    \x0b2\x19.grpc.LinuxThrottleDeviceR\x17ThrottleWriteIOPSDeviceB\x04\xc8\
    \xde\x1f\0\"!\n\tLinuxPids\x12\x14\n\x05Limit\x18\x01\x20\x01(\x03R\x05L\
    imit\"\x81\x01\n\x11LinuxDeviceCgroup\x12\x14\n\x05Allow\x18\x01\x20\x01\
    (\x08R\x05Allow\x12\x12\n\x04Type\x18\x02\x20\x01(\tR\x04Type\x12\x14\n\
    \x05Major\x18\x03\x20\x01(\x03R\x05Major\x12\x14\n\x05Minor\x18\x04\x20\
    \x01(\x03R\x05Minor\x12\x16\n\x06Access\x18\x05\x20\x01(\tR\x06Access\"l\
    \n\x0cLinuxNetwork\x12\x18\n\x07ClassID\x18\x01\x20\x01(\rR\x07ClassID\
    \x12B\n\nPriorities\x18\x02\x20\x03(\x0b2\x1c.grpc.LinuxInterfacePriorit\
    yR\nPrioritiesB\x04\xc8\xde\x1f\0\"F\n\x12LinuxHugepageLimit\x12\x1a\n\
    \x08Pagesize\x18\x01\x20\x01(\tR\x08Pagesize\x12\x14\n\x05Limit\x18\x02\
    \x20\x01(\x04R\x05Limit\"H\n\x16LinuxInterfacePriority\x12\x12\n\x04Name\
    \x18\x01\x20\x01(\tR\x04Name\x12\x1a\n\x08Priority\x18\x02\x20\x01(\rR\
    \x08Priority\"\xa6\x01\n\x0cLinuxSeccomp\x12$\n\rDefaultAction\x18\x01\
    \x20\x01(\tR\rDefaultAction\x12$\n\rArchitectures\x18\x02\x20\x03(\tR\rA\
    rchitectures\x12\x14\n\x05Flags\x18\x03\x20\x03(\tR\x05Flags\x124\n\x08S\
    yscalls\x18\x04\x20\x03(\x0b2\x12.grpc.LinuxSyscallR\x08SyscallsB\x04\
    \xc8\xde\x1f\0\"i\n\x0fLinuxSeccompArg\x12\x14\n\x05Index\x18\x01\x20\
    \x01(\x04R\x05Index\x12\x14\n\x05Value\x18\x02\x20\x01(\x04R\x05Value\
    \x12\x1a\n\x08ValueTwo\x18\x03\x20\x01(\x04R\x08ValueTwo\x12\x0e\n\x02Op\
    \x18\x04\x20\x01(\tR\x02Op\"\x97\x01\n\x0cLinuxSyscall\x12\x14\n\x05Name\
    s\x18\x01\x20\x03(\tR\x05Names\x12\x16\n\x06Action\x18\x02\x20\x01(\tR\
    \x06Action\x12\x1c\n\x08errnoret\x18\x03\x20\x01(\rH\0R\x08errnoret\x12/\
    \n\x04Args\x18\x04\x20\x03(\x0b2\x15.grpc.LinuxSeccompArgR\x04ArgsB\x04\
    \xc8\xde\x1f\0B\n\n\x08ErrnoRet\"5\n\rLinuxIntelRdt\x12$\n\rL3CacheSchem\
    a\x18\x01\x20\x01(\tR\rL3CacheSchemaBpZ^github.com/kata-containers/kata-\
    containers/src/runtime/virtcontainers/pkg/agent/protocols/grpc\xf8\xe1\
    \x1e\x01\xa8\xe2\x1e\x01\xc0\xe2\x1e\x01\xb8\xe2\x1e\x01b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::gogo::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(31);
            messages.push(Spec::generated_message_descriptor_data());
            messages.push(Process::generated_message_descriptor_data());
            messages.push(Box::generated_message_descriptor_data());
            messages.push(User::generated_message_descriptor_data());
            messages.push(LinuxCapabilities::generated_message_descriptor_data());
            messages.push(POSIXRlimit::generated_message_descriptor_data());
            messages.push(Mount::generated_message_descriptor_data());
            messages.push(Root::generated_message_descriptor_data());
            messages.push(Hooks::generated_message_descriptor_data());
            messages.push(Hook::generated_message_descriptor_data());
            messages.push(Linux::generated_message_descriptor_data());
            messages.push(Windows::generated_message_descriptor_data());
            messages.push(Solaris::generated_message_descriptor_data());
            messages.push(LinuxIDMapping::generated_message_descriptor_data());
            messages.push(LinuxNamespace::generated_message_descriptor_data());
            messages.push(LinuxDevice::generated_message_descriptor_data());
            messages.push(LinuxResources::generated_message_descriptor_data());
            messages.push(LinuxMemory::generated_message_descriptor_data());
            messages.push(LinuxCPU::generated_message_descriptor_data());
            messages.push(LinuxWeightDevice::generated_message_descriptor_data());
            messages.push(LinuxThrottleDevice::generated_message_descriptor_data());
            messages.push(LinuxBlockIO::generated_message_descriptor_data());
            messages.push(LinuxPids::generated_message_descriptor_data());
            messages.push(LinuxDeviceCgroup::generated_message_descriptor_data());
            messages.push(LinuxNetwork::generated_message_descriptor_data());
            messages.push(LinuxHugepageLimit::generated_message_descriptor_data());
            messages.push(LinuxInterfacePriority::generated_message_descriptor_data());
            messages.push(LinuxSeccomp::generated_message_descriptor_data());
            messages.push(LinuxSeccompArg::generated_message_descriptor_data());
            messages.push(LinuxSyscall::generated_message_descriptor_data());
            messages.push(LinuxIntelRdt::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}